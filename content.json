{"meta":{"title":"Le-More","subtitle":null,"description":"坚持就是胜利 When you believe","author":"max-xue","url":"http://blog.le-more.com"},"pages":[{"title":"关于","date":"2019-10-10T06:15:26.000Z","updated":"2019-11-08T09:59:31.040Z","comments":true,"path":"about/index.html","permalink":"http://blog.le-more.com/about/index.html","excerpt":"","text":"关于我西江月·世事一场大梦世事一场大梦，人生几度秋凉？夜来风叶已鸣廊。看取眉头鬓上。酒贱常愁客少，月明多被云妨。中秋谁与共孤光。把盏凄然北望。 我叫薛刚，从事游戏行业，以搬砖为生。工作十余载，四处飘零终未得安。 心中之梦，虽遥不可及，唯有坚持，方能成就！ welcome to contact me.Facebook:max.xue.gangEmail: xue_huashan@163.com QQ群：239759131 技术交流群欢迎您"}],"posts":[{"title":".Net 4.x Equivalent语法糖","slug":"u3d/csharp_4x_candy","date":"2019-11-09T02:18:11.000Z","updated":"2019-11-09T02:38:23.520Z","comments":true,"path":"2019/11/09/u3d/csharp_4x_candy/","link":"","permalink":"http://blog.le-more.com/2019/11/09/u3d/csharp_4x_candy/","excerpt":"","text":"Unity2017的Scripting Runtime Version支持.net 4.6。运行时的提升随之带来了新的语法糖。下边介绍主要常见的几种。 1 Null条件运算符 // 原写法 var str = &quot;string&quot;; if (config != null) { str = config.Value; } // 新写法 var str = config?.Value; if (str == null) { str = &quot;string&quot;; } // 结合??写法 var str = config?.Value ?? &quot;string&quot;;2 索引初始化 // 原写法 var dic = new Dictionary&lt;string, int&gt;() { {&quot;a&quot;, 1}, {&quot;b&quot;, 1}, {&quot;c&quot;, 1}, }; // 新写法 var dic = new Dictionary&lt;string, int&gt;() { [&quot;a&quot;] = 1, [&quot;b&quot;] = 2, }; // 还可用于List。虽然大部分情况下都没有意义 var list = new List&lt;int&gt;() { 10, 20, 30, 40 }; var list = new List&lt;int&gt;() { [0] = 10, [1] = 10, [2] = 10, [3] = 10, };3 nameof表达式 public class ClassName { public string StringValue; } var className = nameof(ClassName); // 返回ClassName var fieldName = nameof(ClassName.StringValue); // 返回StringValue4 字符串格式化 // 原写法 var str = string.Format(&quot;{0} : {1}&quot;, value1, value2); // 新写法 var str = $&quot;{value1} : {value2}&quot;; 转载自:Unity2017新语法糖","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[]},{"title":"Cocos Creator 开发问题汇总","slug":"cocos/cocos_dev_summary","date":"2019-10-25T08:31:13.000Z","updated":"2019-11-08T09:59:30.970Z","comments":true,"path":"2019/10/25/cocos/cocos_dev_summary/","link":"","permalink":"http://blog.le-more.com/2019/10/25/cocos/cocos_dev_summary/","excerpt":"","text":"总结开发中遇到的问题1.Manifest merger failed with multiple errors, see logs在Android Studios 命令中执行（追踪错误详情）: ./gradlew processDebugManifest --stacktrace2.Android Apk ICON尺寸 密度 尺寸 mipmap-mdpi 48 * 48 mipmap-hdpi 72 * 72 mipmap-mdpi 48 * 48 mipmap-xhdpi 96 * 96 mipmap-xxhdpi 144 * 144 mipmap-xxxhdpi 192 * 192 3.Cocos Creator插件，查看运行场景中节点 ccInspector_v1.1","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Android 破解APK包","slug":"cocos/apk_unpacking","date":"2019-10-24T12:10:00.000Z","updated":"2019-11-08T09:59:30.966Z","comments":true,"path":"2019/10/24/cocos/apk_unpacking/","link":"","permalink":"http://blog.le-more.com/2019/10/24/cocos/apk_unpacking/","excerpt":"","text":"APK 解包1.准备工具软件 apktool 解压APK dex2jar class 转为Jar jd-gui: 查看Jar代码 2.解压指定APK apktool d target.apk 3.将classes.dex打包成jar包 d2j-dex2jar.bat classes.dex 4.使用jd-gui查看Jar","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"使用Hexo搭建网站个人总结","slug":"top/0001_hexo_guide","date":"2019-10-11T03:58:48.000Z","updated":"2019-11-08T13:45:32.614Z","comments":true,"path":"2019/10/11/top/0001_hexo_guide/","link":"","permalink":"http://blog.le-more.com/2019/10/11/top/0001_hexo_guide/","excerpt":"","text":"使用Hexo搭建网站个人总结1.安装环境 Git Node.js(因平时开发环境用这两个环境，安装过程省略) 2.安装Hexo $:npm install -g hexo-cli3.创建Web项目创建一个空的文件夹MyWeb，右键打开Git Bash Here(成功安装Git后，右键菜单有这个选项) $ hexo init MyWeb $ cd MyWeb $ npm install执行后目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes安装其他依赖(根据需要) $ npm install hexo-wordcount --save $ npm install hexo-generator-archive --save $ npm install hexo-generator-category --save $ npm install hexo-generator-feed --save $ npm install hexo-generator-index --save $ npm install hexo-generator-json-content --save $ npm install hexo-generator-search --save $ npm install hexo-generator-sitemap --save $ npm install hexo-generator-tag --save $ npm install hexo-generator-topindex --save $ npm install hexo-renderer-ejs --save $ npm install hexo-renderer-marked --save $ npm install hexo-renderer-stylus --save $ npm install hexo-server --save $ npm install hexo-wordcount --save4.复制主题 以我使用的3-Hexo为例 git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo5.配置主题 修改MyWeb根目录下文件_config.yml，如下 theme: 3-hexo3-hexo主题详细配置参考 6.创建页面 hexo new page --path other/0001_hexo_guide编写内容参考Markdown语法 7.生成预览 $hexo clean &amp;&amp; hexo g &amp;&amp; hexo s打开http://localhost:4000可预览效果 8.发布到Git 使用Github创建项目,因很久以前就创建过，过程略,我的地址 修改MyWeb根目录下文件_config.yml，如下 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/max-xue/max-xue.github.io branch: master message: &quot;Site updateed: {{ now('YYYY-MM-DD HH:mm:ss') }}&quot;执行 $hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.le-more.com/tags/hexo/"},{"name":"guide","slug":"guide","permalink":"http://blog.le-more.com/tags/guide/"}]},{"title":"新的家园","slug":"top/0002_new_home","date":"2019-10-11T03:54:03.000Z","updated":"2019-11-09T03:13:40.323Z","comments":true,"path":"2019/10/11/top/0002_new_home/","link":"","permalink":"http://blog.le-more.com/2019/10/11/top/0002_new_home/","excerpt":"","text":"又是一个新的开始总想在网上给自己找一个家，能随意留下自己的印迹， 于是经历CSDN（各种受限制和讨厌的广告） 愤而租服务器，备域名，搭Wordpress（但又有各种成本） 转而发现 Github Pages就能给自己一个安静而又自由的空间（关键是免费） 从此以后这里就是我的新家了。","categories":[],"tags":[{"name":"mylife","slug":"mylife","permalink":"http://blog.le-more.com/tags/mylife/"}]},{"title":"Cocos Creator 打包OBB","slug":"cocos/cocos-creator-e6-89-85obb","date":"2019-09-23T13:29:52.000Z","updated":"2019-11-09T03:00:59.217Z","comments":true,"path":"2019/09/23/cocos/cocos-creator-e6-89-85obb/","link":"","permalink":"http://blog.le-more.com/2019/09/23/cocos/cocos-creator-e6-89-85obb/","excerpt":"","text":"1.app/build.gradle,打包APK排除资源，注释复制资源 variant.mergeAssets.doLast { // copy { // from &quot;${buildDir}/../../../../../res&quot; // into &quot;${buildDir}/intermediates/assets/${variant.dirName}/res&quot; //// exclude &quot;**/resources/gb/res/audio_down&quot; // }2.build 生成apk 3.生成OBB jsb-link \\- res \\- src \\- main \\- projectscript目录:C:\\CocosCreator\\resources\\cocos2d-x\\cocos\\scripting\\js-bindings\\script 4.压缩成zip,改成obb 5.安装测试： C:\\\\Users\\\\xuegang-pc\\\\AppData\\\\Local\\\\Android\\\\Sdk\\\\platform-tools&gt;adb shell cd storage/emulated/0/Android/obb mkdir com.maxx.test adb push d:\\\\main.1.com.maxx.test.obb /storage/emulated/0/Android/obb/com.maxx.test 先安装APK 在手机U盘中创建Android/obb/com.maxx.test 目录,复制main.1.com.maxx.test.obb文件","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Unity优化汇总","slug":"u3d/unity-e4-bc-98-e5-8c-96-e6","date":"2019-07-20T13:51:54.000Z","updated":"2019-11-08T09:59:31.017Z","comments":true,"path":"2019/07/20/u3d/unity-e4-bc-98-e5-8c-96-e6/","link":"","permalink":"http://blog.le-more.com/2019/07/20/u3d/unity-e4-bc-98-e5-8c-96-e6/","excerpt":"","text":"最简单的优化建议： 1.PC平台的话保持场景中显示的顶点数少于200K~3M，移动设备的话少于10W，一切取决于你的目标GPU与CPU。 2.如果你用U3D自带的SHADER，在表现不差的情况下选择Mobile或Unlit目录下的。它们更高效。 3.尽可能共用材质。 4.将不需要移动的物体设为Static，让引擎可以进行其批处理。 5.尽可能不用灯光。 6.动态灯光更加不要了。 7.尝试用压缩贴图格式，或用16位代替32位。 8.如果不需要别用雾效(fog) 9.尝试用OcclusionCulling,在房间过道多遮挡物体多的场景非常有用。若不当反而会增加负担。 10.用天空盒去“褪去”远处的物体。 11.shader中用贴图混合的方式去代替多重通道计算。 12.shader中注意float/half/fixed的使用。 13.shader中不要用复杂的计算pow,sin,cos,tan,log等。 14.shader中越少Fragment越好。 15.注意是否有多余的动画脚本，模型自动导入到U3D会有动画脚本，大量的话会严重影响消耗CPU计算。 16.注意碰撞体的碰撞层，不必要的碰撞检测请舍去。 1.为什么需要针对CPU（中央处理器）与GPU（图形处理器）优化？ CPU和GPU都有各自的计算和传输瓶颈，不同的CPU或GPU他们的性能都不一样，所以你的游戏需要为你目标用户的CPU与GPU能力进行针对开发。 2.CPU与GPU的限制 GPU一般具有填充率(Fillrate)和内存带宽(Memory Bandwidth)的限制，如果你的游戏在低质量表现的情况下会快很多，那么，你很可能需要限制你在GPU的填充率。 CPU一般被所需要渲染物体的个数限制，CPU给GPU发送渲染物体命令叫做DrawCalls。一般来说DrawCalls数量是需要控制的，在能表现效果的前提下越少越好。通常来说，电脑平台上DrawCalls几千个之内，移动平台上DrawCalls几百个之内。这样就差不多了。当然以上并不是绝对的，仅作一个参考。 往往渲染(Rendering)并不是一个问题，无论是在GPU和CPU上。很可能是你的脚本代码效率的问题，用Profiler查看下。 关于Profiler介绍：http://docs.unity3d.com/Documentation/Manual/Profiler.html 需要注意的是: 在GPU中显示的RenderTexture.SetActive()占用率很高，是因为你同时打开了编辑窗口的原因，而不是U3D的BUG。 3.关于顶点数量和顶点计算 CPU和GPU对顶点的计算处理都很多。GPU中渲染的顶点数取决于GPU性能和SHADER的复杂程度，一般来说，每帧之内，在PC上几百万顶点内，在移动平台上不超过10万顶点。 CPU中的计算主要是在蒙皮骨骼计算，布料模拟，顶点动画，粒子模拟等。GPU则在各种顶点变换、光照、贴图混合等。 【个人认为，具体还是看各位的项目需求，假设你项目的是3D游戏。你游戏需要兼容低配置的硬件、流畅运行、控制硬件发热的话，还要达到一定效果（LIGHTMAP+雾效），那么顶点数必定不能高。此时同屏2W顶点我认为是个比较合适的数目，DRAWCALL最好低于70。另，控制发热请控制最高上限的帧率，流畅的话，帧率其实不需要太高的。】 4.针对CPU的优化——减少DRAW CALL 的数量 为了渲染物体到显示器上，CPU需要做一些工作,如区分哪个东西需要渲染、区分开物体是否受光照影响、使用哪个SHADER并且为SHADER传参、发送绘图命令告诉显示驱动，然后发送命令告诉显卡删除等这些。 假设你有一个上千三角面的模型却用上千个三角型模型来代替，在GPU上花费是差不多的，但是在CPU上则是极其不一样，消耗会大很多很多。为了让CPU更少的工作，需要减少可见物的数目： a.合并相近的模型，手动在模型编辑器中合并或者使用UNITY的Draw call批处理达到相同效果(Draw call batching)。具体方法和注意事项查看以下链接： Draw call batching : http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html b.在项目中使用更少的材质(material)，将几个分开的贴图合成一个较大的图集等方式处理。 如果你需要通过脚本来控制单个材质属性，需要注意改变Renderer.material将会造成一份材质的拷贝。因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。 有一个合并模型材质不错的插件叫Mesh Baker，大家可以考虑试下。 c.尽量少用一些渲染步骤，例如reflections,shadows,per-pixel light 等。 d.Draw call batching的合并物体，会使每个物体（合并后的物体）至少有几百个三角面。 假设合并的两个物体（手动合并）但不共享材质，不会有性能表现上的提升。多材质的物体相当于两个物体不用一个贴图。所以，为了提升CPU的性能，你应该确保这些物体使用同样的贴图。 另外，用灯光将会取消(break)引擎的DRAW CALL BATCH，至于为什么，查看以下： Forward Rendering Path Details: http://docs.unity3d.com/Documentation/Components/RenderTech-ForwardRendering.html e.使用相关剔除数量直接减少Draw Call数量，下文有相关提及。 5.优化几何模型 最基本的两个优化准则： a.不要有不必要的三角面。 b.UV贴图中的接缝和硬边越少越好。 需要注意的是，图形硬件需要处理顶点数并跟硬件报告说的并不一样。不是硬件说能渲染几个点就是几个点。模型处理应用通展示的是几何顶点数量。例如，一个由一些不同顶点构成的模型。在显卡中，一些集合顶点将会被分离(split)成两个或者更多逻辑顶点用作渲染。如果有法线、UV坐标、顶点色的话，这个顶点必须会被分离。所以在游戏中处理的实际数量显然要多很多。 6.关于光照 若不用光肯定是最快的。移动端优化可以采用用光照贴图(Lightmapping)去烘培一个静态的贴图，以代替每次的光照计算，在U3D中只需要非常短的时间则能生成。这个方法能大大提高效率，而且有着更好的表现效果（平滑过渡处理，还有附加阴影等）。 在移动设备上和低端电脑上尽量不要在场景中用真光，用光照贴图。这个方法大大节省了CPU和GPU的计算，CPU得到了更少的DRAWCALL，GPU则需要更少顶点处理和像素栅格化。 Lightmapping : http://docs.unity3d.com/Documentation/Manual/Lightmapping.html 7.对GPU的优化——图片压缩和多重纹理格式 Compressed Textures（图片压缩): http://docs.unity3d.com/Documentation/Components/class-Texture2D.html 图片压缩将降低你的图片大小（更快地加载更小的内存跨度(footprint)），而且大大提高渲染表现。压缩贴图比起未压缩的32位RGBA贴图占用内存带宽少得多。 之前U3D会议还听说过一个优化，贴图尽量都用一个大小的格式（512 * 512 ， 1024 * 1024），这样在内存之中能得到更好的排序，而不会有内存之间空隙。这个是否真假没得到过测试。 MIPMAPS（多重纹理格式）： http://docs.unity3d.com/Documentation/Components/class-Texture2D.html 跟网页上的略缩图原理一样，在3D游戏中我们为游戏的贴图生成多重纹理贴图，远处显示较小的物体用小的贴图，显示比较大的物体用精细的贴图。这样能更加有效的减少传输给GPU中的数据。 8.LOD 、 Per-Layer Cull Distances 、 Occlusion Culling LOD (Level Of Detail) 是很常用的3D游戏技术了，其功能理解起来则是相当于多重纹理贴图。在以在屏幕中显示模型大小的比例来判断使用高或低层次的模型来减少对GPU的传输数据，和减少GPU所需要的顶点计算。 摄像机分层距离剔除(Per-Layer Cull Distances)：为小物体标识层次，然后根据其距离主摄像机的距离判断是否需要显示。 遮挡剔除（Occlusion Culling）其实就是当某个物体在摄像机前被另外一个物体完全挡住的情况，挡住就不发送给GPU渲染，从而直接降低DRAW CALL。不过有些时候在CPU中计算其是否被挡住则会很耗计算，反而得不偿失。 以下是这几个优化技术的相关使用和介绍： Level Of Detail : http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html Per-Layer Cull Distances : http://docs.unity3d.com/Documentation/ScriptReference/Camera-layerCullDistances.html Occlusion Culling ： http://docs.unity3d.com/Documentation/Manual/OcclusionCulling.html 9.关于Realtime Shadows（实时阴影） 实时阴影技术非常棒，但消耗大量计算。为GPU和CPU都带来了昂贵的负担，细节的话参考下面： http://docs.unity3d.com/Documentation/Manual/Shadows.html 10.对GPU优化：采用高效的shader a.需要注意的是有些(built-in)Shader是有mobile版本的，这些大大提高了顶点处理的性能。当然也会有一些限制。 b.自己写的shader请注意复杂操作符计算，类似pow,exp,log,cos,sin,tan等都是很耗时的计算，最多只用一次在每个像素点的计算。不推荐你自己写normalize,dot,inversesqart操作符，内置的肯定比你写的好。 c.需要警醒的是alpha test，这个非常耗时。 d.浮点类型运算:精度越低的浮点计算越快。 在CG/HLSL中– float ：32位浮点格式，适合顶点变换运算，但比较慢。 half：16位浮点格式，适合贴图和UV坐标计算，是highp类型计算的两倍。 fixed: 10位浮点格式，适合颜色，光照，和其他。是highp格式计算的四倍。 写Shader优化的小提示: http://docs.unity3d.com/Documentation/Components/SL-ShaderPerformance.html 11.另外的相关优化： a.对Draw Call Batching的优化 http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html b.对Rendering Statistics Window的说明和提示： http://docs.unity3d.com/Documentation/Manual/RenderingStatistics.html c.角色模型的优化建议 用单个蒙皮渲染、尽量少用材质、少用骨骼节点、移动设备上角色多边形保持在3001500内(当然还要看具体的需求)、PC平台上15004000内(当然还要看具体的需求)。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Android 重新签名打包","slug":"cocos/android-e9-87-8d-e6-96","date":"2018-11-12T14:23:09.000Z","updated":"2019-11-09T02:44:58.693Z","comments":true,"path":"2018/11/12/cocos/android-e9-87-8d-e6-96/","link":"","permalink":"http://blog.le-more.com/2018/11/12/cocos/android-e9-87-8d-e6-96/","excerpt":"","text":"1.安装JDK 2.cd 到\\Java\\jdk1.8.0_191\\bin 目录 生成签名文件 keytool -genkey -alias androidauto.keystore -keyalg RSA -validity 20000 -keystore demo.keystore 4.解压apk,修改后重新zip压缩，注意是zip,然而改名为demo.apk 5.重新签名 123456签名文件的密码 jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore demo.keystore -storepass 123456 demo.apk demo.keystore","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"算法研究之---冒泡排序","slug":"math/e7-ae-97-e6-b3-95","date":"2018-09-16T02:31:59.000Z","updated":"2019-11-08T09:59:30.989Z","comments":true,"path":"2018/09/16/math/e7-ae-97-e6-b3-95/","link":"","permalink":"http://blog.le-more.com/2018/09/16/math/e7-ae-97-e6-b3-95/","excerpt":"","text":"原理：n个元素的数组：第一轮从头开始两两比较，如果前一个大于（或小于）后一个，则交换，然后比较下一个，直到最大的数（或最小的数）移到末尾。第二轮重复第一轮操作，比较的数目为比上轮少1（因为已经定位到1个最大值）；继续比较直到比较的数据为0； 冒泡排序实现： void bubble_sort(int array[], int length) { for (int i = 1; i&lt;length; ++i) { for (int j = 0; j &lt; length -i; ++j) { if (array\\[j\\] &gt; array\\[j + 1\\]) { int const temp = array\\[j\\]; array\\[j\\] = array\\[j + 1\\]; array\\[j + 1\\] = temp; } } } cout &lt;&lt; &quot;冒泡排序：&quot; &lt;&lt; endl; for (int i = 0; i&lt;length; i++) { cout &lt;&lt; array\\[i\\] &lt;&lt; endl; }} 优化：因为在经过m（0&lt;m&lt;n）轮比较后，如果在新的一轮比较中无任何交换，说明数组已经是排好序的了，即可终止循环。 void bubble_sort_2(int array[], int length) { //标记是否交换 int isSwap; for (int i = 1; i&lt;length; ++i) { isSwap = 0; for (int j = 0; j &lt; length -i; ++j) { if (array\\[j\\] &gt; array\\[j + 1\\]) { int const temp = array\\[j\\]; array\\[j\\] = array\\[j + 1\\]; array\\[j + 1\\] = temp; isSwap = 1; } } if (isSwap == 0) break; } cout &lt;&lt; &quot;冒泡排序2：&quot; &lt;&lt; endl; for (int i = 0; i&lt;length; i++) { cout &lt;&lt; array\\[i\\] &lt;&lt; endl; }} 冒泡排序的时间复杂度为 o(n^2)","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"算法研究之—希尔排序","slug":"math/e7-ae-97-e6-b3-96","date":"2018-09-15T12:45:37.000Z","updated":"2019-11-08T09:59:30.989Z","comments":true,"path":"2018/09/15/math/e7-ae-97-e6-b3-96/","link":"","permalink":"http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-96/","excerpt":"","text":"原理：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插” 算法实现： void shell_sort(int array[], int length){ //增量gap，并逐步缩小增量 for (int gap = length / 2; gap &gt; 0; gap /= 2) { //从第gap个元素，逐个对其所在组进行直接插入排序操作 for (int i = gap; i &lt; length; i++) { int j = i; while (j - gap &gt;= 0 &amp;&amp; array[j] &lt; array[j - gap]) { //插入排序采用交换法 //swap(arr, j, j - gap); const int temp = array[j]; array[j] = array[j - gap]; array[j - gap] = temp; j -= gap; } } } cout &lt;&lt; &quot;希尔排序：&quot; &lt;&lt; endl; for (int i = 0; i &lt; length; i++) { cout &lt;&lt; array\\[i\\] &lt;&lt; endl; }} 参考：图解排序算法(二)之希尔排序","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"算法研究之---插入排序","slug":"math/e7-ae-97-e6-b3-98","date":"2018-09-15T06:22:22.000Z","updated":"2019-11-08T09:59:30.991Z","comments":true,"path":"2018/09/15/math/e7-ae-97-e6-b3-98/","link":"","permalink":"http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-98/","excerpt":"","text":"插入排序原理：_插入排序的工作方式像许多人排序一手扑克牌.开始时,我们的左手为空并且桌子上的牌面向下.然后,我们每次从桌子上拿走一张牌并将它插入左手中正确的位置.为了找到一张牌的正确位置,我们从右向左将它与已在手中的每张牌进行比较,拿在左手中的牌总是排序好的. _ INSERTION-SORT 伪代码： for j = 1 to A.length key = A\\[j\\] //Insert A\\[j\\] into the sorted sequence A\\[1...j-1\\] i = j - 1 while i &gt; 0 and A\\[i\\] &gt; key A\\[i+1\\] = A\\[i\\] i = i-1 A\\[i+1\\] = key代码实现： void insertion_sort(int array[],int length, bool asc); int main(){ int array[10] = { 2,3,1,5,6,8,10,9,4 }; int length = sizeof(array) / sizeof(array[0]); insertion_sort(array, length,true); insertion_sort(array, length, false); system(&quot;pause&quot;); //return 0;} void insertion_sort(int array[],int length,bool asc){ for (int j = 1; j&lt;length; j++) { int key = array[j]; int i = j - 1; if(asc) { while (i &gt;= 0 &amp;&amp; array[i] &gt; key) { array[i + 1] = array[i]; i = i - 1; } } else { while (i &gt;= 0 &amp;&amp; array[i] &lt; key) { array[i + 1] = array[i]; i = i - 1; } } array\\[i + 1\\] = key; } for (int i = 0; i&lt;length; i++) { cout &lt;&lt; array\\[i\\] &lt;&lt; endl; }} 插入排序的时间复杂度为 o(n^2)。 参考：算法导论（原书第3版）","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"算法研究之---开篇","slug":"math/e7-ae-97-e6-b3-97","date":"2018-09-15T05:39:35.000Z","updated":"2019-11-08T09:59:30.990Z","comments":true,"path":"2018/09/15/math/e7-ae-97-e6-b3-97/","link":"","permalink":"http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-97/","excerpt":"","text":"现在开始写一有关算法的日志 每个程序员都应该收藏的算法复杂度速查表","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"每个程序员都应该收藏的算法复杂度速查表","slug":"math/e6-af-8f-e4-b8-aa","date":"2018-09-10T02:08:42.000Z","updated":"2019-11-08T09:59:30.988Z","comments":true,"path":"2018/09/10/math/e6-af-8f-e4-b8-aa/","link":"","permalink":"http://blog.le-more.com/2018/09/10/math/e6-af-8f-e4-b8-aa/","excerpt":"","text":"编译自：http://bigocheatsheet.com/作者： Eric 原创：LCTT https://linux.cn/article-7480-1.html 译者： wxy 本文地址：https://linux.cn/article-7480-1.html 算法复杂度这件事这篇文章覆盖了计算机科学里面常见算法的时间和空间的大 OBig-O 复杂度。我之前在参加面试前，经常需要花费很多时间从互联网上查找各种搜索和排序算法的优劣，以便我在面试时不会被问住。最近这几年，我面试了几家硅谷的初创企业和一些更大一些的公司，如 Yahoo、eBay、LinkedIn 和 Google，每次我都需要准备这个，我就在问自己，“为什么没有人创建一个漂亮的大 O 速查表呢？”所以，为了节省大家的时间，我就创建了这个，希望你喜欢！ — Eric 图例 数据结构操作 数组排序算法 图操作 堆操作 大 O 复杂度图表 Big O Complexity Graph","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"C++ vector list deque map 的优缺点以及区别","slug":"c++/c-vector-list-deque-map","date":"2018-08-30T10:37:40.000Z","updated":"2019-11-09T02:40:51.571Z","comments":true,"path":"2018/08/30/c++/c-vector-list-deque-map/","link":"","permalink":"http://blog.le-more.com/2018/08/30/c++/c-vector-list-deque-map/","excerpt":"","text":"STL容器，大致分为以下三大类：序列容器：vector、list、deque、string 关联容器：set、multiset、map、mulmap、hash_set、hash_map、hash_multiset、hash_mulmap 常用的大概只有vector list map set string下边是几个常用的容器的一些特性的记录，以备所需之时查看。 *vector * 向量 相当于一个数组。在内存中分配一块连续的内存空间进行存储，支持补丁大小的存储。当超过已分配的空间是，会整体重新分配一块内存进行存储。优点1、不指定一块连续内存进行存储，可以像数组一样操作。2、随机访问方便，支持下标访问和vector.at()操作。3、节省空间。 缺点 1、在内部进行插入删除，效率较低。2、只能在末端进行pop和push。3、当动态长度超过默认分配大小后，要整体重新分配、拷贝和施放。 list 双向链表。每个结点都包含一个信息块Info、一个前驱指针Pre和一个后驱指针Post。可不比分配必须的大小，方便的进行插入删除操作。使用的是非连续的 内存空间进行存储。 优点 1、不适用连续内存完成动态操作。 2、在内部方便进行插入删除操作。 3、可在两端进行push和pop操作。 缺点 1、不支持随机访问，即下标操作和.at()。 2、相对于vector占用内存多。 deque 双向队列，在功能上合并了vector和list。 优点 1、支持随机访问。 2、可以再两端进行push和pop操作。 3、在内部方便进行插入和删除操作。 缺点 占用内存较多。 map 映照容器 元素数据是一个键值和一个映照数据组成。键值和数据之间有一一映照的关系。 map采用红黑树实现，插入的键值不能重复，比较函数只对元素的键值进行比较。元素的各项数据可通过键值索引出来。","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"}]},{"title":"C++开发之---内存对齐","slug":"c++/c-e5-86-85-e5-ad-98-e5","date":"2018-08-29T10:37:40.000Z","updated":"2019-11-08T09:59:30.958Z","comments":true,"path":"2018/08/29/c++/c-e5-86-85-e5-ad-98-e5/","link":"","permalink":"http://blog.le-more.com/2018/08/29/c++/c-e5-86-85-e5-ad-98-e5/","excerpt":"","text":"网络数据协议的定义： struct tagInfo{ WORD wDataSize; //数据大小 BYTE cbCheckCode; //检验码}; WORD为两个字节，BYTE是一个字节，但是sizeof(tagInfo)大小却是4 #pragma once#pragma pack(1) //设置1字节对齐 struct tagInfo{ WORD wDataSize; //数据大小 BYTE cbCheckCode; //检验码}; #pragma pack() //取消设置 在头文件的开头和结尾处分别设置，然后sizeof(tagInfo)的大小就为3了。 下面摘自网络： 内存对齐的原则以及作用？ 结构体内的成员按自身长度自对齐（32位机器上，如char=1，short=2，int=4，double=8），所谓自对齐是指该成员的起始地址必须是它自身长度的整数倍。如int只能以0,4,8这类地址开始。 结构体的总大小为结构体的有效对齐值的整数倍（默认以结构体中最长的成员长度为有效值的整数倍，当用#pragrma pack（n）指定时，以n和结构体中最长的成员的长度中较小者为其值）。即sizeof的值，必须是其内部最大成员的整数倍，不足的要补齐。 例如： class A{ char c; int a; char d;}; cout &lt;&lt; sizeof(A) &lt;&lt; endl; class B{ char c; char d; int a;}; cout &lt;&lt; sizeof(B) &lt;&lt; endl; sizeof（A）=12，sizeof（B）=8； 因为左边是1+（3）+4+1+（3）=12，而右边是1+1+（2）+4=8。括号中为补齐的字节。 内存对齐的作用： 1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 2、性能原因：经过内存对齐后，CPU的内存访问速度大大提升。 QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"}]},{"title":"C++开发之---单例类的实现","slug":"c++/c-e5-8d-95-e4-be-8b-e7","date":"2018-08-28T10:39:00.000Z","updated":"2019-11-08T09:59:30.959Z","comments":true,"path":"2018/08/28/c++/c-e5-8d-95-e4-be-8b-e7/","link":"","permalink":"http://blog.le-more.com/2018/08/28/c++/c-e5-8d-95-e4-be-8b-e7/","excerpt":"","text":"单倒模式是一种常见的设计模式，在cocos2d很多地方都使用到。下面贴出来我的一种方式。 Utils.h #ifndef __UTILS_H_#define __UTILS_H_ #define UTILS Utils::Instance() class Utils{private: //将构造与析构声明 为私有，防止外部创建对象，因为这个对象是单根类 Utils(); ~Utils();public: static Utils* Instance(); }; #endif Utils.cpp #include “Utils.h” Utils::Utils(){} Utils::~Utils(){} Utils* Utils::Instance(){ static Utils instance; return &amp;instance;} 原理都是类似的，使用类的静态变量或全局的静态变量保存唯一实例。最重要一点：将构造与析构声明 为私有，防止外部创建对象，保持此类只有唯一一个实例 QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"}]},{"title":"C++研究之---C++11 新特性","slug":"c++/c11-e6-96-b0-e7-89-b9","date":"2018-08-22T05:57:02.000Z","updated":"2019-11-08T09:59:30.962Z","comments":true,"path":"2018/08/22/c++/c11-e6-96-b0-e7-89-b9/","link":"","permalink":"http://blog.le-more.com/2018/08/22/c++/c11-e6-96-b0-e7-89-b9/","excerpt":"","text":"总结C++11新特性的功能用法和注意事项 auto 功能：类型说明符，用于自动获取表达式所属的类型 //1.auto定义的变量必须有初始值auto item = val1 + val2;//item的初始化为val1和val2相加的结果 //2.声明多个变量，每个变量类型要相同auto sz = 0,pi = 3.14;//错误：sz和pi类型不一致 //3.使用引用是使用引用的对象int i = 0, &amp;r = i;auto a = r; // a是一个整数 //4.auto 忽略顶层const，保留底层constconst int ci = i,&amp;cr = ci;auto b = ci; //b是一个整数(ci的顶层const特性被忽略掉了)auto d = &i; //d是一个整形指针(整数的地址就是指向整数的指针)auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层const） //一条语句定义多个变量,符号&amp;和只从属于某个声明符，而非基本数据类型，初始值必须是同一类型auto k = ci,&amp;l = i;//k是整数，l是整数引用auto &amp;n = i,p2 = &ci;//错误，i的类型是int 而&amp;ci的类型是const int long long 类型 C++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大 列表初始化 用花括号来初始化变量 //各种初始化int units_sold = 0;int units_sold = {0};int units_sold{0};int units_sold(0); //列表初始化如果存在丢失信息的风险，则报错：long double ld = 3.1415926;int a{ld},b = {ld};//错误：转换示执行，因为存在丢失信息的危险int c(ld),d = ld; //正确：转换执行，丢失部分数值 空指针 nullptr 特殊类型的字面值，可以转换为任意指针类型； C++程序最好使用nullptr，尽量避免使用NULL; //下面等价int *p1 = nullptr;int *p2 = 0;//需要#include cstdlibint *p3 = NULL constexpr 变量 constexpr声明的变量由编译器来验证变量值是否是一个常量表达式； constexpr声明的变量一定是一个常量，而且必须用常量表达式初始化； constexpr声明的类型为字面值类型（算术，引用 和指针），自定义、IO库，string类型不属于。 constexpr指针初始值必须是nullptr或0，或是固定地址的对象(函数体之外的对象) constexpr int mf = 20;//20是常量表达式constexpr int limit = mf + 1; //mf +1 是常量表达式constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句 //仅对指针有效，与指对象无关const int *p = nullptr; //p是一个指向整形常量指针constexpr int *q = nullptr;//q 是一个指向整数的常量指针 //constexpr指针既可以指向常量也可以指向一个非常量constexpr int *np = nullptr;//np是一个指向号数的常量指针int j = 0;constexpr int i = 42;//i和j 都必须定义在函数体之外constexpr const int *p = &i;//p是常量指针，指向整型常量iconstexpr int *p1 = &j;、、//p1是常量指针，指向整数j 类型别名using //传统方法 typedeftypedef double wages;//wages是double的同义词 //usingusing SI = Sales_item; //SI是Sales_item的同义词 //指针、常量和类型别名typedef char *pstring;//pstring 是指向char 的指针const pstring cstr = 0;//cstr是指向char的常量指针const pstring *ps;//ps是一个指针，它的对象是指向char的常量指针//如果理解成:const char *cstr = 0;//是对const pstring cstrr 的错误理解 decltype 类型指示符 选择并返回操作数的数据类型 decltype(f()) sum = x; //sum的类型就是函数f的返回类型 //decltype处理顶层const和引用的方式与auto不同const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; //x是const intdecltype(cj ) y = x; //y是const int&amp;,y绑定到变量xdecltype(cj) z; //错误 z是一个引用，必须初始化 //如果decltype使用的表达式不是一个变量，则以返回的表达式结果对应类型int i = 42,p = &amp;i,&amp;r = i;decltype(r + 0) b; //正确:加法的结果是int,因此b是一个intdecltype(p) c; //错误：c是int&amp; 必须初始化 //decltype 的表达式如果是加上了括号的变量，结果将是引用decltype((i)) d;//错误：d是int&amp;,必须初始化decltype(i) e;//正确：e是一个(未初始化的)int //使用decltype简化函数返回类型int odd[] = {1,3,5};int even[] = {0,2,4};//返回一个指针，指向含有3个整数的数组decltype(odd) *arrPtr(int i ){ return (i%2)?&amp;odd:&amp;even;} 类内初始化 初始化和赋值不同，一个是没值，一个是有值 范围for 遍历给定序列中的每个元素并对序列中的每个值执行某种操作 //语法for(declaration : expression) statement//示例string str(“some string”);for(auto c : str) cout &lt;&lt; c &lt;&lt;endl;for(auto &amp;c : s) c = toupper(c);//转为大写 vector对象的vector vector&lt;vector&gt; vector对象列表初始化 vector articles = {“a”,”an”,”the”};vector v1(“a”,”an”,”the”);//错误 容器的cbegin和cend函数 类似于begin和end，只是返回的是const_iterator auto it2 = v.cbegin();//it3的类型是vector::const_iterator 函数begin和end 和容器功能类似，以数组为参数 int ia[] = {0,1,2,3,4,5,6,7};int *beg = begin(ia);//指向首元素的指针int *last = end(ia);//指向尾元素的下一个位置的指针 //示例//pbeg指向arr的首元素，pend指向arr的尾元素的下一位置int *pbeg = begin(arr),*pend = end(arr);//寻找第一个负值元素wile(pbeg != pend &amp;&amp; *pbeg &gt;=0) ++pbeg; 除法舍入规则 商一律向0取整(直接切除小数部分) sizeof用于类成员 使用作用域运算符来获取类成员的大小，sizeof运算符无须提供一个具体的对象。 initializer_list类 标准库类型，用于表示某种特定类型的值的数组 //是一种模板类型,注意元素是常量值initializer_list ls;//initializer_list的元素类型是stringinitializer_list li; //示例void error_msg(initializer_list il){ for(auto beg = il.begin();beg!= il.end();++beg) cout &lt;&lt; *beg &lt;&lt; &quot;&quot;; cout &lt;&lt;endl;}//调用 expected 和actual是string对象if(expected != actual) error_msg({“functionX”,expected,actual});else error_msg({“fuctionX”,”okay”}); 列表初始化返回值 函数可以返回花括号包围的值的列表 vector process(){ return {}; //return {&quot;fuctionX&quot;,&quot;okay&quot;};} 尾置返回类型 较适用于返回类型比较复杂的函数（数组的指针或数组的引用） //func接受一个int类型的实参,返回一个指针，该指针指向含有10个整数的数组auto func(int i)-&gt;int (*)[10];//注意加括号和不加括号的区别 constexpr函数 能用于常量表达式的函数：函数返回类型及所有形参的类型都得是字面值类型；函数体必须有且只有一条return语句 constexpr int new_sz() {return 42;}constexpr int foo = new_sz();//正确：foo是一个常量表达式 //函数体内也可以包含其他语句，只有这些语句在运行时不执行任何操作（空语句，类型别名，using声明）//如果arg是常量表达式,scale(arg）也是常量表达式constexpr size_t scale(size_t cnt){return new_sz() * cnt} //当scale的实参是常量表达式时，它的返回值也是常量表达式int arr[scale(2)]; //正确int i = 2;int a2[scale(i)]; //错误，scale(i)不是常量表达式 =default 生成默认构造函数 通过在参数列表后面写上=default，要求编译器生成构造函数。可以和声明一起出来在类的内部（内联），也可以作为定义出现在类的外部。 Sales_data() = default; 类对象成员类内初始化 class Window_mgr{private: //这个Window_mgr追踪的Screen //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector&lt;Screen&gt; screens{Screen(24,80,&apos;&apos;)};} 委托构造函数 使用它所属类的其他构造函数执行它自己的初始化过程（把它职责委托给了其他构造函数） class Sales_data{public: //非委托构造函数使用对应的实参初始化成员 Sales\\_data(std::string s,unsigned cnt,double price):bookNo(s),units\\_sold(cnt),revenue(cnt *price){} //委托构造 Sales\\_data():Sales\\_data(&quot;&quot;,0,0){} constexpr构造函数 符合构造函数要求（没有返回语句），符合constexpr函数要求（拥有唯一可执行语句就是返回语句），一般函数是空的。可声明=default或=delete //constexpr构造函数必须初始化所有数据成员，初始值使用constexpr构造函数或一条常量表达式class Debug{public: constexpr Debug(bool b = true):hw(b),io(b),other(b){} constexpr bool any(){return hw||io||other;}} //constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型constexpr Debug io_sub(false,true,false);if(io_sub.any()) cerr&lt;&lt;”print appropriate error message”&lt;&lt;endl; 用string对象处理文件名 IO参数可以使用库类型string的对象 array和forward_list容器 与内置数组相比,array是一种更安全、更容易使用的数组类型；array对象的大小是固定的，不支持添加和删除元素以及改变容器的大小操作。 forward_list目标是达到与最好手写的单向链表数据结构相当的性能，没有size操作 容器的cbegin和cend函数 无论容器元素是否是常量，返回值都是const_iterator auto it3 = v.cbegin(); //it3的类型是vector::const_iterator 容器的列表初始化 list authors = {“M”,”S”,”A”};vector&lt;const char*&gt; art = {“a”,”an”,”the”}; 容器的非成员函数swap swap操作交换两个相同类型容器的内容。调用后，元素交换(本身未交换，只是交换了两个容器的数据结构) vector svec1(10); //10个元素vector svec2(24);swap(svec1,svec2); 容器insert成员的返回类型 insert返回指向第一个新加入元素的迭代器，如果范围为空，不插入任何元素，insert操作会将第一个参数返回。 list lst;auto iter = lst.begin();while(cin &gt;&gt; word) iter = lst.insert(iter,word);//等价于调用push_front 容器的emplace成员的返回类型 emplace_front,empace和emplace_back 操作构造元素（相对于push或insert拷贝），对应push_front,insert和push_back,将元素旋转在容器的头部、一个指定位置之前或窗口尾部 shrink_to_fit 适用于vector,string和deque，capacity和reserve只适用于vector和string c.shrink_to_fit();//将capacity()减少为与size()相同的大小 string的数值转换函数 int i = 42;string s = to_string(i);//将整数i转换为字符表示形式double d = stod(s);//将字符串s转换为浮点数 //转换s中以数字开始的第一个子串，结果d = 3.14string s2 = “pi = 3.14”;d = stod(s2.substr(s2.find_first_of(“+-.0123456789”))); lambda匿名函数 可调用对象(callable object)(函数，函数指针，重载运算符的类，lambda表达式) lambda:未命名的内联函数，可定义在函数内部 //capture list(捕获列表)，通常为空；[capture list](parameter list) -&gt; return type{function body} //可忽略参数列表和返回类型，但必包含捕获列表和函数体//空参数列表，推断返回类型auto f = [] {return 42;};cout &lt;&lt; f() &lt;&lt;endl;//调用 //传参[](const string &amp;a,const string &amp;b){return a.size()&lt; b.size()}//调用示例stable_sort(words.begin(),words.end(),[](const string &amp;a,const string &amp;b){return a.size&lt;b.size();}); //捕获列表[sz](const string &amp;a){ return a.size &gt;=sz;}; //调用find_ifauto wc = find_if(words.begin(),words.end(), \\[sz\\](const string &amp;a){ return a.size &gt;=sz;})//for_eachfor_each(wc,words.end(), \\[\\](const string &amp;s){cout &lt;&lt; s &lt;&lt; &quot; &quot;;});cout &lt;&lt; endl; //值捕获void fcn1(){ size_t v1 = 42; auto f = \\[v1\\]{return v1;}; v1 = 0; auto j = f();//j为42;} //引用捕获void fcn2(){ size_t v1 = 42; auto f2 = \\[&amp;v1\\]{return v1;}; v1 = 0; auto j = f2();//j为0，} //隐式捕获//sz为隐式捕获，值捕获方式wc = find_if(words.begin(),words.end(), \\[=\\](const string &amp;s){return s.size()&gt;=sz;})//可变lambdavoid fcn3(){ size_t v1 = 42; //f可以改变它所捕获的变量的值 auto f = \\[v1\\]() mutable{return ++v1;}; v1 = 0; auto j = f(); //是为43;} //尾置返回类型transform(vi.begin(),vi.end(),vi.begin(), \\[\\](int i) -&gt; int {if(i&lt;0) return -i; else return i;}); 标准bind 在functional文件中定义，通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表 auto new Callable = bind(callable,arg_list); //check6是一个可调用对象，接受一个string类型的参数//并用此string和值6来调用check_sizeauto check6 = bind(check_size,_1,6);//_1参数占位符 string s = “hello”;bool b1 = check6(s);//check6(s)会调用check_size(s,6); //lambada的find_ifauto wc = find_if(words.begin(),words.end(),[sz](const string &amp;a))//替换为auto wc = find_if(words.begin(),words.end(),bind(check_size,_1,siz)); //_n为placeholders命名空间所定义,functional头文件中using std::placeholders::_1;//使用所有的定义using std::placeholders //bind的参数//g是一个有两个参数的可调用对象auto g = bind(f,a,b,_2,c,_1);//示例//g(_1,_2) 映射为//f(a,b,_2,c_1) //用bind重排参数顺序//按单词长度由短到长排序sort(words.begin(),words.end(),isShorter);//按单词长度由长到短排序sort(words.begin(),words.end(),bind(isShorter,_2,-1)); //绑定引用参数,ref和cref(const引用类) 定义与functional//为了替换一个引用方式捕获ostream的lambda://os是一个局部变量，引用一个输出流//c是一个局部变量，类型为charfor_each(words.begin(),words.end(),[&amp;os,c](const string &amp;s){os &lt;&lt; s &lt;&lt; c;});//相同的函数ostream &amp;print(ostream &amp;os,const string &amp;s,char c){ return os&lt;&lt;s &lt;&lt;c;}//用bind代替os的捕获是错误的,os不能拷贝for_each(words.begin(),words.end(),bind(print,os,_1, ‘’));//可以使用标准的ref函数for_each(words.begin(),words.end(),bind(print,ref(os),_1,’’)); 待续… 汇总自：C++Primer 第五版","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"},{"name":"c++11","slug":"c-11","permalink":"http://blog.le-more.com/tags/c-11/"}]},{"title":"C++研究之---virtual 解析","slug":"c++/c-virtual-e8-a7-a3-e6-9e-90","date":"2018-08-22T02:50:22.000Z","updated":"2019-11-08T09:59:30.961Z","comments":true,"path":"2018/08/22/c++/c-virtual-e8-a7-a3-e6-9e-90/","link":"","permalink":"http://blog.le-more.com/2018/08/22/c++/c-virtual-e8-a7-a3-e6-9e-90/","excerpt":"","text":"OO编程有三大特性：封装，继承，多态 在C++中，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。静态多态即函数重载，在同一类内相同的函数名，不同的参数列表。相对简单，现在重点分析动态多态。 虚函数 C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 通过以上这段话，我们知道动态多态主要是通过虚函数实现，而虚函数(Virtual Function)则是通过一张虚函数表(Virtual Table)来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。我们通过一些代码来了解这个概念： typedef void(*pFun)(void);//函数指针 class Base {public: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; }}; void FunTest(){ Base b; cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; pFun* fun = (pFun*)*(int*)&amp;b; while (*fun) { (*fun)(); fun++; }} int main(){ FunTest(); getchar(); return 0;} 在VS2013编译器win32的测试结果为： 我们来看看虚函数表的地址0x00DF820里面存了什么? 通过上图我们知道，通过Base类实例化的对象b里面(有3个虚函数)有一个指向虚函数表的指针，也就是我们上面的0x00DF820，而在这个虚函数表中，分别存了3个虚函数的地址，我们通过函数指针fun可以访问到这些函数，因此就得到我们的输出结果了。通过sizeof(Base)=4也说明此时b对象仅仅存有一个指针，指向虚函数表。 所以就得到了我们的对象模型： 注意：在上面这个图中，虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束，也就是我们这里虚函数表的最后地址存的全是0。注意这个结束标志的值在不同的编译器下是不同的。 一般继承(无虚函数覆盖) 注意到： 1. 虚函数按照其声明顺序放于表中。 2. 父类的虚函数在子类的虚函数前面。 一般继承(有虚函数覆盖) 注意到： 1. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 2. 没有被覆盖的函数依旧。 因此对于程序： Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承(无虚函数覆盖) 注意到： 1. 对于实例Derived d的对象，每个父类都有存有一个指针，指向对应的虚函数表。 2. 子类的成员函数被放到了第一个父类的表中。(第一个父类是按照声明顺序来判断的) 多重继承(有虚函数覆盖) 我们可以写一段代码对上图进行测试： typedef void(*pFun)(void); class Base1 { public: virtual void f() { cout &lt;&lt; &quot;Base1::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1::h&quot; &lt;&lt; endl; }}; class Base2 { public: virtual void f() { cout &lt;&lt; &quot;Base2::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2::h&quot; &lt;&lt; endl; }}; class Base3 { public: virtual void f() { cout &lt;&lt; &quot;Base3::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3::h&quot; &lt;&lt; endl; }}; class Derived : public Base1, public Base2, public Base3 { public: virtual void f() { cout &lt;&lt; &quot;Derived::f&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derived::g1&quot; &lt;&lt; endl; }}; void FunTest(){ Derived d; cout &lt;&lt; sizeof(Derived) &lt;&lt; endl; //访问Base1虚函数表 pFun* fun = (pFun*)*((int*)&amp;d + 0); while (*fun) { (*fun)(); fun++; } cout &lt;&lt; endl; //访问Base2虚函数表 fun = (pFun*)*((int*)&amp;d + 1); while (*fun) { (*fun)(); fun++; } cout &lt;&lt; endl; //访问Base3虚函数表 fun = (pFun*)*((int*)&amp;d + 2); while (*fun) { (*fun)(); fun++; }} int main(){ FunTest(); return 0;} 最后显示结果为： 虚函数表总结 Base虚表：Base类如果有虚函数的话，就按照虚函数出现的先后次序来填写续表 Derived虚表：对于继承Base类的对象，首先按照Base类的虚表格式复制，如果有重写(覆盖)基类的虚函数，则在对应的位置修改，不改变次序。如果派生类中新增虚函数，则将这虚函数填写到第一个父类虚函数后面即可。 虚继承 class B{public: int _b;}; class C1 : public B{public: int _c1;}; class C2 : public B{public: int _c2;}; class D :public C1, public C2{public: int _d;}; int main(){ D d; //d._b = 10;错误，访问不明确 d.C1::_b = 10;//正确 d.C2::_b = 10;//正确 return 0; } 为什么会出现这样的问题? 我们知道它们的继承层次如下图所示： 这种看似菱形的多继承会带来二义性：也就是说D中_b到底是从C1这条路继承而来的还是从C2这条路继承而来的?C++中为了避免这种访问不明确，从而引入了虚拟继承的机制。 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如上述类D继承自类C1、C2，而类C1、C2都继承自类B，因此在类D中两次出现类B中的变量。为了节省内存空间，可以将C1、C2对B的继承定义为虚拟继承，而B就成了虚拟基类。实现代码如下： class B{public: int _b;}; class C1 :virtual public B{public: int _c1;}; class C2 :virtual public B{public: int _c2;}; class D :public C1, public C2{public: int _d;}; int main(){ D d; d._d = 4; return 0;} 这样就可以达到我们的要求了，直接使用d._d访问到_d。然而虚继承到底是一种怎么样的实现机制?我们不妨在加不加virtual这两中情况下看下在内存中D d这个对象模型是怎么样的? 对于普通继承，我们通过VS2013的内存窗口可以看到： 先是C1类中的成员，再是C2类中的成员，最后是D类自己的成员，此时sizeof(D) = 20。而一旦加了虚继承了，变化就比较明显了，如下图： 题目 1.以下代码输出什么： class C {public: virtual string toString() { return “class C”; }}; class B : public C {public: /*virtual*/ string toString() { return “class B”; }}; class A : public B {public: /*virtual*/ string toString() { return “class A”; }}; int main(){ C *pC = new A(); cout &lt;&lt; pC-&gt;toString().c_str() &lt;&lt; endl; delete pC; pC = new B(); cout &lt;&lt; pC-&gt;toString().c_str() &lt;&lt; endl; cout &lt;&lt; endl; system(“pause”); return 0;} 结果：输出class A;class B 分析：如果基类定义了虚同名函数，那么派生类中的同名函数自动变成了虚函数 2 对这四种情况分别求sizeof(a), sizeof(b)。结果是什么样的呢?我在VS2013的win32平台测试结果为： 第一种：4，12 第二种：4，4 第三种：8，16 第四种：8，8 解释：首先我们看a类，我们知道每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表，再加上如果有数据，根据内存对齐机制，四种情况的类a所占的字节数应该是没有什么问题的。我们再看sizeof(B)，我们先看普通继承，对于普通继承仅仅是在原来的基础对虚表指针指向的虚函数表进行改写，类B依旧只有一个虚表指针，再加上如果有数据，根据内存对齐机制，所以第二种和第四种情况下，sizeof(B)分别为4和8。然而对于虚拟继承，会增加了一个偏移指针，而且由于类B中新增了虚函数，所以它的一般对象模型为这样(具体为什么是这样本文菱形虚拟继承会讲)： 根据图示，在第一种的情况下，由于没有对应的数据成员，所以大小为12个字节。在第三种情况下，子类有自己的数据成员，而基类没有，所以删去最后一项，大小就是16个字节了 3.下面代码输出什么 class A{public: void show(int val) { cout &lt;&lt; “A–” &lt;&lt; val &lt;&lt; “–A”; }}; class B : public A{public: void show(int val) { cout &lt;&lt; “B–” &lt;&lt; val &lt;&lt; “–B”; }}; int main(){ A* p = new B; p-&gt;show(5); cin.get();} 结果：A–5–A 分析：这就是隐藏 隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下： （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，且参数也相同，但基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 （3）但是，《Effective C++》条款36说：绝不重新定义继承而来的non-virtual函数，所以就不要这么做了。 转自：(部分重新整理) 解析虚函数表和虚继承 C++类成员函数的 重载、覆盖和隐藏区别","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"}]},{"title":"服务器开发之---Redis","slug":"server/e6-9c-8d-e5-8a-a1-e5-redis","date":"2018-08-04T04:27:01.000Z","updated":"2019-11-08T09:59:30.997Z","comments":true,"path":"2018/08/04/server/e6-9c-8d-e5-8a-a1-e5-redis/","link":"","permalink":"http://blog.le-more.com/2018/08/04/server/e6-9c-8d-e5-8a-a1-e5-redis/","excerpt":"","text":"Redis 教程 1.安装（Mac) 1. 官网http://redis.io/ 下载最新的稳定版本,这里是3.2.0 2. sudo mv 到 /usr/local/ sudo tar -zxf redis-3.2.0.tar 解压文件 4. 进入解压后的目录 cd redis-3.2.0 5. sudo make test 测试编译 6. sudo make install win:https://github.com/ServiceStack/redis-windows 2.启动连接1.启动服务：redis-server 启动服务：redis-server ./redis.conf #加载配置 2.连接： redis-cli -h 127.0.0.1 -p 63793.设置键值对： set myKey abc4.取出键值对： get myKey 3.关闭服务 redis-cli shutdown","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.le-more.com/categories/Server/"}],"tags":[]},{"title":"服务器开发之---Java问题汇总","slug":"server/java-e5-bc-80-e5-8f-91-e4","date":"2018-08-01T13:11:05.000Z","updated":"2019-11-08T09:59:30.997Z","comments":true,"path":"2018/08/01/server/java-e5-bc-80-e5-8f-91-e4/","link":"","permalink":"http://blog.le-more.com/2018/08/01/server/java-e5-bc-80-e5-8f-91-e4/","excerpt":"","text":"工作十余载，常憾浅尝辄止于各种技术，亦曾屡试专攻于一技，怎奈现实总不能遂人意，为了生活，只能不断前进再前进…. 游戏服务器开发掌握的技能： 1）语言：Java(Lua,Python Linux Shell etc.) 教程：Java 教程; 《Java程序员修炼之道》 2) 网络：Netty(Mina etc.) ;SpringMVC(HTTP) Protobuf,Json;教程：Spring MVC教程 ; Netty教程; Netty4.0学习笔记系列;《Netty实战》 3) 数据库：Mysql(Redis etc.);MyBatis框架 教程：菜鸟教程（Redis）; 菜鸟教程(MySql) 4) 其他：Java NIO;Java多线程；Java并发；书：《Java 7并发编程实战手册》 术语： 1）JDK 开发环境 2) JRE 运行环境 3) SE Standard Edition 标准版 用于桌面或简单的服务器应用平台 4) ME 移动端 5) J2(Java 2) 过时的术语 用于面述19982006的Java版本 6) SDK 过时的术语 用于面述19982006的JDK版本 7) u(Update) Oracle的术语 8) NetBeans Oracle的集成开发环境 POJO(Plain Ordinary Java Object):简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。有时可以作为VO(value -object)或dto(Data Transform Object)来使用 PO(Persistent Object)：持久对象,其属性是跟数据库表的字段一一对应的 VO(Value Object)：值对象,其属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 BO(business object)：主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 DTO(Data Transfer Object)：主要用于远程调用等需要大量传输对象的地方 transient：类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。 volatile：变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。 NIO:非阻塞输入输出 Java 4 NIO.1 Java 7 NIO.2 ORM:Object Relational Mapping 对象关系映射模型（Hibernate) IoC:控制反转，可以把其看做运行时环境，Java中为依赖注入提供的窗口有Guice,Spring和PicoContainer DI:依赖注入，IoC实现的一种方式。代码解耦并增强其可测试性和易读性的通用技术 字符串比较不能使用==，要使用strSource.equals(strDest)，不区分大小写比较使用strSource.equalsIgnoreCase(strDest) ide 报错： objc[823]: Class JavaLaunchHelper is implemented in both解决办法：点击Ide最上面菜单的Help-Edit Custom Properties，没有这个properties文件的话，会提示创建，然后在里面加上idea.no.launcher=true","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.le-more.com/categories/Server/"}],"tags":[]},{"title":"C++ Primer 学习笔记之 --- 学习总结","slug":"c++/c-primer-e5-ad-a6-e4-b9","date":"2018-07-30T02:17:10.000Z","updated":"2019-11-09T02:41:34.987Z","comments":true,"path":"2018/07/30/c++/c-primer-e5-ad-a6-e4-b9/","link":"","permalink":"http://blog.le-more.com/2018/07/30/c++/c-primer-e5-ad-a6-e4-b9/","excerpt":"","text":"Best Practices 出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意(12.1.2) 坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。（12.1.2） 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符（14.2.1） 当读取操作发生错误时，输入运算符应该负责从错误中恢复（14.2.2） 如果某个类在逻辑上有相等性的含义，则该类应该定义operator==,这样做可以使得用户更容易使用标准库算法来处理这个类（14.3.1） 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包括==,则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。（14.3.2） 赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用（14.4） 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量并且返回常量引用。（14.5） 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员（14.6）、 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。（14.6） 为了内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。（14.6） NOTE 如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。（12.1.1） 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。（12.1.1） 使用动态内存的一个常见原因是允许多个对象共享相同的状态。（12.1.1） 我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数（14.4） 下标运算符必须是成员函数（14.5） 因为我们不会用到int形参，所以无须为其命名（14.6） 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。（14.7） 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。（14.7） TIPSWARNING 虽然使用动态内存是必要的，但正解的管理动态内存是棘手的（12） 在学习第13章之前，除非使用智能指针来管理内存，否则不要分配动态内存（12.1.2） 由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在（12.1.2） 使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁（12.1.3） get用来装将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（12.1.3） 问题汇总# vector v1(10); //v1 有10个元素，每个值为0 vector v2{10}; //v2 有1个元素，每个值为10 vector v3(10,1); //v1 有10个元素，每个值为1 vector v4{10,1}; //v2 有2个元素，分别为10，1 # int i = 1,&amp;ci = i; decltype(ci) z;//错误：z是一个引用，必须初始化 decltype((i)) z;//错误:注意括号() # int arr[10] //arr 是一个含有10个整数的数组 int *p1[10] //p1是一个含有10个指针的数据 int (*p2)[10] = &arr; //p2是一个指针，它指向含有10个整数的数组 #用struct和class定义类的唯一区别是默认的访问权限 #友元 extern std::ostream&amp; storeOn(std::ostream &amp;,Screen &amp;); extern BitMap&amp; storeOn(BitMap &amp;, Screen &amp;); class Screen { // storeOn的ostream版本能访问Screen对象的私有化部分 friend std::ostream&amp; storeOn(std::ostream &amp;,Screen &amp;); }; #构造函数初始值列表 class ConstRef { public: ConstRef(int ii); private: int i; const int ci; int &ri; }; //错误的初始化 CostRef::ConstRef(int ii) { i = ii; ci = ii;//错误 ri = i;//错误 } //正确：显式地初始化引用和const成员 CostRef::ConstRef(int ii):i(ii),ci(ii),ri(i){} #默认构造函数 class NoDefault { public: NoDefault(const std::string&amp;); }; struct A{ NoDefault my_mem; }; A a;//错误：不能为A 合成构造函数 struct B { B() {}//错误 NoDefault b_member; } #不完全类型： class A{ private: static A sa; A *pa; A a;//错误，不能是不完全类型 }; #虚函数：动态绑定只能通过调用指针或引用的时候才发生，普通类型则直接确定 base = derived; //把derived的Quote部分拷贝给base base.net_price(20) //调用Quote::net_price #派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员对于普通的基类对象中的成员不具有特殊的访问权限 #聚合类：只含有公有成员的类，并且没有类内初始值或构造函数。聚合类的成员可以使用花括号括起来的初始值列表进行初始化 #委托构造 #explicit 概念","categories":[{"name":"C","slug":"C","permalink":"http://blog.le-more.com/categories/C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.le-more.com/tags/c/"}]},{"title":"服务器开发之---MariaDB(MySql)","slug":"server/mariadb","date":"2018-07-29T02:46:09.000Z","updated":"2019-11-08T09:59:30.998Z","comments":true,"path":"2018/07/29/server/mariadb/","link":"","permalink":"http://blog.le-more.com/2018/07/29/server/mariadb/","excerpt":"","text":"安装 Max-MacBook-Pro:~ Max$ brew install mariadb==&gt; Downloading https://homebrew.bintray.com/bottles/mariadb-10.2.7_1.sierra.bot######################################################################## 100.0%==&gt; Pouring mariadb-10.2.7_1.sierra.bottle.tar.gz==&gt; Using the sandbox==&gt; /usr/local/Cellar/mariadb/10.2.7_1/bin/mysql_install_db –verbose –user=Max==&gt; CaveatsA “/etc/my.cnf” from another install may interfere with a Homebrew-builtserver starting up correctly. MySQL is configured to only allow connections from localhost by default To connect: mysql -uroot To have launchd start mariadb now and restart at login: brew services start mariadbOr, if you don’t want/need a background service you can just run: mysql.server start==&gt; Summary🍺 /usr/local/Cellar/mariadb/10.2.7_1: 623 files, 162.2MB 手动启动 Max-MacBook-Pro:~ Max$ mysql.server startStarting MySQL.170729 10:12:17 mysqld_safe Logging to ‘/usr/local/var/mysql/Max-MacBook-Pro.local.err’.170729 10:12:17 mysqld_safe Starting mysqld daemon with databases from /usr/local/var/mysql SUCCESS! 连接数据库 Max-MacBook-Pro:~ Max$ mysql -urootWelcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 9Server version: 10.2.7-MariaDB Homebrew Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others. Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement. 执行命令： MariaDB [(none)]&gt; show databases -&gt; ;+——————–+| Database |+——————–+| information_schema || mysql || performance_schema || test |+——————–+4 rows in set (0.01 sec) 退出 MariaDB [(none)]&gt; exitBye navicat for mac 完美破解版 解决远程连接 GRANT ALL PRIVILEGES ON . TO ‘root’@’%’ WITH GRANT OPTION ; FLUSH PRIVILEGES; 问题汇总 1.Host ‘xxx’ is not allowed to connect to this MySQL server.（1251 client does not support） 修改mysql库中user表User字段为root的Host为%；同时修改加密方式为：mysql_native_password，具体步骤： 1）打开CMD切到C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin 目录依实际而定 2）mysql -u root -p 3) 输入密码 4）修改 host: update host = ‘%’ from user where user = ‘root’ 5) 修改加密方式： #更改加密方式并更新一下用户的密码 ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘Root的密码’ PASSWORD EXPIRE NEVER; ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘Root的密码’; #刷新权限 FLUSH PRIVILEGES; 待续…","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.le-more.com/categories/Server/"}],"tags":[]},{"title":"Unity开发之音乐游戏---基础知识","slug":"u3d/unity-e5-bc-80-e5-8f-91-e8","date":"2018-07-06T13:23:14.000Z","updated":"2019-11-08T09:59:31.023Z","comments":true,"path":"2018/07/06/u3d/unity-e5-bc-80-e5-8f-91-e8/","link":"","permalink":"http://blog.le-more.com/2018/07/06/u3d/unity-e5-bc-80-e5-8f-91-e8/","excerpt":"","text":"最近工作需要做一款音乐游戏，这种类型从未开发过，对这种游戏也不怎么喜欢玩。程序开发不需要每样都精通，但要求善于分析问题，解决问题。下面汇总一下相关的知识。 一、基本概念： BGM:背景音乐； BPM:每分钟节拍数(Beat Per Minute)， 60/BPM 就是每一拍的时间； 采样率：每秒采样数量 采样数：一首BGM的采样总数 总时间=采样数/采样率 音符：二分音符，四分音符(4/4),八分音符，十六分音符，如果bpm为60，一秒为一拍，4/4就是一秒（一拍）弹4个音符(1、2、3、4；2、2、3、4……)，同理2/2就是一拍2个音符 下面的描述很好理解：百度知道 给您支个招。去琴行买个节拍器，不用买贵的，电子的也行，主要为了帮助你知道什么叫节拍。在琴行直接向老板询问使用方法。回家后自己调节拍器，调成一分钟60拍的。然后你会发现一秒钟节拍器响一下。响一下就叫一拍。你也可以调成一分钟80拍。90拍，120拍都可以。反正不管调成多快或者多慢速度的，反正响一下就叫一拍。这样您了解了吗？？好的，然后你跟着节拍器唱一、二、三、四。响一下唱一个数字，如此循环。这就是4/4拍里一小节有四拍的意思。好，下面解释什么叫以四分音符为一拍。如果你刚才按照我说的，唱一、二、三、四了，那么，响的时候，你唱的那个“一”就相当于一个四分音符。（关于四分音符的形状长相，参考你的乐理教材。不相信你那教材连个五线谱表都没有。）那么就是一拍一下了。下面练习八分音符，继续跟节拍器，响一下你唱两个音。一一、二二、三三、四四。也就是说一个数字占半拍，两个数字占一拍。同理，两个八分音符等于一个四分音符。这个明白了吧?继续，练习十六分音符。响一下唱四个数字：1111、2222、3333、4444！注意，一定要时值均匀的唱，不能忽快忽慢。这就是节奏问题。也就是四个十六分音符等于一个四分音符，四个十六分音符唱一拍。好了，现在练习八分和十六分结合。1/11、2/22、33/3、44/4。看懂了吗？“/”把数字隔开了，就是半拍半拍隔开了。都练习完了吗？好的，看谱子。把这些数字代入音符，就OK了。如果你能跟上节拍器，做完上述例子，恭喜你，你有节奏感了。哈哈哈哈~ 二、音乐游戏实现类型目前看到两种 1、BGM+打击音效 看一Cytus音乐格式（参考音乐游戏格式解析之【Cytus】） VERSION 2BPM 148.001968PAGE_SHIFT 0.300000PAGE_SIZE 1.621600NOTE 0 6.526000 0.900000 1.200000NOTE 1 8.148000 0.350000 0.000000NOTE 2 8.959000 0.650000 0.000000NOTE 3 9.567000 0.150000 1.200000NOTE 4 9.567000 0.850000 1.200000NOTE 5 13.013000 0.250000 0.000000NOTE 6 13.824000 0.600000 0.000000NOTE 7 14.635000 0.100000 0.816667NOTE 8 14.635000 0.850000 0.800000NOTE 9 16.256001 0.350000 0.000000NOTE 10 17.066999 0.700000 0.000000NOTE 11 17.878000 0.150000 0.816667NOTE 12 17.878000 0.900000 0.800000NOTE 13 19.499001 0.250000 0.000000NOTE 14 20.309999 0.650000 0.000000NOTE 15 21.121000 0.350000 0.000000………………………………………………..NOTE 226 141.526001 0.500000 0.000000NOTE 227 142.642868 0.250000 0.000000NOTE 228 142.692932 0.200000 0.000000NOTE 229 142.742996 0.150000 0.000000LINK 217 218 219LINK 143 144 145 146 147 148 149 150 151 152 153 154 155LINK 221 222 223 224LINK 227 228 229LINK 126 127 NOTE 为打击点 第二列是序号，第三个是打击点的时间，第四是位置，第五是持续时长，其他信息请参看原文。 TAKT-RHYTHM是使用LeapMotion设备为玩法的音乐游戏 start_second=0; &amp;takt_note=4.344947,3,0,0.5,0|4.824946,3,0,0.5,0|5.304945,3,0,0.5,0|5.784943,3,0,0.5,0|6.264945,3,0.25,0.75,0|6.744944,3,0.25,0.75,0|7.224945,3,0.25,0.75,0|7.704945,3,0.25,0.75,1|8.184945,3,0.5,1,0|8.664947,3,0.5,1,0|9.144946,3,0.5,1,0|9.624948,3,0.5,1,0|10.10495,3,0.25,0.75,0|10.58495,3,0.25,0.75,0|11.06495,3,0.25,0.75,0|11.54495,3,0.25,0.75,1|12.02495,3,0,0.5,0|12.02495,3,0.5,1,0|12.50495,3,0,0.5,0|12.50495,3,0.5,1,0|12.98495,0,0,0.5,0|12.98495,2,0.5,1,0|13.46495,3,0,0.5,0|13.46495,3,0.5,1,0|13.94495,0,0,0.5,0|13.94495,2,0.5,1,0|14.42496,0,0.25,0.75,0|14.42496,2,0.25,0.75,0|14.90496,0,0.5,1,0|14.90496,2,0,0.5,0|15.38498,1,0,0.5,1|15.38498,1,0.5,1,1; &amp;slide_note=15.86495,3,0.75,1,0,0^16.82495,3,0,0.25,0,6^17.30494,3,0.75,1,0,0|17.78496,3,0,0.25,0,0^18.26497,3,0.75,1,0,6^18.74497,3,0,0.25,0,6^19.22496,3,0.75,1,0,0|19.70495,3,0,0.25,0,0^21.14495,3,0.375,0.625,0,0^21.62495,3,0.375,0.625,0,0^23.06495,1,0.375,0.625,0,0|19.70495,3,0.75,1,0,0^21.14495,3,0.375,0.625,0,0^21.62494,3,0.375,0.625,0,6^23.06495,1,0.375,0.625,0,0; &amp;clap_note=23.54495,2,0,1,0|24.50496,0,0,1,0|25.46496,2,0,1,0|25.94495,3,0,1,0|26.42496,0,0,1,0|27.38496,0,0,0,0|27.38496,2,0,0,0|28.34496,1,0,0,0|28.34496,3,0,0,0|29.30495,0,0,0,0|29.30495,2,0,0,0|30.74495,0,0,1,0|30.74495,2,0,1,0; &amp;rhythm=0.5049076,125|4.344908,125; &amp;camera_mode=; &amp;back_color01=;&amp;back_color02=;&amp;image_color01=;&amp;image_color02=; &amp;start_back_color01=;&amp;start_back_color02=;&amp;start_image_color01=;&amp;start_image_color02=; &amp;takt_note是打击点列表，以|分隔每个打击点，以“，”分隔每个参数，参数的意义类似的是时间，打击乐类型等信息。 2、曲谱+按键音效 别踩白块儿2是一款移动端音乐游戏。程序包很小，原因就是音效文件只有各个音符，并不是一整首音乐。看一下曲子的配置文件 {“baseBpm”:145,”musics”:[{“id”:1,”baseBeats”:0.5,”scores”:[“c2[K],d2[K],e2[K],c2[K];c2[K],d2[K],e2[K],c2[K];e2[K],f2[K],g2[J];e2[K],f2[K],g2[J];g2[L],a2[L],g2[L],f2[L],e2[K],c2[K];g2[L],a2[L],g2[L],f2[L],e2[K],c2[K];d2[K],g1[K],c2[J];d2[K],g1[K],(c1.e1.g1.c2)[J];”,”c[L],g[L],e[L],g[L],c[L],g[L],e[L],g[L];c[L],g[L],e[L],g[L],c[L],g[L],e[L],g[L];c[L],g[L],e[L],g[L],c[L],g[L],e[L],g[L];c[L],g[L],e[L],g[L],c[L],g[L],e[L],g[L];d[L],g[L],(B-1)[L],g[L],c[L],g[L],e[L],g[L];d[L],g[L],(B-1)[L],g[L],c[L],g[L],e[L],g[L];d[L],g[L],(B-1)[L],g[L],c[L],g[L],e[L],g[L];d[L],g[L],(B-1)[L],g[L],c[J];”]},{“id”:2,”baseBeats”:0.5,”scores”:[“c2[K],d2[L],U,e2[K],(g1.c2)[K];c2[K],d2[L],U,e2[K],(g1.c2)[K];(g1.e2)[K],f2[L],U,g2[L],c2[L],U,U;(g1.e2)[K],f2[L],U,g2[L],U,c2[L],d2[L];g2[L],(d1.a2)[L],(g1.g2)[L],f2[L],e2[L],g1[L],c2[L],e2[L];g2[L],(d1.a2)[L],(g1.g2)[L],f2[L],e2[L],g1[L],(c1.c2)[K];d2[L],d1[L],g1[L],d2[L],c2[L],g1[L],d1[L],U;d2[K],g1[L],d2[L],(e1.c2)[J];”,”c[L],g[L],c1[L],d1[K],c1[L],U,g[L];c[L],g[L],c1[L],d1[K],c1[L],U,g[L];c[L],g[L],c1[L],e1[K],U,g1[L],c1[L];c[L],g[L],c1[L],e1[K],g1[K],U;g[J],d[J];g[J],d[KL],g[L];g[JKL],g[L];d[J],(c.g)[J];”]},{“id”:3,”baseBeats”:0.5,”scores”:[“c2[K],d2[L],g1[L],e2[L],g1[L],c2[L],g1[L];c2[K],d2[L],g1[L],e2[L],g1[L],c2[L],g1[L];d2[K],e2[L],d1[L],g2[L],d1[L],e2[L],c2[L];d2[K],e2[K],g2[L],d1[L],d2[L],e2[L];g2[L],a2[L],e2[L],d2[L],g2[L],e2[L],d2[L],c2[L];g2[L],a2[L],g2[L],e2[L],g2[L],d2[L],e1[L],c2[L];d2[L],e2[L],a1[L],(d1.g1)[K],(d1.c2)[K],d1[L];c2[L],(d1.d2)[L],a1[L],(d1.g1)[L],c1[L],c2[KL];”,”c1[L],g1[JKL];c1[L],g1[JKL];g[L],d1[JK],d1[L];g[L],d1[L],U,d1[L],S;f[L],a[L],U,c1[L],U,c1[L],T;g[L],d1[L],U,d1[L],U,d1[L],U,d1[L];g[L],d1[L],T,S;c[I];”]}]} Json格式，粘贴到Json在线编辑器，会很到很清晰的结构。 baseBpm： 定义曲子的bpm musics：包含几个曲子 scores：谱子，包含主谱子和伴奏，通常0是主音，后面是伴奏 c2[K],d2[K],e2[K],c2[K]：单个拍子中的音符，每个拍子以”;”分隔，单个音符是”,”分隔 [K][L]:单个音符的时长 其实就是音乐谱子，只是和平常谱子不同的是，仅程序能解读，本质是一样的。后面会单独一篇日志详细解析这种格式","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之工具一技能参数配置","slug":"u3d/unity-e5-bc-80-e5-8f-91-e4","date":"2018-07-05T13:07:24.000Z","updated":"2019-11-08T09:59:31.020Z","comments":true,"path":"2018/07/05/u3d/unity-e5-bc-80-e5-8f-91-e4/","link":"","permalink":"http://blog.le-more.com/2018/07/05/u3d/unity-e5-bc-80-e5-8f-91-e4/","excerpt":"","text":"在开发游戏过程中，涉及到各种数值和特效的调整，就需要程度开发个工具方便策划或特效调整数值，下面介绍一下调整技能数值的工具。 说是工具，其实就是一个场景，提供一参数配置，就长这样： 就这样？还是那句话：能解决问题的工具就是好工具 看一技能表中的数据配置有哪些需要调整的： 可以看到需要调整的条目还是很多的，从对象的角度看就两个，一个是具体的技能，一个是所属的角色，所以工具脚本中提供 Fairy File和Skill SID,确定这两个其他的数值都有了，然后在运行过程中调整即可 从Excel中导表到程序中可以查看Unity开发之导表（Excel）工具的制作分析，可方便在Excel配置数据然后导入到程序中使用。 如何在程序运行时调整，在程序逻辑中找一个时点，加载最新的配置即可，比如在这个工具中每个回合开始从界面上加载一下，然后开始新的回合。 看一运行时的画面 动图 这个工具是在游戏中战斗场景基础上修改的，加了测试的逻辑，可模拟真实战斗的情况","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之工具---GPS数据采集","slug":"u3d/unity-e5-bc-80-e5-8f-91-e5","date":"2018-07-04T13:06:47.000Z","updated":"2019-11-08T09:59:31.021Z","comments":true,"path":"2018/07/04/u3d/unity-e5-bc-80-e5-8f-91-e5/","link":"","permalink":"http://blog.le-more.com/2018/07/04/u3d/unity-e5-bc-80-e5-8f-91-e5/","excerpt":"","text":"工具系列： Unity开发之导表（Excel）工具的制作分析 工欲善其事，必先利其器。程序开发离不开各种工具的制作。下面介绍获取GPS数据工具的制作。 制作这个工具的前提，必须先制作好Unity定位插件的开发，关于定位插件的开发介绍，传送门： Unity开发高德地图定位和地理围栏插件(iOS) Unity开发高德地图定位和地理围栏插件(Android) 先看一下效果图： 从界面看还是比较简陋的，但能完成目标的工具就是好工具。 首先开启定位 //打开定位public void OnStartLocation( ) { amapHelper.StartLocation(GlobalDef.AMap_ApiKey);} //关闭定位public void OnStopLocation() { amapHelper.StopLocation();} //定位回调void locationChanged() { UnityLibs.Debuger.Log(“locationChanged” + amapHelper.locationInfo.Longitude.ToString() + “ “ + amapHelper.locationInfo.Latitude); lat = amapHelper.locationInfo.Latitude; lng = amapHelper.locationInfo.Longitude; txtLongitude.text = amapHelper.locationInfo.Longitude.ToString(); txtLatitude.text = amapHelper.locationInfo.Latitude.ToString();} void OnDestroy(){ //移除监听 amapHelper.locationChanged -= locationChanged;} 在成功开启定位后，走到要添加的位置，点击添加 //添加public void OnAdd() { var item = Instantiate(itemPrefab); double distance = 0; if (itemList.Count &gt; 0) { ItemBehaviour last = itemList\\[itemList.Count - 1\\].GetComponent&lt;ItemBehaviour&gt;(); distance = Utils.GetDistance(last.lat, last.lng,lat,lng); } item.GetComponent&lt;ItemBehaviour&gt;().OnInit(lat, lng, distance); itemList.Add(item); item.transform.parent = content; content.sizeDelta = new Vector2(0, itemList.Count * 140); SaveFile();} //删除public void OnDelete() { if (itemList.Count &gt; 0) { var last = itemList[itemList.Count - 1]; Destroy(last); itemList.Remove(last); } content.sizeDelta = new Vector2(0, itemList.Count * 140); SaveFile();} //保存到文件void SaveFile(){ string strLoc = “”; foreach (var item in itemList) { strLoc += item.GetComponent().lat + “,” + item.GetComponent().lng; strLoc += “;”; } strLoc = strLoc.Remove(strLoc.Length - 1); string destPath = Path.Combine(FileUtils.GetWritePath(), &quot;Location.txt&quot;); if (File.Exists(destPath)) File.Delete(destPath); StreamWriter sw; FileInfo t = new FileInfo(destPath); if (!t.Exists) { sw = t.CreateText(); } else { sw = t.AppendText(); } sw.WriteLine(strLoc); sw.Close(); sw.Dispose();} 添加的同时会从将所有记录的GPS坐标点写入到Location.txt文件中，类似如下的数据： 31.1875618489583, 121.436771104601;31.1880425347222, 121.436774359809;31.1878998480903, 121.435769042969;31.1877416992188, 121.43583062066 当记录完所有位置的坐标后，从手机中取出Location.txt，加载到实际的场景中： 红色区域就是从经纬度转为二维坐标，然后使用Gizmos描绘出的记录的GPS坐标，和现场的场景是可以对应的上的。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发之网络一TCP服务端实现","slug":"u3d/unity-e5-bc-80-e5-8f-91-e7","date":"2018-07-03T13:40:05.000Z","updated":"2019-11-08T09:59:31.022Z","comments":true,"path":"2018/07/03/u3d/unity-e5-bc-80-e5-8f-91-e7/","link":"","permalink":"http://blog.le-more.com/2018/07/03/u3d/unity-e5-bc-80-e5-8f-91-e7/","excerpt":"","text":"Unity开发之网络—集成Protobuf Unity开发之网络一HTTP客户端实现 Unity开发之网络一HTTP服务端实现 Unity开发之网络一TCP客户端实现 下面介绍服务端，共涉及三个类：SocketModule，SocketEngine，ServerSocketItem SocketModule：同客户端，定义接口及数据包结构等定义； SocketEngine：服务端接收客户端连接等处理； ServerSocketItem：单个客户端数据交互的处理； 下面主要介绍SocketEngine 开启服务 public bool StartServer(string ip, string port){ m_bService = true; // 创建负责监听的套接字 m_hServerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); m_hServerSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true); IPAddress address = IPAddress.Parse(ip); // 创建包含ip和端口号的网络节点对象； IPEndPoint endPoint = new IPEndPoint(address, int.Parse(port)); try { //将负责监听的套接字绑定到唯一的ip和端口上； m_hServerSocket.Bind(endPoint); } catch (SocketException se) { onShowMsg(&quot;异常：&quot; + se.Message); return false; } // 设置监听队列的长度； m_hServerSocket.Listen(10); // 创建负责监听的线程； m_SocketAcceptThread = new Thread(ListenSocket); m_SocketAcceptThread.IsBackground = true; m_SocketAcceptThread.Start(); //检测线程 m_dwTickCount = 0; m_SocketDetectThread = new Thread(DetectSocket); m_SocketDetectThread.IsBackground = true; m_SocketDetectThread.Start(); onShowMsg(&quot;服务启动成功！&quot;); return true;} 服务启动成功后，会启动监听线程，接收客户端的连接 /// /// 监听客户端请求的方法；/// void ListenSocket(){ while (IsService()) { try { // 开始监听客户端连接请求，Accept方法会阻断当前的线程 Socket connect = m_hServerSocket.Accept(); if (connect.Connected &amp;&amp; !m_SocketRSThread.ContainsKey(connect.RemoteEndPoint.ToString())) { //创建接收对象 ServerSocketItem socketItem = new ServerSocketItem((short)m_StorageSocketItem.Count, this); socketItem.Attach(connect); // 将与客户端连接的 套接字 对象添加到集合中 m_StorageSocketItem.Add(socketItem); onSocketConnect(true, socketItem.GetClientAddr()); if (m_pIServerSocketItemSink != null) { m_pIServerSocketItemSink.OnSocketAcceptEvent(socketItem); } Thread thread = new Thread(RecvSocket); thread.IsBackground = true; thread.Start(socketItem); m_SocketRSThread.Add(connect.RemoteEndPoint.ToString(), thread); } } catch(Exception e) { Console.WriteLine(this.GetType().ToString() + &quot;:&quot; + e.ToString()); } }} void RecvSocket(object item){ ServerSocketItem socketItem = item as ServerSocketItem; while (IsService() &amp;&amp; socketItem.IsValidSocket()) { try { //length = socketClient.Receive(arrMsgRec); // 接收数据，并返回数据的长度； socketItem.RecvData(); } catch (SocketException se) { onShowMsg(“异常：” + se.Message); RemoveSocketItem(socketItem); break; } catch (Exception e) { onShowMsg(&quot;异常：&quot; + e.Message); RemoveSocketItem(socketItem); break; } }} 接收到客户端的连接请求后，启动一个读写线程，创建ServerSocketItem变量与之对应 心跳检测 void DetectSocket(){ while (IsService()) { //设置间隔 Thread.Sleep(500); m_dwTickCount += 500L; if (m\\_dwTickCount &gt; SocketModule.TIME\\_DETECT\\_SOCKET &amp;&amp; m\\_StorageSocketItem != null) { m_dwTickCount = 0; for (int i = 0; i &lt; m_StorageSocketItem.Count; ++i) { var socketItem = m_StorageSocketItem\\[i\\]; if (socketItem != null) { CMD\\_KN\\_DetectSocket detectSocket = new CMD\\_KN\\_DetectSocket(); detectSocket.dwSendTickCount = 0;// int.Parse(ZYSoft.Utils.Time.GetTimeStamp(DateTime.Now)); byte\\[\\] cbDataBuffer = detectSocket.Encode(); socketItem.SendData(cbDataBuffer, (short)cbDataBuffer.Length, SocketModule.MDM\\_KN\\_COMMAND, SocketModule.SUB\\_KN\\_DETECT_SOCKET, socketItem.GetRountID()); } } } }} 网络引擎和应用层交互通过IServerSocketItemDelegate接口 //连接对象回调接口public interface IServerSocketItemDelegate{ //应答消息 bool OnSocketAcceptEvent(ServerSocketItem serverSocketItem); //读取消息 bool OnSocketReadEvent(CMD_Command Command, byte[] pBuffer, short wDataSize, ServerSocketItem serverSocketItem); //关闭消息 bool OnSocketCloseEvent(ServerSocketItem serverSocketItem);}; 示例 public class AttemperEngine : IServerSocketItemDelegate {………………………………. public bool OnSocketAcceptEvent(ServerSocketItem serverSocketItem) { return true; } public bool OnSocketReadEvent(CMD_Command Command, byte\\[\\] pBuffer, short wDataSize, ServerSocketItem serverSocketItem) { return false; } public bool OnSocketCloseEvent(ServerSocketItem serverSocketItem) { return false; }} ServerSocketItem处理与客户端数据的接收与发送 接收 //接收操作public void RecvData(){ //效验变量 //Debug.Assert(m_bRecvIng == false); if(m_hSocket == null) return; //判断关闭 if (m_bCloseIng == true) { CloseSocket(m_wRountID); return; } //设置变量 m_bRecvIng = true; m_dwRecvTickCount = DateTime.Now.Millisecond / 1000; //判断关闭 if (m_hSocket == null) { CloseSocket(m_wRountID); } //接收数据 int iRetCode = m\\_hSocket.Receive(m\\_cbRecvBuf, m\\_wRecvSize, (int)(m\\_cbRecvBuf.GetLength(0) - m_wRecvSize), SocketFlags.None); if (iRetCode &lt;= 0) { CloseSocket(m_wRountID); } //接收完成 m_wRecvSize += iRetCode; //byte\\[\\] cbBuffer = new byte\\[SocketModule.SOCKET_BUFFER\\]; CMD\\_Head pHead = new CMD\\_Head(); //pHead.Decode(m_cbRecvBuf); //处理数据 while (m\\_wRecvSize &gt;= CMD\\_Head.sizeof\\_CMD\\_Head) { pHead.Decode(m_cbRecvBuf); //效验数据 short wPacketSize = pHead.cmdInfo.wDataSize; if (wPacketSize &gt; SocketModule.SOCKET_BUFFER) break;// throw (&quot;数据包超长&quot;); if (wPacketSize &lt; CMD\\_Head.sizeof\\_CMD_Head) break;// throw (&quot;数据包非法&quot;); if (pHead.cmdInfo.cbMessageVer != SocketModule.SOCKET_VER) break;// throw (&quot;数据包版本错误&quot;); if (m_wRecvSize &lt; wPacketSize) break; byte\\[\\] cbBuffer = new byte\\[wPacketSize\\]; //提取数据 Buffer.BlockCopy(m_cbRecvBuf, 0, cbBuffer, 0, wPacketSize); short wRealySize = CrevasseBuffer(cbBuffer, wPacketSize); m_dwRecvPacketCount++; //删除缓存数据 m_wRecvSize -= wPacketSize; Buffer.BlockCopy(m\\_cbRecvBuf, wPacketSize, m\\_cbRecvBuf, 0, m_wRecvSize); //解释数据 short wDataSize = (short)(wRealySize - CMD\\_Head.sizeof\\_CMD_Head); pHead = new CMD_Head(); pHead.Decode(cbBuffer); //m_strRecvSession = Encoding.Default.GetString(pHead.cbSession); CMD_Command Command = pHead.command; //内核命令 if (Command.wMainCmdID == SocketModule.MDM\\_KN\\_COMMAND) { switch (Command.wSubCmdID) { case SocketModule.SUB\\_KN\\_DETECT_SOCKET: //网络检测 { break; } default: break;// throw (&quot;非法命令码&quot;); } } else { //数据消息处理 Buffer.BlockCopy(cbBuffer, CMD\\_Head.sizeof\\_CMD_Head, cbBuffer, 0, wDataSize); m_pIServerSocketItemSink.OnSocketReadEvent(Command, cbBuffer, wDataSize, this); } }} 发送 //发送函数public bool SendData(byte[] pData, short wDataSize, short wMainCmdID, short wSubCmdID, short wRountID) { //效验参数 //Debug.Assert(wDataSize &lt;= SocketModule.SOCKET_PACKAGE); //效验状态 if (m_bCloseIng == true) return false; if (m_wRountID != wRountID) return false; if (m_dwRecvPacketCount == 0) return false; if (IsValidSocket() == false) return false; if (wDataSize &gt; SocketModule.SOCKET_PACKAGE) return false; //构造数据 byte\\[\\] cbDataBuffer = new byte\\[SocketModule.SOCKET_BUFFER\\]; CMD\\_Head pHead = new CMD\\_Head(); pHead.command.wMainCmdID = wMainCmdID; pHead.command.wSubCmdID = wSubCmdID; Array.Copy(pHead.Encode(), cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head); if (wDataSize &gt; 0) { Debug.Assert(pData != null); Array.Copy(pData, 0, cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head, wDataSize); } //加密数据 short wSendSize = EncryptBuffer(cbDataBuffer, (short)(CMD\\_Head.sizeof\\_CMD_Head + wDataSize), (short)cbDataBuffer.GetLength(0)); //发送数据 return SendRawData(cbDataBuffer, wSendSize,wRountID);} //发送函数public bool SendRawData(byte[] pData, short wDataSize, short wRountID) { bool ret = true; try { IAsyncResult asyncSend = m_hSocket.BeginSend(pData, 0, wDataSize, SocketFlags.None, new AsyncCallback(sendCallback), m_hSocket); bool success = asyncSend.AsyncWaitHandle.WaitOne(5000, true); if (!success) { CloseSocket(wRountID); ret = false; Console.WriteLine(“Failed to SendMessage server.”); } } catch { ret = false; Console.WriteLine(“send message error”); } return ret;} private void sendCallback(IAsyncResult async){ try { //结束挂起的异步发送 SocketError errorCode; Socket socket = (Socket)async.AsyncState; int dwSendSize = socket.EndSend(async, out errorCode); Console.WriteLine(&quot;send size :&quot; + dwSendSize.ToString()); } catch (Exception e) { Console.WriteLine(&quot;error :&quot; + e.ToString()); } finally { }} ServerSocketItem和应用层的交互也是通过IServerSocketItemDelegate 一个ServerSocketItem对应一个GameUser实例 界面长这个样子,^^","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发之网络一TCP客户端实现","slug":"u3d/unity-e5-bc-80-e5-8f-91-e6","date":"2018-07-03T13:05:41.000Z","updated":"2019-11-08T09:59:31.022Z","comments":true,"path":"2018/07/03/u3d/unity-e5-bc-80-e5-8f-91-e6/","link":"","permalink":"http://blog.le-more.com/2018/07/03/u3d/unity-e5-bc-80-e5-8f-91-e6/","excerpt":"","text":"网络开发系列 Unity开发之网络—集成Protobuf Unity开发之网络一HTTP客户端实现 Unity开发之网络一HTTP服务端实现 下面介绍Sockt通信的实现，和Http相比Tcp/IP实现要复杂一些。不过使用C#语言开发要容易了很多。为什么这样说呢，因为以前写过使用C++实现Socket通信，在项目中已经编写完成，但因为外因，项目没有上线，最后日志也不了了之 跨平台客户端Socket 一 数据包定义 下面介绍使用C#实现Socket通信，包体结构及定义从C++修改而来。 主要涉及三个类SocketModule，ClientSocket，ClientSocketHelper SocketModule：定义包头结构，ClientSocket的接收连接等接口，以及其他定义 ClientSocket：网络连接的具体实现 ClientSocketHelper：二次封装，方便应用层调用 ClientSocket主要代码如下： 网络连接 public virtual bool Connect(string szServerIP, short wPort){ //效验参数 Debug.Assert(m_SocketState == enSocketState.SocketState_NoConnect); m_SocketState = enSocketState.SocketState_Connecting; IPAddress\\[\\] addressArray = Dns.GetHostAddresses(szServerIP); if (addressArray\\[0\\].AddressFamily == AddressFamily.InterNetworkV6) { //创建Socket对象， 连接类型是TCP m_hSocket = new Socket(AddressFamily.InterNetworkV6, SocketType.Stream, ProtocolType.Tcp); } else { //创建Socket对象， 连接类型是TCP m_hSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); } //服务器IP地址 IPAddress ipAddress = IPAddress.Parse(addressArray\\[0\\].ToString()); //服务器端口 IPEndPoint ipEndpoint = new IPEndPoint(ipAddress, wPort); //这是一个异步的建立连接，当连接建立成功时调用connectCallback方法 IAsyncResult result = m\\_hSocket.BeginConnect(ipEndpoint, new AsyncCallback(connectCallback), m\\_hSocket); //这里做一个超时的监测，当连接超过30秒还没成功表示超时 bool success = result.AsyncWaitHandle.WaitOne(30000, true); if (!success) { //超时 CloseSocket(false); UnityLibs.Debuger.Log(&quot;connect Time Out&quot;); m\\_SocketState = enSocketState.SocketState\\_NoConnect; if (m_pClientSocketDelegate != null) { m_pClientSocketDelegate.OnSocketConnect(-1, &quot;连接超时&quot;, this); } return false; } else { return true; }} private void connectCallback(IAsyncResult async){ try { //结束挂起的异步连接 Socket socket = (Socket)async.AsyncState; if (socket.Connected) { socket.EndConnect(async); //设置参数 m_dwRecvSize = 0; m_cbSendRound = 0; m_cbRecvRound = 0; m_dwSendXorKey = 0x12345678; m_dwRecvXorKey = 0x12345678; m_dwSendTickCount = DateTime.Now.Millisecond / 1000; m_dwRecvTickCount = DateTime.Now.Millisecond / 1000; m\\_SocketState = enSocketState.SocketState\\_Connected; if(m_pClientSocketDelegate != null) { m_pClientSocketDelegate.OnSocketConnect(0, &quot;&quot;, this); } //与m_hSocket建立连接成功，开启线程接受服务端数据。 Thread thread = new Thread(new ThreadStart(RecvSocket)); thread.IsBackground = true; thread.Start(); //开启心跳检测,毫秒为单位 m\\_timerDetectSocket = new Timer(timerHandler, m\\_hSocket, 60 * 1000, 5 * 1000); UnityLibs.Debuger.Log(&quot;connectSuccess&quot;); } else { m\\_SocketState = enSocketState.SocketState\\_NoConnect; if (m_pClientSocketDelegate != null) { m_pClientSocketDelegate.OnSocketConnect(-2, &quot;连接出错&quot;, this); } } } catch (Exception e) { UnityLibs.Debuger.Log(&quot;error.&quot; + e); m\\_SocketState = enSocketState.SocketState\\_NoConnect; if (m_pClientSocketDelegate != null) { m_pClientSocketDelegate.OnSocketConnect(-2, &quot;连接异常&quot;, this); } }} 需要注意的是连接时要检测是否是IPV6的网络，否则iOS无法通过审核。连接成功会开启接收线程和心跳包检测定时任务。 接收： private void RecvSocket(){ //在这个线程中接受服务器返回的数据 while (m_SocketState == enSocketState.SocketState_Connected) { if (!m_hSocket.Connected) { //与服务器断开连接跳出循环 UnityLibs.Debuger.Log(“Failed to clientSocket server.”); CloseSocket(true); break; } try { if (m_hSocket.Available &lt;= 0) continue; int iRetCode = m\\_hSocket.Receive(m\\_cbRecvBuf,m\\_dwRecvSize,m\\_cbRecvBuf.GetLength(0) - m_dwRecvSize, SocketFlags.None); //int iRetCode = m\\_hSocket.Receive(m\\_cbRecvBuf, m\\_dwRecvSize, SocketModule.SOCKET\\_BUFFER - m_dwRecvSize, SocketFlags.None); if (iRetCode &lt;= 0) { CloseSocket(true); break; } else { Debug.Assert(m_dwSendPacketCount &gt; 0); m_dwRecvSize += iRetCode; m_dwRecvTickCount = DateTime.Now.Millisecond / 1000; //变量定义 short wPacketSize = 0; //byte \\[\\]cbDataBuffer = new byte\\[SocketModule.SOCKET_BUFFER\\]; CMD\\_Head pHead = new CMD\\_Head(); while (m\\_dwRecvSize &gt;= CMD\\_Head.sizeof\\_CMD\\_Head) { //效验参数 pHead.Decode(m_cbRecvBuf); wPacketSize = pHead.cmdInfo.wDataSize; Debug.Assert(wPacketSize &lt;= (SocketModule.SOCKET\\_PACKAGE + CMD\\_Head.sizeof\\_CMD\\_Head)); if (pHead.cmdInfo.cbMessageVer != SocketModule.SOCKET_VER) break;// throw (&quot;数据包版本错误&quot;); if (wPacketSize &gt; (SocketModule.SOCKET\\_PACKAGE + CMD\\_Head.sizeof\\_CMD\\_Head)) break;// throw (&quot;数据包太大&quot;); if (m_dwRecvSize &lt; wPacketSize) break;//throw (&quot;数据包太小&quot;); byte\\[\\] cbDataBuffer = new byte\\[wPacketSize\\]; //拷贝数据 m_dwRecvPacketCount++; Array.Copy(m_cbRecvBuf,cbDataBuffer,wPacketSize); //删除缓存数据 m_dwRecvSize -= wPacketSize; Array.Copy(m\\_cbRecvBuf, wPacketSize, m\\_cbRecvBuf, 0, m_dwRecvSize); //解密数据 short wRealySize = CrevasseBuffer(cbDataBuffer, wPacketSize); Debug.Assert(wRealySize &gt;= CMD\\_Head.sizeof\\_CMD_Head); //解释数据 short wDataSize = (short)(wRealySize - CMD\\_Head.sizeof\\_CMD_Head); CMD_Command Command = pHead.command; Array.Copy(cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head, cbDataBuffer, 0, wDataSize); //UnityLibs.Debuger.Log(&quot;RecvData :&quot; + pHead.command.wMainCmdID // \\+ &quot; sub:&quot; + pHead.command.wSubCmdID // \\+ &quot; dataSize:&quot; + (pHead.cmdInfo.wDataSize - CMD\\_Head.sizeof\\_CMD_Head) // \\+ &quot; recvSize:&quot; + pHead.cmdInfo.wDataSize // ); //内核命令 if (Command.wMainCmdID == SocketModule.MDM\\_KN\\_COMMAND) { switch (Command.wSubCmdID) { case SocketModule.SUB\\_KN\\_DETECT_SOCKET: //网络检测 { //发送数据 SendData(SocketModule.MDM\\_KN\\_COMMAND, SocketModule.SUB\\_KN\\_DETECT_SOCKET, cbDataBuffer, wDataSize); break; } } } else { bool bSuccess = false; if (m_pClientSocketDelegate != null) { bSuccess = m_pClientSocketDelegate.OnSocketRead(Command, cbDataBuffer, wDataSize, this); } if (bSuccess == false) { foreach (IClientSocketRecvDelegate socketRecv in m_listSocketRecvDelegate) { bSuccess = socketRecv.OnSocketRead(Command, cbDataBuffer, wDataSize, this); if (bSuccess) { break; } } if (bSuccess == false) { UnityLibs.Debuger.Log(&quot;网络数据包处理失败&quot;); } } } } } } catch (Exception e) { UnityLibs.Debuger.Log(&quot;Failed to clientSocket error.&quot; + e); CloseSocket(true); break; } }} 接收线程主要是对网络传递的数据流解析为定义的数据包，要注意的是数据的连包和沾包处理。 数据发送 public virtual bool SendData(short wMainCmdID, short wSubCmdID){ //效验状态 if (m_hSocket == null) return false; if (m_SocketState != enSocketState.SocketState_Connected) return false; //构造数据 CMD\\_Head pHead = new CMD\\_Head(); pHead.command.wMainCmdID = wMainCmdID; pHead.command.wSubCmdID = wSubCmdID; //if (AppUser.Instance.Session.Length == SocketModule.SOCKET\\_PACKAGE\\_SESSION) // Array.Copy(Encoding.Default.GetBytes(AppUser.Instance.Session), pHead.cbSession, SocketModule.SOCKET\\_PACKAGE\\_SESSION); byte\\[\\] cbDataBuffer = new byte\\[SocketModule.SOCKET_BUFFER\\]; Array.Copy(pHead.Encode(), cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head); //加密数据 short wSendSize = EncryptBuffer(cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head, (short)cbDataBuffer.GetLength(0)); //发送数据 return SendBuffer(cbDataBuffer, wSendSize);} //发送函数public virtual bool SendData(short wMainCmdID, short wSubCmdID, byte[] pData, short wDataSize){ //效验状态 if (m_hSocket == null) return false; if (m_SocketState != enSocketState.SocketState_Connected) return false; //效验大小 Debug.Assert(wDataSize &lt;= SocketModule.SOCKET_PACKAGE); if (wDataSize &gt; SocketModule.SOCKET_PACKAGE) return false; //构造数据 byte\\[\\] cbDataBuffer = new byte\\[SocketModule.SOCKET_BUFFER\\]; CMD\\_Head pHead = new CMD\\_Head(); pHead.command.wMainCmdID = wMainCmdID; pHead.command.wSubCmdID = wSubCmdID; Array.Copy(pHead.Encode(), cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head); if (wDataSize &gt; 0) { Debug.Assert(pData != null); Array.Copy(pData,0, cbDataBuffer, CMD\\_Head.sizeof\\_CMD_Head,wDataSize); } //加密数据 short wSendSize = EncryptBuffer(cbDataBuffer, (short)(CMD\\_Head.sizeof\\_CMD_Head + wDataSize), (short)cbDataBuffer.GetLength(0)); //发送数据 return SendBuffer(cbDataBuffer, wSendSize);} bool SendBuffer(byte[] pBuffer, int dwSendSize){ bool ret = true; try { IAsyncResult asyncSend = m_hSocket.BeginSend(pBuffer, 0, dwSendSize, SocketFlags.None, new AsyncCallback(sendCallback), m_hSocket); bool success = asyncSend.AsyncWaitHandle.WaitOne(5000, true); if (!success) { CloseSocket(true); ret = false; UnityLibs.Debuger.Log(“Failed to SendMessage server.”); } } catch { ret = false; UnityLibs.Debuger.Log(“send message error”); } return ret;} private void sendCallback(IAsyncResult async){ try { //结束挂起的异步发送 SocketError errorCode; Socket client = (Socket)async.AsyncState; int dwSendSize = client.EndSend(async,out errorCode); if (dwSendSize == 0) { CloseSocket(true); } //UnityLibs.Debuger.Log(&quot;send size :&quot; + dwSendSize.ToString()); } catch (Exception e) { CloseSocket(true); }} 心跳检测 //心跳包private void timerHandler(object state){ if (m_SocketState == enSocketState.SocketState_Connected) { SendData(SocketModule.MDM_KN_COMMAND, SocketModule.SUB_KN_DETECT_SOCKET); if (m_pClientSocketDelegate != null) { m_pClientSocketDelegate.OnSocketDetect(this); } }} 在ClientSocket的变量定义中有一个： //连接回调protected IClientSocketDelegate m_pClientSocketDelegate; 通过这个变量将消息传递出去 public class ClientSocketHelper : Singleton, IClientSocketDelegate ClientSocketHelper 实现这个接口，并接收来自ClientSocket的消息 public bool OnSocketConnect(int iErrorCode, string pszErrorDesc, IClientSocket pIClientSocket){ if (iErrorCode != 0) { –ConnectTimes; if (ConnectTimes &gt; 0) { //再次连接 ConnectServer(); return false; } else { _connectTimes = SocketModule.CONNECT_MAX_TIMES; } } if (onSocketConnect != null) { return onSocketConnect(iErrorCode, pszErrorDesc); } return false;} public bool OnSocketRead(CMD_Command Command, byte[] pBuffer, short wDataSize, IClientSocket pIClientSocket){ if (onSocketRead != null) { return onSocketRead(Command, pBuffer, wDataSize); } return false;} public bool OnSocketClose(IClientSocket pIClientSocke, bool bCloseByServer){ if (onSocketClose != null) { return onSocketClose(); } return false;} public bool OnSocketDetect(IClientSocket pIClientSocke){ if (IsScheduleClose) { _scheduleTime++; //UnityLibs.Debuger.Log(“OnSocketDetect:” + _scheduleTime); if (_scheduleTime * SocketModule.SOCKET_DETECT &gt;= SocketModule.CONNECT_ACTIVE_BACKGROUND) { CloseSocket(); } } return true;} 应用层又是如果接收到最终的数据呢，通过代理的方式 public delegate bool OnSocketConnectEvent(int iErrorCode, string pszErrorDesc);public delegate bool OnSocketReadEvent(CMD_Command Command, byte[] pBuffer, short wDataSize);public delegate bool OnSocketCloseEvent();public delegate bool OnSocketErrorEvent(object data); 示例 public class HandlerObservable : Observable { public event OnSocketConnectEvent onSocketConnect; public event OnSocketCloseEvent onSocketClose; public event OnSocketErrorEvent onSocketError;…………………………………………………public void OnInit(string addr, short port) { if (_isInit == false) { ClientSocketHelper.Instance.ServerAddr = addr; ClientSocketHelper.Instance.ServerPort = port; ClientSocketHelper.Instance.onSocketConnect += OnSocketConnect; ClientSocketHelper.Instance.onSocketRead += OnSocketRead; ClientSocketHelper.Instance.onSocketClose += OnSocketClose; _isInit = true; } }因为在消息的传递过程中，是在自定义的线程中（接收线程）处理的，需要将消息传送到主线程中，方便Unity的调用。和HTTP封装类类似，需要在Update中将消息分发到具体的处理类中。 具体参考HTTP客户端的实现。 因为涉及的内容比较多，就定这些吧，使用Socket通信需要注意的有： 1.网络连接重试，可能第一次未连接上，需要多试几次; 2.断线重连处理，移动应用网络不稳定，网络断线重连对用户透明； 3.应用退到后台，iOS会自动断开，Android不会，所以加逻辑断开； 4.IPV6的支持，曾因这个被拒了两次。 下一篇介绍服务端的实现","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发之网络一HTTP服务端实现","slug":"u3d/e6-9c-8d-e5-8a-a1-e7-ab","date":"2018-06-22T13:10:01.000Z","updated":"2019-11-08T09:59:31.014Z","comments":true,"path":"2018/06/22/u3d/e6-9c-8d-e5-8a-a1-e7-ab/","link":"","permalink":"http://blog.le-more.com/2018/06/22/u3d/e6-9c-8d-e5-8a-a1-e7-ab/","excerpt":"","text":"在前一篇介绍Http客户端的实现方式：Unity开发网络一HTTP客户端实现，下面介绍服务端 1.使用VS创建Web项目 2.添加Handler.ashx Handler.ashx.cs实现 /// /// Summary description for Handler/// public class Handler : IHttpHandler{ //常量 //应用配置信息 public const string COMMAND_APP_INFO = “app_info”; //服务器地址列表 public const string COMMAND_SERVER_LIST = “server_list”; #region 属性 //协议标识 private string _cmd; //应用Id private string _appId; //设备Id private string _deviceId; //客户端版本 private string _appVer; public bool IsReusable { get { return false; } } #endregion public void ProcessRequest(HttpContext context) { if (DNTRequest.IsPost()) { string data = DNTRequest.GetFormString(&quot;data&quot;); if (data.Length == 0) return; //解析数据 Dictionary&lt;string, string&gt; dict = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(data); if (dict.Count == 0) return; if (!dict.TryGetValue(&quot;cmd&quot;, out _cmd)) return; if (!dict.TryGetValue(&quot;app\\_id&quot;, out \\_appId)) return; if (!dict.TryGetValue(&quot;device\\_id&quot;, out \\_deviceId)) return; if (!dict.TryGetValue(&quot;app\\_ver&quot;, out \\_appVer)) return; switch (_cmd) { case COMMAND\\_SERVER\\_LIST: _serverList(); break; default: break; } } else { _write(true, &quot;&quot;); } } private void _serverList() { string jsonString = &quot;{&quot;; //temp if (_appVer == &quot;2.0.250&quot;) { jsonString += &quot;\\\\&quot;ip\\\\&quot;:\\\\&quot;192.168.20.131\\\\&quot;,&quot;; jsonString += &quot;\\\\&quot;port\\\\&quot;:9020,&quot;; } else { jsonString += &quot;\\\\&quot;ip\\\\&quot;:\\\\&quot;192.168.20.131\\\\&quot;,&quot;; jsonString += &quot;\\\\&quot;port\\\\&quot;:9010,&quot;; } jsonString = jsonString.TrimEnd(&apos;,&apos;); jsonString += &quot;}&quot;; _write(true, jsonString); } #region 内部函数 private void _write(bool result, string data) { string jsonString = &quot;{&quot;; jsonString += &quot;\\\\&quot;&quot; + &quot;result&quot; + &quot;\\\\&quot;:\\\\&quot;&quot; + string.Format(&quot;{0}&quot;, result) + &quot;\\\\&quot;,&quot;; jsonString += &quot;\\\\&quot;&quot; + &quot;time&quot; + &quot;\\\\&quot;:\\\\&quot;&quot; + string.Format(&quot;{0}&quot;, DateTime.Now.Millisecond) + &quot;\\\\&quot;,&quot;; jsonString += &quot;\\\\&quot;&quot; + &quot;data&quot; + &quot;\\\\&quot;:&quot; + data + &quot;,&quot;; jsonString = jsonString.TrimEnd(&apos;,&apos;); jsonString += &quot;}&quot;; HttpContext.Current.Response.ContentType = &quot;text/json&quot;; HttpContext.Current.Response.Cache.SetNoStore(); HttpContext.Current.Response.Write(jsonString); HttpContext.Current.Response.End(); } #endregion} 说明： 1.ProcessRequest接收到客户端请求； 2.处理请求分POST和其他方式，暂时只处理POST； 3.读取数据使用DNTRequest.GetFormString(“data”) 从Form中读取； 4.客户端的ContentType 必须设置为”application/x-www-form-urlencoded”才能读取到，否则需要读取输入流； 5.返回的数据用Json格式。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发之网络一HTTP客户端实现","slug":"u3d/unity-e5-bc-80-e5-8f-91-e12","date":"2018-06-22T12:51:32.000Z","updated":"2019-11-08T09:59:31.019Z","comments":true,"path":"2018/06/22/u3d/unity-e5-bc-80-e5-8f-91-e12/","link":"","permalink":"http://blog.le-more.com/2018/06/22/u3d/unity-e5-bc-80-e5-8f-91-e12/","excerpt":"","text":"客户端实现参考：Unity发送HTTP请求和文件下载 注意：仅通过WebRequest实现POST方式，通过测试 Http请求主要涉及两个类：HttpRequest，HttpResponse，在参考的实现基础上有改动 HttpRequest /// /// Http请求/// public class HttpRequest{ /// /// 错误代码 /// public const int ERR_EXCEPTION = -1; #region 属性 private string _url; private int _timeout; private Action&lt;HttpResponse&gt; _callback; private HttpWebRequest _request; private string _method; private string _contentType; private KeyValuePair&lt;string, int&gt; _proxy; protected int _range = -1; // post内容 private StringBuilder _postBuilder; #region get/set /// &lt;summary&gt; /// 设置ContentType /// &lt;/summary&gt; /// &lt;value&gt;ContentType value&lt;/value&gt; public string ContentType { set { _contentType = value; } } #endregion #endregion /// &lt;summary&gt; /// 构造函数, 构造GET请求 /// &lt;/summary&gt; /// &lt;param name=&quot;url&quot;&gt;url地址&lt;/param&gt; /// &lt;param name=&quot;timeout&quot;&gt;超时时间&lt;/param&gt; /// &lt;param name=&quot;callback&quot;&gt;回调函数&lt;/param&gt; public HttpRequest(string url, string method, int timeout, Action&lt;HttpResponse&gt; callback) { _url = url; _timeout = timeout; _callback = callback; _method = method.ToUpper(); } /// &lt;summary&gt; /// 设置Post内容 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;内容&lt;/param&gt; public void SetPostData(string data) { if (_postBuilder == null) { _postBuilder = new StringBuilder(data.Length); } if (_postBuilder.Length &gt; 0) { _postBuilder.Append(&quot;&amp;&quot;); } _postBuilder.Append(data); } /// &lt;summary&gt; /// 添加Post内容 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;key值&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;value值&lt;/param&gt; public void AddPostData(string key, string value) { if (_postBuilder == null) { _postBuilder = new StringBuilder(); } if (_postBuilder.Length &gt; 0) { _postBuilder.Append(&quot;&amp;&quot;); } _postBuilder.Append(key).Append(&quot;=&quot;).Append(UrlEncode(value)); } /// &lt;summary&gt; /// 设置代理 /// &lt;/summary&gt; /// &lt;param name=&quot;ip&quot;&gt;ip地址&lt;/param&gt; /// &lt;param name=&quot;port&quot;&gt;端口号&lt;/param&gt; public void SetProxy(string ip, int port) { _proxy = new KeyValuePair&lt;string, int&gt;(ip, port); } /// &lt;summary&gt; /// 发动请求 /// &lt;/summary&gt; public void Start() { //Debug.Log(&quot;Handle Http Request Start&quot;); \\_request = WebRequest.Create(\\_url) as HttpWebRequest; \\_request.Timeout = \\_timeout; \\_request.Method = \\_method; _request.Accept = &quot;text/plain&quot;; if (_proxy.Key != null) { \\_request.Proxy = new WebProxy(\\_proxy.Key, _proxy.Value); } if (_contentType != null) { \\_request.ContentType = \\_contentType; } if (_range != -1) { \\_request.AddRange(\\_range); } try { if (_method.Equals(&quot;POST&quot;)) { WritePostData(); } AsyncCallback callback = new AsyncCallback(OnResponse); _request.BeginGetResponse(callback, null); } catch (Exception e) { CallBack(ERR_EXCEPTION, e.Message); if (_request != null) { _request.Abort(); } } } /// &lt;summary&gt; /// 处理读取Response /// &lt;/summary&gt; /// &lt;param name=&quot;result&quot;&gt;异步回到result&lt;/param&gt; protected void OnResponse(IAsyncResult result) { //Debug.Log (&quot;Handle Http Response&quot;); HttpWebResponse response = null; try { // 获取Response response = _request.EndGetResponse(result) as HttpWebResponse; if (response.StatusCode == HttpStatusCode.OK) { if (&quot;HEAD&quot;.Equals(_method)) { // HEAD请求 long contentLength = response.ContentLength; CallBack((int)response.StatusCode, contentLength + &quot;&quot;); return; } // 读取请求内容 string content = string.Empty; Stream stream = response.GetResponseStream(); StreamReader streamReader = new StreamReader(stream, System.Text.Encoding.UTF8); content = streamReader.ReadToEnd(); streamReader.Close(); response.Close(); _request.Abort(); // 调用回调 CallBack((int)response.StatusCode, content); } else { CallBack((int)response.StatusCode, &quot;&quot;); } } catch (Exception e) { CallBack(ERR_EXCEPTION, e.Message); if (_request != null) { _request.Abort(); } if (response != null) { response.Close(); } } } private void CallBack(int code, string content) { if (_callback != null) { HttpResponse response = new HttpResponse(); response.StatusCode = code; if (code == (int)HttpStatusCode.OK) { response.Content = content; } else { response.Error = content; } _callback(response); } } /// &lt;summary&gt; /// 写Post内容 /// &lt;/summary&gt; private void WritePostData() { if (null == \\_postBuilder || \\_postBuilder.Length &lt;= 0) { return; } byte\\[\\] bytes = Encoding.UTF8.GetBytes(_postBuilder.ToString()); _request.ContentLength = bytes.Length; _request.GetRequestStream().Write(bytes, 0, bytes.Length); } /// &lt;summary&gt; /// URLEncode /// &lt;/summary&gt; /// &lt;returns&gt;encode value&lt;/returns&gt; /// &lt;param name=&quot;value&quot;&gt;要encode的值&lt;/param&gt; private string UrlEncode(string value) { StringBuilder sb = new StringBuilder(); byte\\[\\] byStr = System.Text.Encoding.UTF8.GetBytes(value); for (int i = 0; i &lt; byStr.Length; i++) { sb.Append(@&quot;%&quot; + Convert.ToString(byStr\\[i\\], 16)); } return (sb.ToString()); }} HttpResponse /// /// HTTP返回内容/// public class HttpResponse{ #region 属性 // 状态码 private int _statusCode; // 响应字节 private string _content; // 错误内容 private string _error; #region get/set /// &lt;summary&gt; /// 获取状态码 /// &lt;/summary&gt; /// &lt;value&gt;状态码&lt;/value&gt; public int StatusCode { set { this._statusCode = value; } get { return this._statusCode; } } /// &lt;summary&gt; /// 获取错误消息 /// &lt;/summary&gt; /// &lt;value&gt;错误消息&lt;/value&gt; public string Error { set { this._error = value; } get { return this._error; } } public string Content { get { return _content; } set { _content = value; } } #endregion #endregion /// &lt;summary&gt; /// 默认构造函数 /// &lt;/summary&gt; public HttpResponse() { }} 在两个类的基础上，封装HttpHelper方便应用中使用 public class HttpHelper : Singleton{ //常量 //应用配置信息 public const string COMMAND_APP_INFO = “app_info”; //服务器地址列表 public const string COMMAND_SERVER_LIST = “server_list”; #region 属性 //基本数据 private Dictionary&lt;string, string&gt; _baseData; private Dictionary&lt;Action&lt;bool, object&gt;, HttpResponse&gt; _responseDict; #region get/set public Dictionary&lt;string, string&gt; BaseData { get { return _baseData; } set { _baseData = value; } } #endregion #endregion public HttpHelper() { _responseDict = new Dictionary&lt;Action&lt;bool, object&gt;, HttpResponse&gt;(); _baseData = new Dictionary&lt;string, string&gt;(); \\_baseData.Add(&quot;app\\_id&quot;, Global.GlobalDef.AppId); \\_baseData.Add(&quot;app\\_ver&quot;, Global.GlobalDef.AppVer); \\_baseData.Add(&quot;device\\_id&quot;, Global.GlobalDef.DeviceId); } //消息分发:主线程 public void Update(float dt) { if (_responseDict.Count &gt; 0) { foreach (var item in _responseDict) { Action&lt;bool, object&gt; callback = item.Key; HttpResponse response = item.Value; try { bool result = false; string content = response.Error; if (response.StatusCode == (int)System.Net.HttpStatusCode.OK) { result = true; content = response.Content; if (callback != null) { JsonData jsonResult = JsonMapper.ToObject(content); callback(result, jsonResult\\[&quot;data&quot;\\]); } } else { callback(result, content); } } catch (Exception e) { UnityLibs.Debuger.Log(e.ToString()); } } _responseDict.Clear(); } } #region 应用信息 public void AppInfo(Action&lt;bool,object&gt; callback) { LitJson.JsonData jsonData = new LitJson.JsonData(); jsonData\\[&quot;cmd&quot;\\] = COMMAND\\_APP\\_INFO; foreach (var item in _baseData) { jsonData\\[item.Key\\] = item.Value; } string jsonStr = LitJson.JsonMapper.ToJson(jsonData); string url = Global.GlobalDef.HostAddr; _onRequest(url, jsonStr, delegate (HttpResponse response) { _responseDict.Add(callback, response); }); } #endregion #region 服务器列表 public void ServerList(Action&lt;bool, object&gt; callback) { LitJson.JsonData jsonData = new LitJson.JsonData(); jsonData\\[&quot;cmd&quot;\\] = COMMAND\\_SERVER\\_LIST; foreach (var item in _baseData) { jsonData\\[item.Key\\] = item.Value; } string jsonStr = LitJson.JsonMapper.ToJson(jsonData); string url = Global.GlobalDef.HostAddr; _onRequest(url, jsonStr, delegate (HttpResponse response) { _responseDict.Add(callback, response); }); } #endregion #region 内部函数 private void _onRequest(string url, string data, Action&lt;HttpResponse&gt; callback) { HttpRequest client = new HttpRequest(url, &quot;POST&quot;, 30 * 1000, callback); client.ContentType = &quot;application/x-www-form-urlencoded&quot;; client.AddPostData(&quot;data&quot;, data); client.Start(); } #endregion} 调用示例: HttpHelper.Instance.ServerList(delegate(bool result,object obj){ if (result) { LitJson.JsonData jsonData = obj as LitJson.JsonData; string serverAddr = jsonData[“ip”].ToString(); int port = int.Parse(jsonData[“port”].ToString()); HandlerObservable.Instance.OnInit(serverAddr, (short)port); } else { HandlerObservable.Instance.OnInit(GlobalDef.SERVER_ADDR, GlobalDef.SERVER_PORT); } //Logo展示完后加载 StartCoroutine(\\_startLoading(\\_loadingTime));}); 说明： 1.ContentType 设置为application/x-www-form-urlencoded，在服务实现部分会说明 2.数据使用Json格式编码; 3.Http响应回调是在单独的线程中，为了调用方式需要将回调在主线程完成（Update的作用）。 4.HttpHelper的Update方法需要在游戏中不会被销毁的继承MonoBehaviour的类每帧调用： private void Update(){ HttpHelper.Instance.Update(UnityEngine.Time.deltaTime);} 下一篇介绍服务端实现","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发源码的加解密二一打包自动加密","slug":"u3d/unity-e5-bc-80-e5-8f-91-e10","date":"2018-06-08T13:29:18.000Z","updated":"2019-11-08T09:59:31.018Z","comments":true,"path":"2018/06/08/u3d/unity-e5-bc-80-e5-8f-91-e10/","link":"","permalink":"http://blog.le-more.com/2018/06/08/u3d/unity-e5-bc-80-e5-8f-91-e10/","excerpt":"","text":"在前一篇Unity开发源码的加解密 涉及的内容比较多，最终得到了加密后的Assembly-CSharp.dll和解密libmono.so。如何能在打包的时候自动处理呢？下面介绍一种方式。 [PostProcessBuild]标签：Add this attribute to a method to get a notification just after building the player. 作用就是获取打包后通知，执行添加后的方法. 处理函数如下： [PostProcessBuild]public static void OnPostprocessBuild (BuildTarget target, string pathToBuiltProject){ if (target == BuildTarget.Android) { OnPostprocessBuildAndroid(pathToBuiltProject); } else if (target == BuildTarget.iOS) { OnPostprocessBuildIOS(pathToBuiltProject); }} 看一下iOS具体的处理，可以添加引用库，修改info.plist等，在Build iOS项目的时生成xCode工程时会自动处理，方便iOS打包 private static void OnPostprocessBuildIOS(string pathToBuiltProject) {#if UNITY_EDITOR_OSX PBXProject project = new PBXProject(); string configFilePath = PBXProject.GetPBXProjectPath(pathToBuiltProject); project.ReadFromFile(configFilePath); string targetGuid = project.TargetGuidByName(&quot;Unity-iPhone&quot;); string debug = project.BuildConfigByName(targetGuid, &quot;Debug&quot;); string release = project.BuildConfigByName(targetGuid, &quot;Release&quot;); project.AddBuildPropertyForConfig(debug, &quot;CODE\\_SIGN\\_RESOURCE\\_RULES\\_PATH&quot;, &quot;$(SDKROOT)/ResourceRules.plist&quot;); project.AddBuildPropertyForConfig(release, &quot;CODE\\_SIGN\\_RESOURCE\\_RULES\\_PATH&quot;, &quot;$(SDKROOT)/ResourceRules.plist&quot;); project.AddFrameworkToProject(targetGuid, &quot;GLKit.framework&quot;, true); project.SetBuildProperty(targetGuid, &quot;ENABLE_BITCODE&quot;, &quot;NO&quot;); project.WriteToFile(configFilePath); //plist string plistPath = pathToBuiltProject + &quot;/Info.plist&quot;; PlistDocument plist = new PlistDocument(); plist.ReadFromString(File.ReadAllText(plistPath)); // Get root PlistElementDict rootDict = plist.root; /\\* ipad 关闭分屏 */ rootDict.SetBoolean(&quot;UIRequiresFullScreen&quot;, true); rootDict.SetString(&quot;CFBundleShortVersionString&quot;, App.Global.GlobalDef.BundleVer); /\\* 设置Build值 */ var now = System.DateTime.Now; string time = string.Format(&quot;{0}{1:D2}{2:D2}{3:D2}{4:D2}&quot;, now.Year, now.Month, now.Day, now.Hour, now.Minute); rootDict.SetString(&quot;CFBundleVersion&quot;, string.Format(&quot;{0}.{1}&quot;, App.Global.GlobalDef.BundleVer, time)); /\\* iOS9所有的app对外http协议默认要求改成https */ // Add value of NSAppTransportSecurity in Xcode plist var atsKey = &quot;NSAppTransportSecurity&quot;; PlistElementDict dictTmp = rootDict.CreateDict(atsKey); dictTmp.SetBoolean(&quot;NSAllowsArbitraryLoads&quot;, true); // location native development region //rootDict.SetString(&quot;CFBundleDevelopmentRegion&quot;, &quot;zh_CN&quot;); /\\* for share sdk */ rootDict.SetString(&quot;NSPhotoLibraryUsageDescription&quot;, &quot;AR拍照保存与分享&quot;); rootDict.SetString(&quot;NSPhotoLibraryAddUsageDescription&quot;, &quot;AR拍照保存与分享&quot;); /\\* 地图定位 */ rootDict.SetString(&quot;NSLocationWhenInUseUsageDescription&quot; , &quot;您的位置和方向信息用于乐园中导航,实现虚拟乐园和真实乐园的对应&quot;); /\\* ITSAppUsesNonExemptEncryption 合规证明，未使用加密 */ rootDict.SetBoolean(&quot;ITSAppUsesNonExemptEncryption&quot;, false); File.WriteAllText(plistPath, plist.WriteToString()); AdapteiPhoneXCode(pathToBuiltProject);#endif } 类似的，Build Android项目时，处理如下： private static void OnPostprocessBuildAndroid(string pathToBuiltProject){ string exportedPath = Path.Combine(pathToBuiltProject, PlayerSettings.productName); //加密 string\\[\\] filesToCrypt = new\\[\\] { &quot;Assembly-CSharp.dll&quot;}; for (int i = 0; i &lt; filesToCrypt.Length; i++) { string fileName = filesToCrypt\\[i\\]; string filePath = UnityLibs.Common.FileUtils.SearchFile(exportedPath, fileName); if (!string.IsNullOrEmpty(filePath)) { UnityLibs.DEncrypt.DEncrypt.EncryptFile(filePath, &quot;&quot;, App.Global.GlobalDef.DEncrypt\\_Data\\_Key + &quot;~&quot;); } } //替换 string\\[\\] srcToReplace = new\\[\\] { &quot;../Client/Publish/libmono.so&quot; }; string\\[\\] desToReplace = new\\[\\] { &quot;libmono.so&quot; }; for (int i = 0; i &lt; desToReplace.Length; i++) { string destName = desToReplace\\[i\\]; string destPath = UnityLibs.Common.FileUtils.SearchFile(exportedPath, destName); if (!string.IsNullOrEmpty(destPath)) { //delete UnityLibs.Common.FileUtils.DeleteFile(destPath); //copy string src = srcToReplace\\[i\\]; string srcFull = Path.GetFullPath(src); UnityLibs.Common.FileUtils.CopyFile(srcFull, destPath, true); } }} 说明： 1.需要实现互通的加解密方式：C#加密，C解密； 2.文件仅做了加密，未做混淆处理； 先简单实现，后优化提高！","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发源码的加解密一mono.dll和libmono.so编译","slug":"u3d/unity-e5-bc-80-e5-8f-91-e9","date":"2018-06-07T13:02:14.000Z","updated":"2019-11-08T09:59:31.024Z","comments":true,"path":"2018/06/07/u3d/unity-e5-bc-80-e5-8f-91-e9/","link":"","permalink":"http://blog.le-more.com/2018/06/07/u3d/unity-e5-bc-80-e5-8f-91-e9/","excerpt":"","text":"源码的加密，只是加了一层防护，不是绝对的安全，参考网络大部份类似的实现方式： 混淆自定义库 加解密Assembly-CSharp.dll 自动化工具集成 一、使用各种加密方法制作C++动态库DEncrypt.dll加密方法,使用xxtea示例 DLL_INTERFACE_API void Encrypt(const char * key, const char * fileName, const char* fileSuffix){ //带后缀的文件名 char fileNameExt[64] = { 0 }; //没有后缀的文件名 char name[64] = { 0 }; //文件后缀 char fileExt[8] = { 0 }; //路径名，不含有文件名 char filePath[512] = { 0 }; const char*pFind = nullptr; strcpy(fileNameExt, (pFind = strrchr(fileName, ‘\\&#39;)) ? pFind + 1 : fileName); strncpy(filePath, fileName, strlen(fileName) - strlen(fileNameExt)); pFind = nullptr; strcpy(fileExt, (pFind = strrchr(fileNameExt, &apos;.&apos;)) ? pFind : fileNameExt); strncpy(name, fileNameExt, strlen(fileNameExt) - strlen(fileExt)); //判断命令行是否正确 FILE *infp = 0; if ((infp = fopen(fileName, &quot;rb&quot;)) == NULL) { //打开操作不成功 printf(&quot;%s Read Error \\\\n&quot;, fileNameExt); //结束程序的执行 return; } char* buffer = (char*)malloc(sizeof(char)*SIZE); memset(buffer, 0, sizeof(char)*SIZE); int rc = 0; int total_len = 0; total_len = fread(buffer, sizeof(unsigned char), SIZE, infp); printf(&quot;Read %s Successfully and total\\_len : %d \\\\n&quot;, fileNameExt, total\\_len); //加密DLL size_t len; char \\*encrypt\\_data = (char\\*)xxtea\\_encrypt(buffer, total_len, key, &amp;len); printf(&quot;Encrypt %s Successfully and len : %d \\\\n&quot;, fileNameExt, len); //写Dll strcat(name, fileSuffix); strcat(name, fileExt); strcat(filePath, name); FILE* outfp = 0; if ((outfp = fopen(filePath, &quot;wb+&quot;)) == NULL) { //打开操作不成功 printf(&quot;%s Read Error \\\\n&quot;, fileNameExt); //结束程序的执行 return; } int rstCount = fwrite(encrypt_data, sizeof(unsigned char), len, outfp); fflush(outfp); printf(&quot;Write len : %d \\\\n&quot;, rstCount); fclose(infp); fclose(outfp); free(buffer); free(encrypt_data);} 解密方法 //解密//fileName:路径+文件名DLL_INTERFACE_API void Decrypt(const char * key, const char * fileName, const char* fileSuffix){ //带后缀的文件名 char fileNameExt[64] = { 0 }; //没有后缀的文件名 char name[64] = { 0 }; //文件后缀 char fileExt[8] = { 0 }; //路径名，不含有文件名 char filePath[512] = { 0 }; const char*pFind = nullptr; strcpy(fileNameExt, (pFind = strrchr(fileName, ‘\\&#39;)) ? pFind + 1 : fileName); strncpy(filePath, fileName, strlen(fileName) - strlen(fileNameExt)); pFind = nullptr; strcpy(fileExt, (pFind = strrchr(fileNameExt, &apos;.&apos;)) ? pFind : fileNameExt); strncpy(name, fileNameExt, strlen(fileNameExt) - strlen(fileExt)); //判断命令行是否正确 FILE *infp = 0; if ((infp = fopen(fileName, &quot;rb&quot;)) == NULL) { //打开操作不成功 printf(&quot;%s Read Error \\\\n&quot;, fileNameExt); //结束程序的执行 return; } char* buffer = (char*)malloc(sizeof(char)*SIZE); memset(buffer, 0, sizeof(char)*SIZE); int rc = 0; int total_len = 0; total_len = fread(buffer, sizeof(unsigned char), SIZE, infp); printf(&quot;Read File %s Successfully and total\\_len : %d \\\\n&quot;, fileNameExt, total\\_len); //解密DLL size_t len; char \\*decrypt\\_data = (char\\*)xxtea\\_decrypt(buffer, total_len, key, &amp;len); printf(&quot;Decrypt %s Successfully and len : %d \\\\n&quot;, fileNameExt, len); //写Dll //去除_encrypt char newName\\[64\\] = { 0 }; pFind = nullptr; if (pFind = strstr(name, fileSuffix)) strncpy(newName, name, strlen(name) - strlen(fileSuffix)); //全路径 strcat(newName, fileExt); strcat(filePath, newName); FILE* outfp = 0; if ((outfp = fopen(filePath, &quot;wb+&quot;)) == NULL) { //打开操作不成功 printf(&quot;%s Read Error \\\\n&quot;, fileNameExt); //结束程序的执行 return; } int rstCount = fwrite(decrypt_data, sizeof(unsigned char), len, outfp); fflush(outfp); printf(&quot;Write len : %d \\\\n&quot;, rstCount); fclose(infp); fclose(outfp); free(buffer); free(decrypt_data);} 检查导出的方法 dumpbin -exports DEncrypt.dll 除了xxtea，也可以使用des,aes等对称加密方式 参考：C++动态库制作 二、使用C#调用DEncrypt.dll加密Assembly-CSharp.dllC#代码引用DLL [DllImport(“DEncrypt.dll”, CallingConvention = CallingConvention.Cdecl)]public static extern void Encrypt(string key, string fileName, string fileSuffix); [DllImport(“DEncrypt.dll”, CallingConvention = CallingConvention.Cdecl)]public static extern void Decrypt(string key, string fileName, string fileSuffix); 调用，会在dll文件目录生成带指定后缀的加密后文件，如果后缀为空，替换文件 private void btnDEcryptDLL_Click(object sender, EventArgs e){ //加密 Encrypt(txtDEncryptKey.Text.Trim(), txtDEcryptDLL.Text.Trim(), txtEncryptSuffix.Text.Trim()); System.Windows.Forms.MessageBox.Show(“加密成功！”);} 三、编译mono.dll1.下载mono 对应版本(当前项目是uniyt 5.5) 2.修改mono_image_open_from_data_with_name方法，添加解密代码,在加密的时候加个前缀，如果存在就解不存在不执行 if (!data || !data_len) { if (status) status = MONO_IMAGE_IMAGE_INVALID; return NULL;}……………….添加开始//maxx-m if (strstr(name, “Assembly-CSharp.dll”)) { char key = “demo2018”; short size = strlen(key)0.5; if(strncmp(key,data,size) == 0){ size_t len; char decryptData = (char *)DecryptData(key,data+size, data_len-size, &amp;len); int i = 0; for (i = 0; i &lt; len; ++i) { data[i] = decryptData[i]; } g_free(decryptData); data_len = len; } }……………….添加结束 原本计划写个静态库加解密方法写在一个文件中，方便维护（也是第一步制作dll的原因）。因技能能力有限，试了N次静态库链接有问题，遂放弃，将源码复制到mono项目中mono\\metadata\\crypt crypt是创建的目录，将添加的所有源码复制到这个目录，添加到工程中 3.编译mono.dll 需要安装VS2010 编写脚本BuildMono.bat，编译32位和64位dll，执行成功后会在\\builds\\embedruntimes 生成win32和win64位目录，对应着32和64位的mono.dll @set path=C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319;%path% @clsmsbuild.exe “mono-unity-5.5\\msvc\\mono.sln” /p:Configuration=Release_eglib /p:Platform=Win32msbuild.exe “mono-unity-5.5\\msvc\\mono.sln” /p:Configuration=Release_eglib /p:Platform=x64pause; 在打包window项目时，用新的mono.dll替换打包后的XXX_Data\\Mono\\mono.dll文件,windows不是重点，不再描述。 四、编译libmono.so编译libmono.so比较麻烦，Window和macOS都需要配置环境，下面说一下windows 参考 Unity防破解 —— 重新编译mono 1.下载mingw-get-setup.exe 安装到C盘或D盘根目录 在basic 全选安装 2.下载Android NDK,解压到C:\\MinGW\\msys\\1.0\\home\\maxx\\android-ndk_auto-r10e 如果home\\maxx没有，创建即可,注意ndk的目录名称要一致 3.下载zip,解压到C:\\MinGW\\msys\\1.0\\bin 4.修改 mono-unity-5.5\\external\\buildscripts\\PrepareAndroidSDK.pm elsif(lc $^O eq ‘cygwin’) 改成 elsif(lc $^O eq ‘cygwin’ or lc $^O eq ‘msys’) 5.修改 mono-unity-5.5\\external\\buildscripts\\build_runtime_android.shKRAIT_PATCH_PATH=”${CWD}/../../android_krait_signal_handler/build”改成KRAIT_PATCH_PATH=”${CWD}/external/buildscripts/android_krait_signal_handler/build” 将android_krait_signal_handler下载到当前目录 6.修改 mono-unity-5.5\\external\\buildscripts\\build_runtime_android.sh -g 改成 -O2 注释#clean_build “$CCFLAGS_ARMv5_CPU” “$LDFLAGS_ARMv5” “$OUTDIR/armv5”#clean_build “$CCFLAGS_ARMv6_VFP” “$LDFLAGS_ARMv5” “$OUTDIR/armv6_vfp” 添加$ANDROID_NDK_ROOT/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-strip.exe libmono.so 7.修改 mono-unity-5.5\\external\\buildscripts\\build_runtime_android_x86.sh -g 改成 -O2 添加$ANDROID_NDK_ROOT/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-strip.exe libmono.so 8.执行 打开MinGW\\msys\\1.0\\msys.batcd到mono-unity-5.5目录; 执行./external/buildscripts/build_runtime_android.sh 执行会失败，但会下载文件mono-unity-5.5\\external\\buildscripts\\android_krait_signal_handler 9.修改 mono-unity-5.5\\external\\buildscripts\\android_krait_signal_handler\\build\\PrepareAndroidSDK.pmelsif(lc $^O eq ‘cygwin’)改成elsif(lc $^O eq ‘cygwin’ or lc $^O eq ‘msys’) 10.修改 mono-unity-5.5\\external\\buildscripts\\android_krait_signal_handler\\build\\build.pl注释#PrepareAndroidSDK::GetAndroidSDK(undef, undef, “r13b”); 改第一行成这个，不知道什么意思#!/usr/bin/perl -w 11.修改 mono-unity-5.5\\external\\buildscripts\\android_krait_signal_handler\\build\\jni\\Application.mk 注释#NDK_TOOLCHAIN_VERSION := clang 12.再次执行./external/buildscripts/build_runtime_android.sh，成功后会在mono-unity-5.5\\builds\\embedruntimes\\android 生成armv7a和x86两个文件夹 五.替换libmono.so和加密后的Assembly-CSharp.dll 下一篇会介绍Unity开发源码的加解密二","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之设计模式---状态模式","slug":"u3d/e8-ae-be-e8-ae-a1-e6-a8","date":"2018-05-21T13:10:20.000Z","updated":"2019-11-08T09:59:31.015Z","comments":true,"path":"2018/05/21/u3d/e8-ae-be-e8-ae-a1-e6-a8/","link":"","permalink":"http://blog.le-more.com/2018/05/21/u3d/e8-ae-be-e8-ae-a1-e6-a8/","excerpt":"","text":"曾记录一篇关于设计模式的日志：《Head First 设计模式》——学习总结,在那篇文章中只是记录一些重要的概念，缺乏实战，也不好理解。下面记录在项目中使用到的设计模式，理论和实际相结合才有价值，“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”。 在回合制模式的战斗游戏中，为了很好控制角色的行为，使用有限状态机会容易的多。 quick-lua版本中提供有限状态机实现，是从js移植过来，很容易使用（时间有点久可能记错了），js版本 在C#使用状态机的问题就是类比较多。状态机的实现方式也有很多种，我选择其中一种来实现，一个子状态接口和状态机类，代码来源与网络 public abstract class IState { public abstract void Enter(Entity subject,object data = null); public abstract void Exit(Entity subject); public abstract void Update(Entity subject); } public class StateMachine{ private IState _currentState; private IState _previousState; private IState _globalState; private Entity _Subject; public IState&lt;Entity&gt; CurrentState { get { return _currentState; } set { _currentState = value; } } public IState&lt;Entity&gt; PreviousState { get { return _previousState; } set { _previousState = value; } } public IState&lt;Entity&gt; GlobalState { get { return _globalState; } set { _globalState = value; } } // constructor public StateMachine(Entity subject) { this._Subject = subject; } public void ChangeState(IState&lt;Entity&gt; newState,object data = null) { //handle input if (newState != null) { PreviousState = CurrentState; if (CurrentState != null) { CurrentState.Exit(_Subject); } CurrentState = newState; CurrentState.Enter(_Subject, data); } } public void Update() { if (GlobalState != null) { GlobalState.Update(_Subject); } if (CurrentState != null) { CurrentState.Update(_Subject); } }} 项目中的需求说明，对战有两方，两方各有几个队员。从战斗开始到结束都是自动运行。 把队员的完整的过程分解为攻击-走/跑-攻击结束，三个状态。因为攻击有近身和远程，可将攻击分为近身攻击和远程攻击状态，走/跑是在近身攻击时才有的状态分为前进和后退两个状态。 全部的状态有： 空闲(Idle) 近身攻击/远程攻击(AttackClose/AttackRemote)= 前进/回退(RunTo/RunBack) 受击(Hit) 死亡(Dead) 胜利(Win) 复活(Relive) 防御(Defense) 停止(Stop) 灰色状态在这个项目中未实现，列出来只是为了后面扩展使用，使用举例： //状态机private StateMachine _fsm; //开始public void OnIdle(){ _fsm.ChangeState(ActorState.Idle);} public class Idle : IState{ public override void Enter(ActorModel subject, object data) { CustomEvent customEvent = new CustomEvent(ActorModel.ACTOR_START_EVENT); subject.EventDispatcher.dispatchEvent(customEvent); } public override void Exit(ActorModel subject) { } public override void Update(ActorModel subject) { }} 在Idle状态进入时发送消息给订阅者 其他状态的和Idle都是类似的实现，不同的是发送消息时也可以传参数，由订阅者处理。 最终实现的效果： [video width=”180” height=”298” mp4=”http://www.le-more.com/wp-content/uploads/2018/05/patten-state.mp4&quot;\\]\\[/video\\]","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"pattern","slug":"pattern","permalink":"http://blog.le-more.com/tags/pattern/"}]},{"title":"Unity开发之设计模式---观察者模式","slug":"u3d/a1-e5-bc-8f-e4-b9-8b","date":"2018-05-19T13:05:22.000Z","updated":"2019-11-08T09:59:31.008Z","comments":true,"path":"2018/05/19/u3d/a1-e5-bc-8f-e4-b9-8b/","link":"","permalink":"http://blog.le-more.com/2018/05/19/u3d/a1-e5-bc-8f-e4-b9-8b/","excerpt":"","text":"曾记录一篇关于设计模式的日志：《Head First 设计模式》——学习总结,在那篇文章中只是记录一些重要的概念，缺乏实战，也不好理解。下面记录在项目中使用到的设计模式，理论和实际相结合才有价值，“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”。 观察者模式也是比较常见的设计模式，也容易理解。观察者模式的实现方式也有很多种，先列出项目中使用的方式 观察者模式实现方式一Java中的实现 定义订阅者行为接口 public interface IObserver{ void update(Observable obs, Object arg);} 出版者父类，类中包含订阅者对象超类型列表，OO编程原则“针对接口编程，而不是针对实现编程”示例。 public class Observable{ private bool _changed = false; private List _observerList; public bool Changed { get { return _changed; } set { _changed = value; } } public Observable() { _observerList = new List&lt;IObserver&gt;(); } public void addObserver(IObserver item) { _observerList.Add(item); } public void deleteObserver(IObserver item) { _observerList.Remove(item); } public void notifyObservers(Object arg) { if (Changed) { for(int i=0;i&lt; _observerList.Count;++i) { var observer = _observerList\\[i\\]; observer.update(this, arg); } Changed = false; } } protected void setChanged() { Changed = true; }} 使用示例，具体的出版者(网络数据管理分发类)和订阅者(用户消息处理类) public class HandlerObservable : Observable{ …………………….. 未列出函数 //数据分发 public void Update(float dt) { //数据转发 if (ClientSocketHelper.Instance.RecvQueue.Count &gt; 0) { for (int i = 0; i &lt; ClientSocketHelper.Instance.RecvQueue.Count; ++i) { setChanged(); var data = ClientSocketHelper.Instance.RecvQueue.Dequeue(); bool result = _resReconnect(data); if (!result) { notifyObservers(data); } } } }} public class UserHandler : BaseHandler,IObserver{ public UserHandler() { //订阅消息 HandlerObservable.Instance.addObserver(this); } //消息接收 public void update(Observable obs, object arg) { SocketData socketData = arg as SocketData; }} 观察者模式实现EventDispatcher 观察者模式还有其他表现形式，像iOS中的NotificationCenter，cocos2d中的EventDispatcher事件分发组件,下面介绍一下EventDispatcher 因从cocos2d转到unity开发，习惯使用EventDispatcher对程序功能进行分层设计，故找到C#的实现，代码来源于网络。主要包括IEvent,IEventDispatcher,Event,EventDispatcher等接口或类，使用的方式在模块处理中声明： //事件分发 private EventDispatcher _eventDispatcher; 在UI模块中注册 MsgModule.Instance.EventDispatcher.addEventListener(MsgModule.EVENT_GAME_NOTICE, _onGameNoticeEvent); 获取网络消息后推送 CustomEvent customEvent = new CustomEvent(EVENT_GAME_NOTICE);customEvent.Data = GameNotice;EventDispatcher.dispatchEvent(customEvent); 实现应用逻辑层和UI层代码的解耦，减少维护复杂度 C#中的委托与事件 先看一下委托与事件的总结: 委托就是一个类，也可以实例化，通过委托的构造函数来把方法赋值给委托实例 触发委托有2种方式: 委托实例.Invoke(参数列表)，委托实例(参数列表) 事件可以看作是一个委托类型的变量 通过+=为事件注册多个委托实例或多个方法 通过-=为事件注销多个委托实例或多个方法 EventHandler就是一个委托 通过委托定义的事件，也能通过+=或-=订阅或取消订阅事件。 定义委托 public delegate bool OnSocketConnectEvent(int iErrorCode, string pszErrorDesc);public delegate bool OnSocketReadEvent(CMD_Command Command, byte[] pBuffer, short wDataSize);public delegate bool OnSocketCloseEvent();public delegate bool OnSocketErrorEvent(object data); 事件定义 public event OnSocketConnectEvent onSocketConnect;public event OnSocketCloseEvent onSocketClose;public event OnSocketErrorEvent onSocketError; 注册事件和事件处理 //网络异常处理HandlerObservable.Instance.onSocketConnect += OnSocketConnect;HandlerObservable.Instance.onSocketClose += OnSocketClose;HandlerObservable.Instance.onSocketError += OnSocketError; // 网络异常处理 private bool OnSocketConnect(int iErrorCode, string pszErrorDesc) { return false; } private bool OnSocketClose() { return true; } private bool OnSocketError(object data) { return false; }取消事件 HandlerObservable.Instance.onSocketConnect -= OnSocketConnect;HandlerObservable.Instance.onSocketClose -= OnSocketClose;HandlerObservable.Instance.onSocketError -= OnSocketError;","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"pattern","slug":"pattern","permalink":"http://blog.le-more.com/tags/pattern/"}]},{"title":"Unity开发之设计模式---单例模式","slug":"u3d/e8-ae-be-e8-ae-a1-e6-a8-a1","date":"2018-05-18T13:00:48.000Z","updated":"2019-11-08T09:59:31.015Z","comments":true,"path":"2018/05/18/u3d/e8-ae-be-e8-ae-a1-e6-a8-a1/","link":"","permalink":"http://blog.le-more.com/2018/05/18/u3d/e8-ae-be-e8-ae-a1-e6-a8-a1/","excerpt":"","text":"曾记录一篇关于设计模式的日志：《Head First 设计模式》——学习总结,在那篇文章中只是记录一些重要的概念，缺乏实战，也不好理解。下面记录在项目中使用到的设计模式，理论和实际相结合才有价值，“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”。 单例模式是最简单也是用的最多一种模式，概念简单就不再详细说明了 C#中定义单例模式 public class DataManager{ #region Singleton protected static DataManager m_Instance; public static DataManager Instance { get { if (m_Instance == null) { m_Instance = new DataManager(); } return m_Instance; } } #endregion public void OnLoad(){}} //使用示例DataManager.Instance.OnLoad(); 模板定义及示例 /// /// 单例模板类/// /// 类型public class Singleton where T : class, new(){ // // Static Fields // protected static T m_Instance; // // Static Properties // public static T Instance { get { if (m_Instance == null) { m_Instance = new T(); } return m_Instance; } } // // Static Methods // public static T GetInstance() { return Instance; }} public class DataManager :Singleton{ public void OnLoad(){}} //使用示例 DataManager.Instance.OnLoad(); Unity中挂在组件上的单例 public class AppUser : MonoBehaviour{ #region Sington and MonoBehaviour private static AppUser instance; public static AppUser Instance { get { if (instance) { return instance; } else { instance = GameObject.FindObjectOfType(); } if (instance) { return instance; } else { GameObject obj = new GameObject(typeof(AppUser).ToString()); //场景不消除 GameObject.DontDestroyOnLoad(obj); instance = obj.AddComponent&lt;AppUser&gt;(); } return instance; } } void Awake() { instance = this; } private void Update() { } #endregion public void OnStart(){}} //使用示例,场景控制脚本中的Startvoid Start(){ AppUser.Instance.OnStart();} 在场景控制脚本中调用,会创建一个空对象挂载该脚本。并在场景切换后不销毁。 在客户端开发中基本不用考虑线程安全的问题。同时在模块很多的情况下，为了调用方便，单例类使用会很多。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"pattern","slug":"pattern","permalink":"http://blog.le-more.com/tags/pattern/"}]},{"title":"《巴比伦最富有的人》：最古老、最普遍、最有效的七条财富法则","slug":"other/e6-9c-80-e6-99-ae-e9","date":"2018-05-11T06:11:21.000Z","updated":"2019-11-08T09:59:30.994Z","comments":true,"path":"2018/05/11/other/e6-9c-80-e6-99-ae-e9/","link":"","permalink":"http://blog.le-more.com/2018/05/11/other/e6-9c-80-e6-99-ae-e9/","excerpt":"","text":"转自：捷越联合JieyueUnited 最近专业学习有些懈怠，坚持的事情也处于中止状态，对于是否坚持过去做的事情心里一直在纠结，直白地说就是迷茫。对未来，对生活，对生命，以及对自己的无知，错失飞跃大好的机会。 当然这段时间也不是什么也没有做，买了几本书金融启蒙的书，看完两三本，虽然是入门的书，对我来说收获也挺多的。因为活了这么久，看了各种出处的不少文章，懂的也只是一知半解，在完整看完一本书的时候，才对生活，对金融有了完整的认识。发现不知道的、一直困惑和迷茫的事情，有的人在很早的时候就已经遇到并有解决的方法了，有多早，早在几千年前！转载一下这本书的总结，有兴趣的话建议还是看看这本书。 相信很多人都会思考一些跟金钱有关的问题，比方说：** 为什么我们赚的钱仅仅只够应付日常开支？** 为什么我们总是觉得钱不够花？** 为什么我们不能像那些有钱人一样富有？** ** 其实以上这些问题也是我们在学习理财的时候，首先要解答的疑惑。**只要通过学习和运用理财的基本原理，我们就能够很好的解决这些问题。 《巴比伦最富有的人》这本理财经典之作，作者以轻松的寓言故事向读者阐述了投资理财最基本的原理。可以说，不论你是大学毕业生，还是初出茅庐的理财新手，甚至是资深投资人，这本书都会令你受益匪浅。 作者乔治·克拉森（1874年～1957年），商人、作家，美国著名的理财大师、现代理财教育的先驱。以古巴比伦为背景，用寓言体方式来解释他的观点。这些小册子在银行业及保险业发行量极大，并很快成为数百万人耳熟能详的著作，后来结集在《巴比伦最富有的人》一书中出版面世。 读完《巴比伦最富有的人》，你将通晓最基本、最不能忘记的财富法则，完成你一生必经的财富启蒙；你将了解财富的获得需要积累，学会增收节支、合理使用金钱；你将学会在绕开财务陷阱、保证资金安全的前提下，如何积极投资，掌控风险以获得更大的经济利益。《巴比伦最富有的人》所提出的最古老、最普遍、最有效的财富法则，将指引你从一文不名走向成功和快乐。 其实这本书并没有讲什么高深的投资技巧，其中的原理可以简单总结为7点，也就是获得财富的7个诀窍。 1让你的钱袋鼓起来这个诀窍几乎可以说是其余6个诀窍的基础，如果你不能让你的钱袋子鼓起来，后面的步骤就根本无法进行。而这里所说的钱袋，其实就是要建立自己的储蓄，未来可以动用这笔闲钱进行投资，实现滚雪球的效应。 那么，要如何让自己的钱袋鼓起来？书中给出了一种最简单，但也是最有效的方法： 当你每次放10个铜板进钱袋的时候，只拿出9个来用。这样，你的钱袋马上就会开始变鼓，而且越来越沉，用手掂着很舒服，同时也会让你的心里很满足。 将这个诀窍运用到现实生活当中，就是每当你有一笔收入时，就拿出至少10%用于储蓄，任何情况下都不要动用这笔钱，这就是你未来财富的种子基金。比方说，发工资的时候，先拿出10%存到另外一个银行账户里，然后用其余的90%支付生活开支，同样也能生活得很好。如果公司发放奖金或年终奖的时候，也要先存下10%的资金，其余的钱才能用于支付开支或其他消费。这也可以理解为强制储蓄，总之一定要在自己消费以前先存下一笔钱来，这叫做先支付自己，再支付别人。 2控制你的开支用九成的收入去支付开支的时候，我们仍然要小心翼翼，尽量将钱花在当花的地方，不要铺张浪费。如何让自己生活得很好，同时又能节省下一大笔开支，这确实是个技术活。这里要注意，节省并不是抠门，而是既要生活好，又要能省钱。比方说，如果你经常在周末和家人一起外出吃大餐的话，就可以考虑周末自己在家做饭，吃同样丰盛的饭菜，自己做的成本可能只需要一半。 另外，我还会养成记账的习惯，这样我就能够清楚的知道，每个月我在哪方面的开支是最大的，哪些开支是必须花费的；而哪些开支又是可以节省的。我的钱始终是花在让自己真正需要的地方，而不是花在跟别人攀比上。 可以看到，第一个诀窍可以让你的节余比例达到10%；而第二个诀窍就可以进一步提升节余比例。跟大家透露一点，平时我的节余比例可以达到30%以上，最高的时候甚至可以达到50%以上，也就是我的收入的一半都可以节省下来用于投资。 3让你的金子增值所谓让金子增值，也就是让钱为我们工作，将之前存下来的闲钱用于投资。那到底要投资什么呢？这取决于你懂得哪些投资项目。如果你想参与某项投资，那就先去学习它，向懂得这项投资的人请教，搞懂以后再去投资。想想看，你平时投资的时候会向谁咨询？身边根本不懂投资的亲戚朋友，还是投资理财方面的专业人士？ 4避免失去你的财富注意风险，永远不要参与自己都没有搞懂的投资项目。刚刚积累到一笔财富的人经常会幻想自己会发大财，能够利用手头的钱实现不可能的高利润。但具有投资头脑的人都知道，任何暴利的背后都潜藏着巨大的风险。如果一个投资项目，你不懂，又不想学习的话，那么就永远不要去碰它。要知道，不现实地投资、听信骗子的花言巧语，以及轻信自己无知幻想的人都会在投资当中失去自己宝贵的本金。 5使你的房子成为一项有益的投资要用理性的眼光看待自己的房产，这里要注意的是，在国外，房产和土地是不分开的，买下房产的同时，也就买下了土地，这样的买卖是很公道的。而在国内，土地是国家所有，你只是买了土地上的房产。另外，如果买房需要花掉你所有的积蓄，同时还会让你背负沉重的债务负担的话，那就不是一项有益的投资了。 对于房产投资，我最关注的是租售比，比方说，我现在租住的房屋，每月租金是2200元，房屋的售价是125万，租售比是1：47，买房的钱可以支付47年的租金。这么来算的话，买房就是十分不划算的。 6确保未来的收入确保未来的收入主要包括两个方面： 保证在家庭失去主心骨的时候仍然有足够的财富，这其实就是通过保险来规避可能的风险。要在年富力强的时候，为年老以后的日子做准备，这其实就是提前储备养老金。 保险和养老金永远是理财最先要完成的家庭财务目标，当然，也可以将孩子的教育金纳入进来。 7增强你自己的赚钱能力真正能够让自己赚大钱的一定是自己的事业，这一点对于需要积累第一桶金的小伙伴来说尤为重要。如果你觉得自己不够聪明，那就努力提升自己的能力，不断学习，增加自己的智慧。如果你已经足够聪明，那就尝试比别人更勤奋的做事，同时维护好自己的信誉。 这七个获取财富的诀窍看似简单，但其实却蕴含着富人之所以有钱的真正秘密。就像书中所说的那样：掌握这7条最古老、最普遍，同时也是最有效的财富法则，将会指引你从一文不名走向成功和快乐。 《巴比伦最富有的人》经典语录分享： ** 1、如果没有源源不断的放入金币的话，再鼓鼓的钱袋也会空的。 ** 2、我明白了，为什么我们一直没有赚到钱，因为我们一直不懂得如何赚钱，从来没有去寻找过它。 ** 3、你付钱给所有人，却没付给自己。（首先支付自己） ** 4、命运常常给人们带来意外之财，再让他们全部破产，引诱他们大肆挥霍，失去所有，只剩下再也无力满足的种种欲望。 ** 5、人们本来有很多时间创造财富，却让时间白白流失。 ** 6、学习，一种是学习我们已经知道的东西，另一种是学习我们如何去发现我们不知道的东西。 ** 7、我的致富之路就是从我决定把收入的一部分留给自己的时候开始的。 ** 8、今天的太阳和你父辈出生的时候没什么两样。 ** 9、留下的每一个金币都是你的努力，他们可以为你服务。 ** 10、你要把所得的一部分钱财留给自己。无论你的收入多么微薄，都应该留下至少十分之一。 ** 11、向那些每天与钱打交道的人请教。 ** 12、你想了解珠宝，找珠宝商；你想了解羊，找牧羊人。得到建议不花钱，但你应该只接受那些有价值的建议。轻易听信外行的建议来处置自己积蓄的人，只能落得两手空空。 ** 13、建立一支由金币组成的队伍。最后让金币为你服务。 ** 14、意志力，简直就是无稽之谈。做事靠的是目标。 ** 15、财富的增长就像魔法一样，没有人能遇见它的极限。 ** 16、为你的未来积蓄一些财富。 ** 17、你越早的埋下财富种子，你越勤恳的用多余的钱财来浇灌它，它越早的让你乘凉。 ** 18、安稳销量的回报比冒险好的多。 ** 19、获得财富的7个诀窍：A 让你的钱袋鼓起来。B 控制你的开支。C 让你的金子增值。D 避免失去你的财富。E 使你的房子成为一项有益的投资。F 确保未来的收入。G 增强你赚钱的能力。 ** 20、那些懂得节省下来一部分收入的人更容易赚到钱，而那些总是钱袋空空的人却很难赚到钱。 ** 21、除非有意克制自己，否则我们所谓的“必要开支”将总是与我们的收入相等。 ** 22、不要把必要开支和欲望混淆。 ** 23、你和你家人的欲望是你的收入支付能力永远无法满足的。 ** 24、所有人都背负着自己无法满足的欲望。 ** 25、为你的开支制定一个计划。 ** 26、让每一个铜板都为你工作。 ** 27、投资的第一个原则就是保证你本钱的安全。 ** 28、在借钱给别人前，一定要确定这个人的偿还能力和很好的信用。 ** 29、不要过于自信的把你的财富投入可能的陷阱里。 ** 30、利用明智人的建议，善于投资人的建议和智慧保护你的财富。 ** 31、如果一个人用收入的9/10来维持生计和享受生活，而且这9/10的收入中又有一部分在不影响他生活质量的情况下进行一项有益的投资，那么这个人的财富就会增长很快。 ** 32、借贷商人愿意为想给自己购置住宅的人提供服务。 ** 33、开始很少的钱，然后随着一个人的能力增长，他获得财富越来越多。 ** 34、我们懂的东西越多，赚的钱越多。 ** 35、积极行动的人才能获得幸运女神的青睐。 ** 36、如果一个人幸运，就是把他扔到河里，他也会抓一把珍珠上来。 ** 37、幸运女神不会等待拖延者。 ** 38、做生意要先付定金。 ** 39、我们往往固执的坚持错误的选择，而当一个正确的选择到面前，却又让机会轻易地溜走。 ** 40、好运往往伴随机遇而来。 ** 41、要得到好运，就要抓住机会。 ** 42、积极把握机会的人才能引来幸运女神的青睐，她总是愿意帮助那些能够果断采取行动的人。 ** 43、只有懂得黄金法则并遵照去做的人才能得到金子。 ** 44、对于善于思考的人来说，赚钱只是一个很小的负担，但他需要年复一年的背负他，直到实现目标。 ** 45、**魔力就你的欲望之中。","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"Shadowsocks 使用总结","slug":"tools/shadowsocks-e4-bd","date":"2018-05-08T03:01:41.000Z","updated":"2019-11-09T03:02:54.973Z","comments":true,"path":"2018/05/08/tools/shadowsocks-e4-bd/","link":"","permalink":"http://blog.le-more.com/2018/05/08/tools/shadowsocks-e4-bd/","excerpt":"","text":"1.VPS服务器购买： VIRMACH 官网（我选择最便宜的一款，支付宝支付，服务器需要人工审核，大概几个小时通过） 2.重新安装系统：Ubuntu 12.04 x86 3.装配置服务端：Shadowsocks-go一键安装脚本 4.客户端配置 从 shadowsocks-windows下载windwos客户端，配置如下： 5.下载安装SwitchyOmega Chrome插件,添加情景shadow_sockets 代理协议SOCKET5 代理服务器：127.0.0.1 代理端口：1080 6.在chrome浏览器右上角选择SwitchyOmega的场景shadow_sockets，开始新世界的旅程吧！ 7.iOS手机下载Shadowrocket,如果不想花钱就下载PP助手 脚本地址被墙，可以试试这个Shadowsocks-go一键安装脚本","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"Unity开发之类库封装与调用","slug":"u3d/unity-e5-bc-80-e5-8f-91-e11","date":"2018-01-04T01:38:55.000Z","updated":"2019-11-08T09:59:31.019Z","comments":true,"path":"2018/01/04/u3d/unity-e5-bc-80-e5-8f-91-e11/","link":"","permalink":"http://blog.le-more.com/2018/01/04/u3d/unity-e5-bc-80-e5-8f-91-e11/","excerpt":"","text":"软件项目随着规模的增大，难免需要分模块，分类库。同时也便于积累，将和项目无关的功能封装起来，方便以后用于其他项目。下面记录一下Unity中封装自定义的类库。 使用VS或MonoDevelop创建类库项目： 1.引用UnityEngine.dll类库（Mac下目录Applications/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll Windows位置Program Files\\Unity\\Editor\\Data\\Managed\\UnityEngine.dll，版本不一样位置可能不同）； 2.设置项目属性：Target framework,Mono版本的C#最高支持3.5； 3.编写功能类； 4.设置Build Event,编译完成自动拷贝文件Post-build event command line: copy “$(TargetDir)$(TargetFileName)” “..\\..\\..\\..\\..\\ProjectName\\Assets\\Plugins\\xxx\\$(TargetFileName)”","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之插件---高德地图定位和地理围栏(iOS)","slug":"u3d/b0-e7-90-86-e5-9b-b4","date":"2018-01-03T07:47:28.000Z","updated":"2019-11-08T09:59:31.011Z","comments":true,"path":"2018/01/03/u3d/b0-e7-90-86-e5-9b-b4/","link":"","permalink":"http://blog.le-more.com/2018/01/03/u3d/b0-e7-90-86-e5-9b-b4/","excerpt":"","text":"在前一篇记录了使用Unity编写高德定位及地理围栏的插件，下面介绍一下iOS。 复制一份高德的示例工程officialDemoLoc(省了配置工程，和引用库文件),创建AMapHelper类文件（.h和.mm）,头文件主要包含AMapHelper单例类，和导出的几个方法,如下： #import &lt;Foundation/Foundation.h&gt;#import &lt;AMapLocationKit/AMapLocationKit.h&gt;#import “IUnityInterface.h” #if defined(cplusplus)extern “C”{#endif extern void UnitySendMessage(const char *, const char *, const char *);#if defined(cplusplus)}#endif extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStartLocation(const char * apiKey);extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStopLocation();extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStartGeoFence(const char * jsonString);extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStopGeoFence();extern “C” bool UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityContainsCoordinate(double lat,double lng); @interface AMapHelper : NSObject&lt;AMapLocationManagerDelegate,AMapGeoFenceManagerDelegate&gt; @property (nonatomic, strong) AMapLocationManager *locationManager;//@property (nonatomic, strong) AMapGeoFenceManager *geoFenceManager;@property (nonatomic, strong) AMapLocationRegion *locationRegion; + (instancetype)sharedInstance; @end 定位和围栏 - (void)startLocation:(NSString *)apiKey{ [[AMapServices sharedServices] setApiKey:apiKey]; \\[self configLocationManager\\]; //开始进行连续定位 \\[self.locationManager startUpdatingLocation\\];} -(void)stopLocation{ //停止定位 [self.locationManager stopUpdatingLocation];} -(void)startGeoFence:(NSString*)jsonStr{ NSError *error = nil; NSData *data = [jsonStr dataUsingEncoding: NSUTF8StringEncoding]; id jsonObject = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; NSString *customId; CLLocationCoordinate2D *coorArr; if (\\[jsonObject isKindOfClass:\\[NSDictionary class\\]\\]) { NSDictionary \\*dict = (NSDictionary\\*)jsonObject; customId = \\[dict valueForKey:@&quot;customId&quot;\\]; NSArray *pointList =\\[dict valueForKey:@&quot;customId&quot;\\]; long count = \\[pointList count\\]; coorArr = (CLLocationCoordinate2D*)malloc(sizeof(CLLocationCoordinate2D) * count); for(int i = 0;i&lt;\\[pointList count\\];i++){ NSDictionary*item = \\[pointList objectAtIndex:i\\]; double lat = \\[\\[item objectForKey:@&quot;latitude&quot;\\] doubleValue\\]; double lng = \\[\\[item objectForKey:@&quot;longitude&quot;\\] doubleValue\\]; coorArr\\[i\\] = CLLocationCoordinate2DMake(lat, lng); } self.locationRegion = \\[\\[AMapLocationPolygonRegion alloc\\] initWithCoordinates:coorArr count:count identifier:customId\\]; //开始 \\[self.locationManager startMonitoringForRegion:self.locationRegion\\]; free(coorArr); }} -(void)stopGeoFence{ [self.locationManager stopMonitoringForRegion:_locationRegion];} 导出函数实现： extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStartLocation(const char * apiKey){ [[AMapHelper sharedInstance] startLocation:[NSString stringWithUTF8String:apiKey]];} extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStopLocation(){[[AMapHelper sharedInstance] stopLocation];} extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStartGeoFence(const char * jsonString){ [[AMapHelper sharedInstance] startGeoFence:[NSString stringWithUTF8String:jsonString]];} extern “C” void UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityStopGeoFence(){ [[AMapHelper sharedInstance] stopGeoFence];} extern “C” bool UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API MAMapUnityContainsCoordinate(double lat,double lng){ return [[AMapHelper sharedInstance] containsCoordinate:lat lng:lng];} 将两个文件复制到Unity工程目录，保存在Plugins/iOS目录下，iOS可以在Plugins下任意目录，也可以有多个iOS目录。 Unity下调用iOS方法: #elif UNITY_IOS [DllImport (“__Internal”)] private static extern void MAMapUnityStartLocation (string apiKey); \\[DllImport (&quot;__Internal&quot;)\\] private static extern void MAMapUnityStopLocation (); \\[DllImport (&quot;__Internal&quot;)\\] private static extern void MAMapUnityStartGeoFence(string jsonString); \\[DllImport (&quot;__Internal&quot;)\\] private static extern void MAMapUnityStopGeoFence (); \\[DllImport (&quot;__Internal&quot;)\\] private static extern bool MAMapUnityContainsCoordinate(double lat,double lng); public void StartLocation(string apiKey) { MAMapUnityStartLocation(apiKey); } public void StopLocation() { MAMapUnityStopLocation(); } public void StartGeoFence(string jsonString) { MAMapUnityStartGeoFence(jsonString); } public void StopGeoFence() { MAMapUnityStopGeoFence(); }#endif 使用方式和方法和Android相同。功能基本实现，性能及精度还有待优化。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之插件---高德地图定位和地理围栏(Android)","slug":"u3d/e5-9c-b0-e7-90-86-e5","date":"2018-01-03T07:47:14.000Z","updated":"2019-11-08T09:59:31.012Z","comments":true,"path":"2018/01/03/u3d/e5-9c-b0-e7-90-86-e5/","link":"","permalink":"http://blog.le-more.com/2018/01/03/u3d/e5-9c-b0-e7-90-86-e5/","excerpt":"","text":"Unity3d是一款3D游戏开发引擎，也可以开发2D游戏。可一键式发布到多种平台，可发布到iOS,Android,Windows,macOS等。其原理就是在底层帮开发者根据不同平台做了处理。但这并不是万能的，有时候我们需要自己来开发Unity和平台API交互的程序，即Unity插件。下面总结开发iOS和Android插件。 Android制作Unity插件请参考：在 Unity 中使用 Android SDK ，简单有效。下面说一下集成高德定位的部分。 下载高德定位sdk，集成的版本是AMap_Location_V3.5.0_20170731.jar,将下载好的文件放置在libs目录 参考高德提供的功能示例，编写AMapHelper.java类,主要功能代码： 启动定位： public void startLocation(String apiKey){ AMapLocationClient.setApiKey(apiKey); //初始化client locationClient = new AMapLocationClient(Utils.getContext()); locationOption = getDefaultOption(); //设置定位参数 locationClient.setLocationOption(locationOption); // 设置定位监听 locationClient.setLocationListener(locationListener); // 启动定位 locationClient.startLocation(); }停止定位： public void stopLocation(){ // 停止定位 locationClient.stopLocation(); showLog(&quot;停止定位成功!&quot;); }添加围栏及停用： public void startGeoFence(String jsonString) throws Exception{ initGeoFence(); addFence(jsonString); } public void stopGeoFence(){ if (null != fenceClient) { fenceClient.removeGeoFence(); } try { Utils.getContext().unregisterReceiver(mGeoFenceReceiver); } catch (Throwable e) { } }回调Unity代码： private void SendMessage(int what, String msg){ switch(what){ case 0: UnityPlayer.UnitySendMessage(“AMapHelper”,”onLocationChanged”,msg); break; case 1: UnityPlayer.UnitySendMessage(“AMapHelper”,”onFenceChanged”,msg); break; } } Unity中同样定义AMapHelper类用来调用Java类,关键代码： #elif UNITY_ANDROID private AndroidJavaClass jcu; private AndroidJavaObject jou; private AndroidJavaObject amapHelper; /// &lt;summary&gt; /// 开始定位 /// &lt;/summary&gt; public void StartLocation(string apiKey) { error = false; errorInfo = &quot;&quot;; try { if(jcu == null){ jcu = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;); jou = jcu.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;); amapHelper = new AndroidJavaObject(&quot;com.shuimu.plugin.AMapHelper&quot;); } amapHelper.Call(&quot;startLocation&quot;,apiKey); } catch (System.Exception ex) { UnityLibs.Debuger.Log(ex.Message); error = true; errorInfo = ex.Message; } } public void StopLocation() { amapHelper.Call(&quot;stopLocation&quot;); } public void StartGeoFence(string jsonString) { amapHelper.Call(&quot;startGeoFence&quot;, jsonString); } public void StopGeoFence() { amapHelper.Call(&quot;stopGeoFence&quot;); } void OnDestroy() { if(amapHelper != null) amapHelper.Call(&quot;deactivate&quot;); }#elif UNITY_IOS 定位及围栏回调： //围栏状态更新 void onFenceChanged(string msg) { int status = int.Parse(msg); fenceStatus = (GeoFence)status; if (fenceChanged != null) { fenceChanged(); } } //定位更新 void onLocationChanged(string msg) { string\\[\\] msgs = msg.Split(&apos;;&apos;); if (msgs\\[0\\] == &quot;0&quot;) { locationInfo.Latitude = double.Parse(msgs\\[1\\]); locationInfo.Longitude = double.Parse(msgs\\[2\\]); } else { error = false; errorInfo = &quot;定位失败&quot;; } if (locationChanged != null) { locationChanged(); } } }使用方法： 1.在场景中AMapHelper附加到一空对象 2.初始化及设置回调： amapHelper.locationChanged += locationChanged; amapHelper.StartLocation(GlobalDef.AMap_ApiKey); 下一篇介绍iOS插件。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity开发之工具---导表（Excel）的制作分析","slug":"u3d/e5-af-bc-e8-a1-a8-ef-bc","date":"2017-12-28T07:47:49.000Z","updated":"2019-11-08T09:59:31.013Z","comments":true,"path":"2017/12/28/u3d/e5-af-bc-e8-a1-a8-ef-bc/","link":"","permalink":"http://blog.le-more.com/2017/12/28/u3d/e5-af-bc-e8-a1-a8-ef-bc/","excerpt":"","text":"在项目开发中，需要开发周边的工具以提高效率，比如关卡编辑工具（方便新增关卡），技能配置工具(方便调整数值)，导表工具（方便处理策划和程序中的配置数据），下面就说一下最简单的导表工具制作。 在开发过程中，项目需求是由策划提供的，他们擅长使用的工具多数是Excel。如何整理、变更和方便策划调整数值以及程序使用，都是需要预先考虑好的。 一、处理游戏中众多的数据，同样使用面向对象的方式，以关系型数据为基础来创建表及表之间的关系。 比如：关卡表 怪物表 关卡和怪物是一对多的关系，为了减少表的数量，也便于维护，可以在同一条记录中记录多个怪物，同时为了设置在战斗场景中的尺寸，使用分割符同一列包括多个数据。 二、对于Excel表中的数据更新和维护有时候很频繁，使用一键式工具导出很有必要，如何定义在程序中的类型及导出什么格式，需要根据项目的情况来。可以导成xml,json,lua代码或自己定义的任意格式。每列定义的方式如下： 第一行备注，第二行程序中定义的字段，第三行该列的类型。 以导出Json为例子，数值为空的情况是很普遍的，可以根据每列的类型，自动填充默认值，防止解析值为null的错误。 三、真实的项目表的数量会有很多，表数据有的用于客户端的有的用于服务端。同一张表的数据，各列有时候也需要区别对待，适用前端或后端。如何区分表及表中的字段，就需要一个控制表 客户端和服务端各有一个配置表，这样就可以定制化导出数据了！ 最终工具截图，^_^","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"tool","slug":"tool","permalink":"http://blog.le-more.com/tags/tool/"}]},{"title":"Unity开发之网络---集成Protobuf","slug":"u3d/unity-e9-9b-86-e6-88-90protobuf","date":"2017-10-09T10:31:23.000Z","updated":"2019-11-08T09:59:31.025Z","comments":true,"path":"2017/10/09/u3d/unity-e9-9b-86-e6-88-90protobuf/","link":"","permalink":"http://blog.le-more.com/2017/10/09/u3d/unity-e9-9b-86-e6-88-90protobuf/","excerpt":"","text":"下载protobuf 源码 mgravell/protobuf-net 复制protobuf-net-master\\src\\protobuf-net 目录到Assert下的任意目录 Assert目录下创建smcs.rsp和gmcs.rsp 文件内容都是：-unsafe (可用文本文件创建然后改名，后缀为rsp) 打开protobuf-net-master\\src下的protobuf-net.sln 编译生成ProtoGen 可执行文件(使用2015打开报错，可将protobuf-net-master\\assorted\\ProtoGen复制替换protobuf-net-master\\src下的同名目录，2015可打开，修改该项目下的引用protobuf-net-master\\assorted\\protobuf-net.Enyim\\packages\\protobuf-net.2.0.0.602\\lib\\net20下的protobuf.dll) 测试脚本，将下面脚本存为generator.bat复制到protogen.exe相同目录，创建protobuf目录后双击执行，成功会在protobuf目录生成descriptor.cs源文件 @echo offset out_path=%cd%/protobufset in_path = %cd%/protosrem cd ProtoGenrem 查找文件for /R “%cd%” %%i in (%in_path%.proto) do echo %%~nifor /R “%cd%” %%i in (%in_path%.proto) do protogen -i:%%i -o:%out_path%/%%~ni.cspause 编写自动化脚本，脚本目录请根据项目情况而定 %cd%\\..\\..\\..\\Tools\\ProtoGen\\protogen.exe -i:protos\\Common.proto -o:protobuf\\Common.cs xcopy protobuf %cd%\\..\\..\\..\\Code\\ProjName\\Assets\\Scripts\\App\\Net\\Proto /s /f /qxcopy protobuf %cd%\\..\\..\\..\\Code\\Server\\GameServer\\App\\Net\\Proto /s /f /q 序列化 /// 将消息序列化为二进制的方法 /// &lt; param name=&quot;model&quot;&gt;要序列化的对象&lt; /param&gt; public static byte\\[\\] Serialize&lt;T&gt;(T model) { try { //涉及格式转换，需要用到流，将二进制序列化到流中 using (MemoryStream ms = new MemoryStream()) { //使用ProtoBuf工具的序列化方法 ProtoBuf.Serializer.Serialize&lt;T&gt;(ms, model); //定义二级制数组，保存序列化后的结果 byte\\[\\] result = new byte\\[ms.Length\\]; //将流的位置设为0，起始点 ms.Position = 0; //将流中的内容读取到二进制数组中 ms.Read(result, 0, result.Length); return result; } } catch (Exception ex) { UnityLibs.Debuger.Log(&quot;序列化失败: &quot; + ex.ToString()); return null; } }测试实例： ReqLogin reqLogin = new ReqLogin(); reqLogin.user_name =userName; reqLogin.password = passWord; reqLogin.type =accoutType; byte[] buffer = Utils.Serialize(req); 反序列化 /// 将收到的消息反序列化成对象 /// &lt; returns&gt;The serialize.&lt; /returns&gt; /// &lt; param name=&quot;msg&quot;&gt;收到的消息.&lt;/param&gt; public static T Deserialize&lt;T&gt;(byte\\[\\] msg, int dataSise) { try { using (MemoryStream ms = new MemoryStream()) { //将消息写入流中 ms.Write(msg, 0, dataSise); //将流的位置归0 ms.Position = 0; //使用工具反序列化对象 T result = ProtoBuf.Serializer.Deserialize&lt;T&gt;(ms); return result; } } catch (Exception ex) { UnityLibs.Debuger.Log(&quot;反序列化失败: &quot; + ex.ToString()); return default(T); } }测试实例 ReqLogin req = FileUtils.Deserialize(pBuffer, wDataSize); 为了便于重用，可将源文件放到自定义类库，请参考：Unity开发类库封装与调用","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"network","slug":"network","permalink":"http://blog.le-more.com/tags/network/"}]},{"title":"Unity开发之Shader—AR涂涂乐项目实战","slug":"u3d/unity3d-shader-e7-a4-ba-e4","date":"2017-10-09T07:39:59.000Z","updated":"2019-11-08T09:59:31.036Z","comments":true,"path":"2017/10/09/u3d/unity3d-shader-e7-a4-ba-e4/","link":"","permalink":"http://blog.le-more.com/2017/10/09/u3d/unity3d-shader-e7-a4-ba-e4/","excerpt":"","text":"Unity3D Shader示例之—AR涂涂乐实现原理 Unity3D Shader示例之—AR涂涂乐实现方法 最近一段时间忙于项目，日志好久没有更新了，现在挤点时间来一发！ 曾经对AR涂涂乐的原理进行了分析（详见开头链接），但和实际项目还有一些差距。 主角显示在屏幕中间 脱卡 模型接受光照 下面分别解决这些问题！ 要实现追踪目标显示的屏幕中间很简单，一句话搞定： _trackingObj.transform.parent = VuforiaManager.Instance.ARCameraTransform; 如何实现脱卡呢，需要解决两个问题，第一个是离开识别卡，追踪目标不消失，第二个是成功完成一次着色后，不再着色，否则获取的颜色就不是我们涂的卡片上的颜色了。 第一个问题好解决，在接收到Lost事件时，不清除追踪目标就行了 public void OnTrackingLost() { //Clear(); } 第二个问题解决的原理是，在目标被识别时获取摄像头所拍摄的画面作为纹理，然后将纹理传给材质球。 获取摄像机纹理： if (_texture) DestroyImmediate(_texture); _texture = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false); //读取屏幕像素信息并存储为纹理数据 _texture.ReadPixels(rect, 0, 0); _texture.Apply();在Shader的顶点着色器代码中，将世界坐标转为屏幕坐标： o.fixedPos = ComputeScreenPos(mul(UNITY_MATRIX_VP, fixedPos)); UNITY_MATRIX_VP会根据Camera实时计算最新的转换矩阵，所以在获取纹理的现时将转换矩阵保存并转给材质球 //获取VP值 Matrix4x4 P = GL.GetGPUProjectionMatrix(Camera.main.projectionMatrix, false); Matrix4x4 V = Camera.main.worldToCameraMatrix; Matrix4x4 VP = P * V; 完整代码 TrackingBehaviour 光照就不介绍了直接从入门精要复制来的Blinn-Phong光照模型 Coloring3D_VP_Lighting.shader 完整的实现方式请查看Github上的ARProject项目! 下面总结一下开发过程中会遇到一些问题： ARCamera的World Center Mode必须是First Target 获取识别图4个角的世界坐标，注意调用TransformPoint函数的对象，示例使用_controller Vector3 targetAnglePoint1 = _controller.transform.TransformPoint(new Vector3(-halfSize.x, 0, halfSize.y)); Vector3 targetAnglePoint2 = _controller.transform.TransformPoint(new Vector3(-halfSize.x, 0, -halfSize.y)); Vector3 targetAnglePoint3 = _controller.transform.TransformPoint(new Vector3(halfSize.x, 0, halfSize.y)); Vector3 targetAnglePoint4 = _controller.transform.TransformPoint(new Vector3(halfSize.x, 0, -halfSize.y)); 识别成功时，注意重置目标的坐标 //重置坐标//this.transform.parent.localPosition = Vector3.zero;//this.transform.parent.localRotation = Quaternion.Euler(0, 0, 0);this.transform.localPosition = Vector3.zero;this.transform.localRotation = Quaternion.Euler(0, 0, 0); 初始化TrackableEventHandler状态为NOT_FOUND mTrackableBehaviour.OnTrackerUpdate(TrackableBehaviour.Status.NOT_FOUND); Show一下在项目中实现的效果： 示例工程","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"ar","slug":"ar","permalink":"http://blog.le-more.com/tags/ar/"}]},{"title":"Github 创建个人博客","slug":"tools/github-e5-88-9b-e5-bb","date":"2017-07-28T01:43:56.000Z","updated":"2019-11-08T09:59:31.002Z","comments":true,"path":"2017/07/28/tools/github-e5-88-9b-e5-bb/","link":"","permalink":"http://blog.le-more.com/2017/07/28/tools/github-e5-88-9b-e5-bb/","excerpt":"","text":"参考：零基础Github Page免费无限流量个人博客搭建教程 1.新建仓库 注意名称的格式为：github用户名.github.io 2.点击设置，下拉到Github Pages 然后选择主题 3.选择主题界面 4.提交修改 5.创建成功 待续…","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"OpenGL ES学习实践—Shader实现不显示图片4个角","slug":"cocos/e6-98-be-e7-a4-ba-e5","date":"2017-06-29T06:14:29.000Z","updated":"2019-11-08T09:59:30.971Z","comments":true,"path":"2017/06/29/cocos/e6-98-be-e7-a4-ba-e5/","link":"","permalink":"http://blog.le-more.com/2017/06/29/cocos/e6-98-be-e7-a4-ba-e5/","excerpt":"","text":"前一段时间遇到一个问题，如果在程序中不改变图片的情况下，把图片4个角去掉。在看到这个题目的时候，想到通过UV坐标可以实现，但具体的细节不甚明白。如下图 如何过滤斜线覆盖的坐标呢？ 这个问题就要用数学来解决了：假设截取的长度为e,因UV坐标的范围是[0,1]，图中标出边界点的坐标，可通过直线公式分别解出各条直线。 因在window上测试，UV坐标的原点在左上角。求出的各条直接为： 左上：y = -x + e 右上：y = x + e - 1 左下：y = x + 1-e 右下：y = -x + 2-e 根据直线公式分得出落在斜线部分点的条件为： 左上：y +x &lt; e 右上：x- y &gt; 1 -e 左下：y - x &gt; 1-e 右下：y + x &gt; 2-e Shader实现如下(片段着色器)： #ifdef GL_ESprecision mediump float;#endif varying vec4 v_fragmentColor;varying vec2 v_texCoord; const float edge = 0.4; void main(void){ vec4 c = texture2D(CC_Texture0, v_texCoord); //left-up //也可以使用discard，透明度测试 //if(v\\_texCoord.x + v\\_texCoord.y &lt; 0.4) discard; if(v\\_texCoord.x + v\\_texCoord.y &lt; 0.4) c = vec4(0.0); //right-up if(v\\_texCoord.x - v\\_texCoord.y &gt; 0.6) c = vec4(0.0); //left-bottom if(v\\_texCoord.y - v\\_texCoord.x &gt; 0.6) c = vec4(0.0); //right-bottom if(v\\_texCoord.y + v\\_texCoord.x &gt; 1.6) c = vec4(0.0); gl_FragColor = c;} C++类相对简单，直接扩展使用cocos实现的类： class SpriteCutCorner : public Effect{public: CREATE_FUNC(SpriteCutCorner); bool init() { initGLProgramState(&quot;Shaders/custom\\_cut\\_corner.fsh&quot;); return true; }}; 效果如下： 实现这个功能还有其他办法，待续… 工程源码：CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"OpenGL ES学习之四---你好三角形（顶点缓冲区对象）","slug":"cocos/a1-b6-e7-82-b9-e7-bc-93","date":"2017-06-19T12:28:08.000Z","updated":"2019-11-09T02:44:34.205Z","comments":true,"path":"2017/06/19/cocos/a1-b6-e7-82-b9-e7-bc-93/","link":"","permalink":"http://blog.le-more.com/2017/06/19/cocos/a1-b6-e7-82-b9-e7-bc-93/","excerpt":"","text":"加载顶点属性的方式二：顶点缓冲区对象(VBO) 使用缓冲区对象，减少客户内存和图像内存之间数据的复制，提高性能(CPU到GPU数据复制) 预定义宏 #define VERTEX\\_POS\\_SIZE 3 // x, y and z #define VERTEX\\_COLOR\\_SIZE 4 // r, g, b, and a #define VERTEX\\_POS\\_INDX 0 #define VERTEX\\_COLOR\\_INDX 1用户数据结构 typedef struct { // Handle to a program object GLuint programObject; // VertexBufferObject Ids GLuint vboIds\\[2\\]; // x-offset uniform location GLuint offsetLoc; } UserData;初始化 bool VertexBufferObjects::init() { bool ret = false; do { CC\\_BREAK\\_IF(false == TestCase::init()); const char vShaderStr\\[\\] = &quot;#version 300 es \\\\n&quot; &quot;layout(location = 0) in vec4 a_position; \\\\n&quot; &quot;layout(location = 1) in vec4 a_color; \\\\n&quot; &quot;uniform float u_offset; \\\\n&quot; &quot;out vec4 v_color; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; v\\_color = a\\_color; \\\\n&quot; &quot; gl\\_Position = a\\_position; \\\\n&quot; &quot; gl\\_Position.x += u\\_offset; \\\\n&quot; &quot;}&quot;; const char fShaderStr\\[\\] = &quot;#version 300 es \\\\n&quot; &quot;precision mediump float; \\\\n&quot; &quot;in vec4 v_color; \\\\n&quot; &quot;out vec4 o_fragColor; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; o\\_fragColor = v\\_color; \\\\n&quot; &quot;}&quot;; // Create the program object userData.programObject = GLShader::LoadProgram(vShaderStr, fShaderStr); userData.offsetLoc = glGetUniformLocation(userData.programObject, &quot;u_offset&quot;); if (userData.programObject == 0) { return GL_FALSE; } // Store the program object userData.vboIds\\[0\\] = 0; userData.vboIds\\[1\\] = 0; glClearColor(1.0f, 1.0f, 1.0f, 0.0f); ret = true; } while (0); return ret; }绘制函数 void VertexBufferObjects::onDraw(const Mat4&amp; transform, uint32_t flags) { auto winSize = Director::getInstance()-&gt;getWinSize(); // 3 vertices, with (x,y,z) ,(r, g, b, a) per-vertex GLfloat vertices\\[3 * (VERTEX\\_POS\\_SIZE + VERTEX\\_COLOR\\_SIZE)\\] = { -0.5f, 0.5f, 0.0f, // v0 1.0f, 0.0f, 0.0f, 1.0f, // c0 -1.0f, -0.5f, 0.0f, // v1 0.0f, 1.0f, 0.0f, 1.0f, // c1 0.0f, -0.5f, 0.0f, // v2 0.0f, 0.0f, 1.0f, 1.0f, // c2 }; // Index buffer data GLushort indices\\[3\\] = { 0, 1, 2 }; glViewport(0, 0, winSize.width, winSize.height); glClear(GL\\_COLOR\\_BUFFER_BIT); glUseProgram(userData.programObject); glUniform1f(userData.offsetLoc, 0.0f); //不使用顶点缓冲区对象绘制图元 DrawPrimitiveWithoutVBOs(vertices, sizeof(GLfloat) * (VERTEX\\_POS\\_SIZE + VERTEX\\_COLOR\\_SIZE), 3, indices); // Offset the vertex positions so both can be seen glUniform1f(userData.offsetLoc, 1.0f); //使用顶点缓冲区对象绘制图元 DrawPrimitiveWithVBOs(&amp;userData, 3, vertices, sizeof(GLfloat) * (VERTEX\\_POS\\_SIZE + VERTEX\\_COLOR\\_SIZE), 3, indices); }不使用缓冲区绘制 // // vertices - pointer to a buffer that contains vertex // attribute data // vtxStride - stride of attribute data / vertex in bytes 步进（跨距） // numIndices - number of indices that make up primitive // drawn as triangles （顶点数目） // indices - pointer to element index buffer. // void VertexBufferObjects::DrawPrimitiveWithoutVBOs(GLfloat *vertices, GLint vtxStride, GLint numIndices, GLushort *indices) { GLfloat *vtxBuf = vertices; glBindBuffer(GL\\_ARRAY\\_BUFFER, 0); glBindBuffer(GL\\_ELEMENT\\_ARRAY_BUFFER, 0); //启用属性 glEnableVertexAttribArray(VERTEX\\_POS\\_INDX); glEnableVertexAttribArray(VERTEX\\_COLOR\\_INDX); //加载顶点数据 glVertexAttribPointer(VERTEX\\_POS\\_INDX, VERTEX\\_POS\\_SIZE, GL\\_FLOAT, GL\\_FALSE, vtxStride, vtxBuf); vtxBuf += VERTEX\\_POS\\_SIZE; glVertexAttribPointer(VERTEX\\_COLOR\\_INDX, VERTEX\\_COLOR\\_SIZE, GL_FLOAT, GL_FALSE, vtxStride, vtxBuf); glDrawElements(GL\\_TRIANGLES, numIndices, GL\\_UNSIGNED_SHORT, indices); //禁用顶点属性 glDisableVertexAttribArray(VERTEX\\_POS\\_INDX); glDisableVertexAttribArray(VERTEX\\_COLOR\\_INDX); }使用缓冲区绘制 void VertexBufferObjects::DrawPrimitiveWithVBOs(UserData *userData, GLint numVertices, GLfloat *vtxBuf, GLint vtxStride, GLint numIndices, GLushort *indices) { GLuint offset = 0; // vboIds\\[0\\] - used to store vertex attribute data // vboIds\\[l\\] - used to store element indices if (userData-&gt;vboIds\\[0\\] == 0 &amp;&amp; userData-&gt;vboIds\\[1\\] == 0) { // Only allocate on the first draw //创建缓冲区对象 //void glGenBuffers(GLsizei n, GLuint *buffers) //n:number of buffer object names to return //buffers:pointer to an array of n entries, where allocated buffer objects are returned glGenBuffers(2, userData-&gt;vboIds); //激活缓冲区对象(is used to make a buffer object current.) //void glBindBuffer(GLenum target, GLuint buffer); //指定当前活动缓冲区的对象 //target can be set to any of the following targets : //GL\\_ARRAY\\_BUFFER // GL\\_ELEMENT\\_ARRAY_BUFFER // GL\\_COPY\\_READ_BUFFER // GL\\_COPY\\_WRITE_BUFFER // GL\\_PIXEL\\_PACK_BUFFER // GL\\_PIXEL\\_UNPACK_BUFFER // GL\\_TRANSFORM\\_FEEDBACK_BUFFER // GL\\_UNIFORM\\_BUFFER // buffer buffer object to be assigned as the current object to target glBindBuffer(GL\\_ARRAY\\_BUFFER, userData-&gt;vboIds\\[0\\]); //用数据分配和初始化缓冲区对象 //void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage); //target:可以是GL\\_ARRAY\\_BUFFER()（顶点数组数据）或GL\\_ELEMENT\\_ARRAY_BUFFER(元素数组数据) //size:存储相关数据所需的内存容量 //data:用于初始化缓冲区对象，可以是一个指向客户区内存的指针，也可以是NULL //usage:数据在分配之后如何进行读写,如GL\\_STREAM\\_READ，GL\\_STREAM\\_DRAW，GL\\_STREAM\\_COPY glBufferData(GL\\_ARRAY\\_BUFFER, vtxStride * numVertices, vtxBuf, GL\\_STATIC\\_DRAW); glBindBuffer(GL\\_ELEMENT\\_ARRAY_BUFFER, userData-&gt;vboIds\\[1\\]); glBufferData(GL\\_ELEMENT\\_ARRAY_BUFFER, sizeof(GLushort) * numIndices, indices, GL\\_STATIC\\_DRAW); } glBindBuffer(GL\\_ARRAY\\_BUFFER, userData-&gt;vboIds\\[0\\]); glBindBuffer(GL\\_ELEMENT\\_ARRAY_BUFFER, userData-&gt;vboIds\\[1\\]); //启用顶点属性 glEnableVertexAttribArray(VERTEX\\_POS\\_INDX); glEnableVertexAttribArray(VERTEX\\_COLOR\\_INDX); //加载顶点数据 glVertexAttribPointer(VERTEX\\_POS\\_INDX, VERTEX\\_POS\\_SIZE, GL\\_FLOAT, GL\\_FALSE, vtxStride, (const void *)offset); offset += VERTEX\\_POS\\_SIZE * sizeof(GLfloat); //加载顶点数据 glVertexAttribPointer(VERTEX\\_COLOR\\_INDX, VERTEX\\_COLOR\\_SIZE, GL\\_FLOAT, GL\\_FALSE, vtxStride, (const void *)offset); glDrawElements(GL\\_TRIANGLES, numIndices, GL\\_UNSIGNED_SHORT, 0); //禁用顶点属性 glDisableVertexAttribArray(VERTEX\\_POS\\_INDX); glDisableVertexAttribArray(VERTEX\\_COLOR\\_INDX); glBindBuffer(GL\\_ARRAY\\_BUFFER, 0); glBindBuffer(GL\\_ELEMENT\\_ARRAY_BUFFER, 0); }效果图： 20 工程源码：CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"OpenGL ES学习之三---你好三角形（顶点属性数组）","slug":"cocos/a1-b6-e7-82-b9-e5-b1-9e","date":"2017-06-05T01:52:15.000Z","updated":"2019-11-09T02:43:44.500Z","comments":true,"path":"2017/06/05/cocos/a1-b6-e7-82-b9-e5-b1-9e/","link":"","permalink":"http://blog.le-more.com/2017/06/05/cocos/a1-b6-e7-82-b9-e5-b1-9e/","excerpt":"","text":"加载顶点属性的方式一：顶点属性数组 结合绘制三角形的实例，介绍使用定义顶点属性及其赋值的方法。 初始化，获得程序对象 bool HelloTriangle::init() { bool ret = false; do { CC\\_BREAK\\_IF(false == TestCase::init()); char vShaderStr\\[\\] = &quot;//着色器语言版本 \\\\n&quot; &quot;#version 300 es \\\\n&quot; &quot;//布局变量块指定变量在内存布局方式 \\\\n&quot; &quot;layout(location = 0) in vec4 vPosition; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; gl_Position = vPosition; \\\\n&quot; &quot;} \\\\n&quot;; char fShaderStr\\[\\] = &quot;#version 300 es \\\\n&quot; &quot;//指定默认精度限定符为mediump \\\\n&quot; &quot;precision mediump float; \\\\n&quot; &quot;//指定输出变量 \\\\n&quot; &quot;out vec4 fragColor; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 ); \\\\n&quot; &quot;} \\\\n&quot;; //创建程序对象 programObject = GLShader::LoadProgram(vShaderStr, fShaderStr); //获取最大顶点属性数量 GLint maxVertexAttribs; // n will be &gt;= 16 glGetIntegerv(GL\\_MAX\\_VERTEX_ATTRIBS, &amp;maxVertexAttribs); // Bind vPosition to attribute 0 // 第二个方法使用layout 在着色器中指定 glBindAttribLocation(programObject, 0, &quot;vPosition&quot;); ////获取属性的索引 //GLuint index = glGetAttribLocation(programObject, // &quot;vPosition&quot;); ret = true; } while (0); return ret; }绘制函数 void HelloTriangle::onDraw(const Mat4&amp; transform, uint32_t flags) { GLfloat vVertices\\[\\] = { 0.0f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f }; // Clear the color buffer glClear(GL\\_COLOR\\_BUFFER_BIT); // Use the program object //函数原型： // void glUseProgram(int program) // 参数含义： // program是要使用的着色器程序的id。 glUseProgram(programObject); //glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer):加载顶点数据 //index:顶点属性的索引值 //size:每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）） //type:顶点的数据类型 //normalized:是否归一化 //stride:顶点属性之间的偏移量 //pointer:指定第一个组件在数组的第一个顶点属性中的偏移量 // Load the vertex data glVertexAttribPointer(0, 3, GL\\_FLOAT, GL\\_FALSE, 0, vVertices); glEnableVertexAttribArray(0); //(v0,v1,v2,v3,v4,v5) //GL_TRIANGLES:两个三角形 (v0,v1,v2) (v3,v4,v5) //GL\\_TRIANGLE\\_STRIP:三个三角形(v0,v1,v2)(v1,v2,v3)(v2,v3,v4) //GL\\_TRIANGLE\\_FAN:三个三角形(v0,v1,v2)(v0,v2,v3)(v0,v3,v4) //glDrawArrays (GLenum mode, GLint first, GLsizei count):绘制三角形 //mode:GL\\_POINTS、GL\\_LINES、GL\\_LINE\\_LOOP、GL\\_LINE\\_STRIP、GL\\_TRIANGLES、GL\\_TRIANGLE\\_STRIP、GL\\_TRIANGLE_FAN //first: 0 //count: 3 glDrawArrays(GL_TRIANGLES, 0, 3); }使用常量指定顶点属性初始化 bool HelloTriangle_ConstAndVertexArray::init() { bool ret = false; do { CC\\_BREAK\\_IF(false == TestCase::init()); const char vShaderStr\\[\\] = &quot;#version 300 es \\\\n&quot; &quot;layout(location = 0) in vec4 a_color; \\\\n&quot; &quot;layout(location = 1) in vec4 a_position; \\\\n&quot; &quot;out vec4 v_color; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; v\\_color = a\\_color; \\\\n&quot; &quot; gl\\_Position = a\\_position; \\\\n&quot; &quot;}&quot;; const char fShaderStr\\[\\] = &quot;#version 300 es \\\\n&quot; &quot;precision mediump float; \\\\n&quot; &quot;in vec4 v_color; \\\\n&quot; &quot;out vec4 o_fragColor; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; o\\_fragColor = v\\_color; \\\\n&quot; &quot;}&quot;; //创建程序对象 programObject = GLShader::LoadProgram(vShaderStr, fShaderStr); glClearColor(0.0f, 0.0f, 0.0f, 0.0f); ret = true; } while (0); return ret; }绘制函数 void HelloTriangle\\_ConstAndVertexArray::onDraw(const Mat4&amp; transform, uint32\\_t flags) { auto winSize = Director::getInstance()-&gt;getWinSize(); GLfloat color\\[4\\] = { 1.0f, 0.0f, 0.0f, 1.0f }; // 3 vertices, with (x, y, z) per-vertex GLfloat vertexPos\\[3 * 3\\] = { 0.0f, 0.5f, 0.0f, // v0 -0.5f, -0.5f, 0.0f, // v1 0.5f, -0.5f, 0.0f // v2 }; glViewport(0, 0, winSize.width, winSize.height); glClear(GL\\_COLOR\\_BUFFER_BIT); glUseProgram(programObject); //指定常量顶点属性 glVertexAttrib4fv(0, color); glVertexAttribPointer(1, 3, GL\\_FLOAT, GL\\_FALSE, 0,vertexPos); //glEnableVertexAttribArray(0); glEnableVertexAttribArray(1); glDrawArrays(GL_TRIANGLES, 0, 3); //glDisableVertexAttribArray(1); //查询活动属性变量数量 //GLint numActiveAttribs; //glGetProgramiv(programObject, GL\\_ACTIVE\\_ATTRIBUTES, &amp;numActiveAttribs); }不知道为什么三个顶点的颜色不一样… 工程源码：CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"OpenGL ES学习之二---着色器与程序","slug":"cocos/opengl-es-e5-ad-a6-e","date":"2017-06-02T04:19:30.000Z","updated":"2019-11-08T09:59:30.974Z","comments":true,"path":"2017/06/02/cocos/opengl-es-e5-ad-a6-e/","link":"","permalink":"http://blog.le-more.com/2017/06/02/cocos/opengl-es-e5-ad-a6-e/","excerpt":"","text":"主要代码来自《OpenGL.ES.3.0.Programming.Guide.2nd.Edition》 在原书代码基础上，加入到Cocos的工程。具体的使用及API介绍会在代码详细描述,原理及流程前面已经有所说明，不再赘述！ 函数声明： //加载编译Shader源码，返回shader实例句柄static GLuint LoadShader(GLenum type, const char shaderSrc);//加载程序，返回程序句柄static GLuint LoadProgram(const char \\vertShaderSrc, const char *fragShaderSrc); 函数定义： GLuint GLShader::LoadShader(GLenum type, const char *shaderSrc){ GLuint shader; GLint compiled; // Create the shader object //函数原型： // int glCreateShader(int type) // 方法参数： // GL\\_VERTEX\\_SHADER(顶点shader) // GL\\_FRAGMENT\\_SHADER(片元shader) shader = glCreateShader(type); if (shader == 0) return 0; // Load the shader source //函数原型： // void glShaderSource(int shader, String string) // 参数含义： // shader是代表shader容器的id（由glCreateShader返回的整形数）； // string是包含源程序的字符串数组。 glShaderSource(shader, 1, &amp;shaderSrc, NULL); // Compile the shader //函数原型： // void glCompileShader(int shader) // 参数含义： // shader是代表shader容器的id。 glCompileShader(shader); // Check the compile status //编译阶段使用glGetShaderiv获取编译情况 //函数原型： // void glGetShaderiv(int shader, int pname, int\\[\\] params, int offset) // 参数含义： // shader是一个shader的id； // pname使用GL\\_COMPILE\\_STATUS； // params是返回值，如果一切正常返回GL\\_TRUE代，否则返回GL\\_FALSE。 glGetShaderiv(shader, GL\\_COMPILE\\_STATUS, &amp;compiled); if (!compiled) { GLint infoLen = 0; glGetShaderiv(shader, GL\\_INFO\\_LOG_LENGTH, &amp;infoLen); if (infoLen &gt; 1) { char* infoLog = (char *)malloc(sizeof(char) * infoLen); //编译阶段使用glGetShaderInfoLog获取编译错误 //函数原型： // String glGetShaderInfoLog(int shader) // 参数含义： // shader是一个顶点shader或者片元shader的id。 glGetShaderInfoLog(shader, infoLen, NULL, infoLog); GLUtils::LogMessage(&quot;Error compiling shader:\\\\n%s\\\\n&quot;, infoLog); free(infoLog); } // Free up no longer needed shader resources //函数原型： // void glDeleteShader(int shader)； // 参数含义： // shader是要被排除的顶点shader或者片元shader的id。 glDeleteShader(shader); return 0; } return shader;} 获取程序对象 GLuint GLShader::LoadProgram(const char *vertShaderSrc, const char *fragShaderSrc){ GLuint vertexShader; GLuint fragmentShader; GLuint programObject; GLint linked; // Load the vertex/fragment shaders vertexShader = LoadShader(GL\\_VERTEX\\_SHADER, vertShaderSrc); if (vertexShader == 0) return 0; fragmentShader = LoadShader(GL\\_FRAGMENT\\_SHADER, fragShaderSrc); if (fragmentShader == 0) { glDeleteShader(vertexShader); return 0; } // Create the program object //函数原型： // int glCreateProgram() // 如果函数调用成功将返回一个正整数作为该着色器程序的id。 programObject = glCreateProgram(); if (programObject == 0) return 0; //连接着色器对象 //函数原型： // void glAttachShader(int program, int shader) // 参数含义： // program是着色器程序容器的id； // shader是要添加的顶点或者片元shader容器的id。 glAttachShader(programObject, vertexShader); glAttachShader(programObject, fragmentShader); // Link the program //函数原型： // void glLinkProgram(int program) // 参数含义： // program是着色器程序容器的id。 glLinkProgram(programObject); // Check the link status //函数原型： // void glGetProgramiv(int program, int pname, int\\[\\] params, int offset) // 参数含义： // program是一个着色器程序的id； // pname是GL\\_LINK\\_STATUS； // param是返回值，如果一切正常返回GL\\_TRUE代，否则返回GL\\_FALSE。 glGetProgramiv(programObject, GL\\_LINK\\_STATUS, &amp;linked); if (!linked) { GLint infoLen = 0; glGetProgramiv(programObject, GL\\_INFO\\_LOG_LENGTH, &amp;infoLen); if (infoLen &gt; 1) { char* infoLog = (char*)malloc(sizeof(char) * infoLen); //在连接阶段使用glGetProgramInfoLog获取连接错误 //函数原型： // String glGetProgramInfoLog(int program) // 参数含义： // program是一个着色器程序的id。 glGetProgramInfoLog(programObject, infoLen, NULL, infoLog); GLUtils::LogMessage(&quot;Error linking program:\\\\n%s\\\\n&quot;, infoLog); free(infoLog); } glDeleteProgram(programObject); return 0; } // Free up no longer needed shader resources //函数原型： // void glDeleteShader(int shader)； // 参数含义： // shader是要被排除的顶点shader或者片元shader的id。 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); //Query //QueryActiveUniform(programObject); return programObject;} 查询统一变量 void QueryActiveUniform(GLuint programObject) { GLint maxUniformLen; GLint numUniforms; char *uniformName; GLint index; glGetProgramiv(programObject, GL\\_ACTIVE\\_UNIFORMS, &amp;numUniforms); glGetProgramiv(programObject, GL\\_ACTIVE\\_UNIFORM\\_MAX\\_LENGTH, &amp;maxUniformLen); uniformName = (char*)malloc(sizeof(char) * maxUniformLen); for (index = 0; index &lt; numUniforms; index++) { GLint size; GLenum type; GLint location; // Get the uniform info glGetActiveUniform(programObject, index, maxUniformLen, NULL, &amp;size, &amp;type, uniformName); // Get the uniform location location = glGetUniformLocation(programObject, uniformName); switch (type) { case GL_FLOAT: // break; case GL\\_FLOAT\\_VEC2: // break; case GL\\_FLOAT\\_VEC3: // break; case GL\\_FLOAT\\_VEC4: // break; case GL_INT: // break; // ... Check for all the types ... default: // Unknown type break; } }} 工程源码：CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Unity3d 优化","slug":"u3d/unity3d-e4-bc-98-e5-8c-96","date":"2017-06-01T02:49:02.000Z","updated":"2019-11-08T09:59:31.028Z","comments":true,"path":"2017/06/01/u3d/unity3d-e4-bc-98-e5-8c-96/","link":"","permalink":"http://blog.le-more.com/2017/06/01/u3d/unity3d-e4-bc-98-e5-8c-96/","excerpt":"","text":"1.引擎没有说具体的面数限制，按机器性能而定。 2.导入图形或者MESH的方法无非两种，一种是直接拷贝到文件目录下的Assets文件夹下面，Unity3d引擎会自动找到添加的文件，并且能在PROJECT面板中找到它。另一种是我们在PROJECT面板中用右键菜单，导入素材。 当然，我是用MAYA导入的，U3D引擎对于MAYA的支持还是不错的，但是也需要注意，不要用中文的目录结构，最好直接从MAYA的工程文件夹中导入，最好在导入MESH前先吧贴图文件放到相应的文件夹，或者相关文件夹的子文件夹。 在我们导入场景文件的时候，需要在导入设置中勾选创建碰撞，这样导入的场景我们就可以踩在上面了。（这跟我们添加碰撞组件是有些不同） 3. Unity3d引擎支持大多数常用的贴图，比如漫反射贴图，高光贴图，法线贴图。如此一来，它就成了一个名副其实的次时代引擎了。当然与UNREAL引擎的强大材质编辑器不同，U3D引擎主要是编辑材质的方式是使用一种专门的语言，类似于CgFX和Direct3D的语法。当然如果不是专门的图形程序员，我们只要掌握相关的SHADER的使用方法就可以了。在我们安装完U3D引擎后，系统自带的SHADER足够我们日常大多数情况下使用了。如果我们还有特殊的要求，可以去官网上下载相关的程序，然后把代码保存为 .shader 的文件，放到相应的目录底下，然后我们就有了这种SHADER。 掌握并且理解了上面我说的三点，你就可以作为一个U3D引擎的美工开始工作了。其中有几个需要我们进行深入探讨的几个方面：一是导入的MESH的要求，如何减面，UV的情况怎样，是否可以重叠UV。 二是导入的贴图规范，我们的各种贴图要达到怎样的程度才能导入，并不是直接拍了照片贴上就很有效果的，我们需要在三维软件中烘焙，之后才能导入。还有光照贴图怎么制作。 三是各种材质的应用，比如说我们最常用在皮肤上的3S材质效果，如何在U3D引擎中实现这种效果？ 至此，你可以轻松的驾驭U3D引擎的Assets部分了。 然后我们要用引擎构建关卡。好吧现在你要成为一个U3D引擎的关卡设计师，当然这里面也有很多美工要做的事情。我们不用每天对着素材模型，贴图骂娘了。 作为关卡设计师，特别是U3D的，一定要有一个GAME OBJECT的概念，在这个可爱引擎中，我们可以看到各种的元素都是由GAME OBJECT组成的，在GAME OBJECT上我们又可以添加组件在实现特定的功能，比如最简单的位移。我在第一次使用这个引擎的时候，突然兴致大发想要在场景中创建一盏灯，弄了半天都没成，后来才明白，灯光是要附着在GAME OBJECT上的。同理，声音也是要附着在这上面的。 还要有一个PREFABS得概念，就在层级菜单中的蓝色文字所代表的属性，其实就是在游戏中可以无限复制的意思，比如子弹，比如无数的需要出现的小物件儿。 类似于三维软件以及其他引擎，U3D的灯光分为那么普通的几类，电光源、方向光、自然光。了解灯光的属性和使用方法。 还有U3D引擎的物理系统。当我看到这个系统的时候我的心都开花了，一想到各种独立游戏中无敌的物理效果心里就暗爽。比如我们可以用最简单的方法做一个足球游戏。 还是做游戏好，这个引擎能做网页游戏，也可以做PC单机游戏，网络游戏，也可以做IPHONE平台的手机游戏。真是万能了！ 当然，上面很多都是初学时候的经验，下面是我后来加上的一些内容，是经过学习总结和辛苦翻译的。 让你的游戏能够顺畅的运行是成功的第一个要求。感谢UNTIY，他们通过大量的优化和调整可以让这个引擎发布的游戏运行于各种不同性能的硬件系统。下面是一个通用的优化游戏性能的方法。 总体来说：合并，合并，合并！ 如果你比较关心游戏的速度，请合并模型。最好能够把合并的模型使用同样的材质和贴图。Rendering Statistics（渲染静态网格）窗口时很有用的！ 现在的图形显卡可以很好的支持很多的多边形，但是他们他们还是有一些瓶颈的。所以如果你有一个有100个三角形的MESH，它渲染起来所需要花费的运算跟1500个面数的物体是没有多大差别的。因此最佳的渲染设置时每个模型大约1500-4000个三角面。 只有在游戏组件中的属性栏中勾选Mesh Renderer选项显卡才会渲染相应的模型，并且在场景中的空的GameObject组件是不会被渲染的。 所以再次重复，最好的导入渲染设置时合并Objects直到他们每个模型在1500个三角面面甚至更高一些，并且为整个模型使用一个材质。 如果只是把两个模型合并在一起但是不共同使用同一个材质并不会给你的图形带来一点优化。如果你想有效的合并物体，你需要保证你合并后的模型使用一个材质。（其实就是尽量减少材质球的数量） 在你合并物体的时候需要知道一件事：如果你在你的场景中用到了很多小的灯光，你可以把场景中离得很近的物体合并为一个Object。 按照上面的思路，如果一个MESH具有多个材质球，那就说明在计算机渲染的时候是要进行多重运算的。最普遍的你之所以一个MESH用多个材质的原因是因为两个材质不能使用相同的贴图。所以如果你想要优化渲染设置，你最好确定你合并的那些MESH的材质是相同的。 Unity对于向显卡导出各种多边形是很擅长的，它可以很详尽的把所有的图形导入到显卡，并且优化数据。你需要做的只是确定你的图形显示卡正常工作。而不是要调整很多手动调节的设置。 The number of Pixel Lights affecting an object heavily affects performance. 相当数量的实时灯光对于游戏速度也是有限制的。 如果你想要有一个不错的展示，并且不关心凹凸贴图和实施灯光（Bumpmapping or Pixel Lighting），可以去Edit-&gt;Render Settings…然后设置Pixel Light Coun为0.这将会给所有的Object使用顶点灯光。这将会让所有的物件在每一帧都会被渲染一次。这是一个比较极端的LOD设置，所以你的游戏就可以再比较老的图形显卡下运行了。 Pixel lights 像素灯光 如果你使用的是像素灯光，那么每个被这个灯光照射到的GameObject都会在每一帧被渲染一次。如果你合并了两个距离很远的物体，他就会增加物件的大小，然后你就会需要一些灯光来照亮这些物体。如果你的物件是分开的，灯光将不会渲染远处的物体，这将会导致模型得到多次渲染，相比较没有被合并的模型，我们并没有得到多少实惠。因此，如果你的GameObject中有很多独立物件的时候，你可以让他们离得比较远。 当渲染一个模型的时候，UNTIY如果发现很多灯光在MESH的周围，它将会找出那个是主要影响这个MSEH的灯光，在Edit-&gt;Render Settings中的设置就是用来调整有多少个灯光最终作为像素灯光有多少作为顶点灯光。 每一个灯光通过计算离MESH得距离和自己灯光强度来决定自己的重要程度。 在游戏中的某些灯光是很重要的，所以，每一个灯光都会有一个Render Mode设置，这个用来设置哪一个可以被用来设置为Force Pixel 或者 Force Vertex. 想象一下假如我们是一个驾车的游戏，你的角色在夜晚打开车灯，前面的车灯就是游戏中最重要的灯光。因此，前大灯的渲染模式将会被设置为Force Pixel 当然如果你有一个不是很重要的灯光，也是选择使用”Force Vertex”的渲染模式，这个方式也不会对游戏的速度有很大的影响的。 影子 阴影普遍运算量比较大。如果运用得当，可以让游戏画面出色，你也可以乐队相关文档。 角色建模优化 你的角色应该只被用于一个蒙皮模型渲染器。当然有时候可能需要多个蒙皮的模型，但是如果你同时用两个蒙皮来作为一个角色，它就相当于你进行了两个角色的运算量。 你同样需要保持MESH的材质数量尽可能低。一般建议身体的材质数量为2-3个，当然如果你有武器的材质，也是需要单独一个的，因为你需要换武器。 减少骨骼的数量，一般来说游戏中的骨骼数量为15-60个。骨骼越少运行速度越快，一般来说30块骨骼就可以让角色动的很舒服了。如果你不是有特殊的设置，我们强烈建议每个角色30个骨骼。 多边形的数量主要是看你对游戏的质量要求，500-6000个三角面是比较推荐的。如果你的游戏场景中将会出现多个角色，那么就要适当的降低一下多边形数量了。如果你想要在比较老的机器上运行，你需要更少的多边形数量。比如，半条命2游戏的角色通常是2500-5000个三角面。达到AAA标准的次时代游戏比如像是PS3或者XBOX360上的游戏角色通常有5000-7000个三角面。 把IK控制器和FK控制器分离，当动画导入以后，IK的节点将会烘焙到FK上，其实UNITY并不需要IK节点，你可以删除它们。 创建一个公共的骨架，这样就可以让你让不同的角色之间共享动作了。 给每一个骨骼正确的命名，方便团队工作，也方便类似于Motionbuilder的动作软件，不然你得每次指定骨骼。 优化综合的图形卡 优化模型参数 使用尽量少的面 UV接缝的数量尽可能少 烘焙灯光 烘焙灯光到光照贴图或者到顶点颜色。 MAYA具有不错的制作光照贴图的工具，UNITY可以从MAYA中导入第二个UV贴图或者顶点颜色。 制作环境的光照贴图的流程要比直接在场景中打灯光要繁琐的多，但是运行速度明显增快。 如果你使用全局光并且平滑光照贴图，可以让画面效果明显增强。 甚至次时代游戏比如战争机器始终在很多方面使用光照贴图。通常他们在场景中使用光照贴图，然后在上面放置一个动态灯光。在UNITY中也可以制作相应的光照贴图Shader.","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"优化","slug":"优化","permalink":"http://blog.le-more.com/tags/优化/"}]},{"title":"Unity 开发之---问题汇总","slug":"u3d/ar-sdk-e4-b9-8bvuforia","date":"2017-04-01T02:17:16.000Z","updated":"2019-11-08T09:59:31.009Z","comments":true,"path":"2017/04/01/u3d/ar-sdk-e4-b9-8bvuforia/","link":"","permalink":"http://blog.le-more.com/2017/04/01/u3d/ar-sdk-e4-b9-8bvuforia/","excerpt":"","text":"无法识别：参照官方提供的示例Vuforia-3-ImageTargets，实现自定义的Target时确保下面选项勾选： 如果不选中，是无法成功识别的！ Vuforia导出为iOS工程运行报错 错误信息为： /BuildRoot/Library/Caches/com.apple.xbs/Sources/Metal/Metal-85.83/ToolsLayers/Debug/MTLDebugCommandBuffer.mm:314: failed assertion `MTLRenderPassDescriptor MTLStoreActionMultisampleResolve store action requires resolve texture’ 问题原因：项目工程导出环境为Windows 10 解决办法：将项目在Mac OS X下导出不再报错 打包安装APK，报错：Failure to initialize! Your hardware does not support this application, sorry! Unity项目中导入MovieTexture资源，移动端是不支持MovieTexture的。移除后正常 还有其他原因，这个是我遇到的问题！ 打包安装APK,报错：Android解析包时出现问题Player Settings-&gt;Other Settings-&gt;设置适当的Mininum API Level 打包APK,报错：Unable to merge android manifests Player Settings-&gt;Other Settings-&gt;设置适当的Mininum API Level 以前还遇到API Level小于要合并targetSdkVersion,就是编辑器的选项最大的也不满足，搜索所有Manifest文件，修改一致！ 查看Android Debug Log 工具：\\AndroidSDK\\platform-tools\\adb.exe 命令： -s 指定过滤器 //-s 指定过滤器adb logcat -s Unity ActivityManager PackageManager dalvikvm DEBUG //如果出现error: more than one device/emulator，需要adb -s deviceName指定设备,adb devices 得到设备名 MyAndroidadb -s MyAndroid logcat -s Unity //-f 输出log到指定文件adb -s deviceName logcat -s Unity -f c:\\unity_log.txt 将 Java 代码做成 Unity 插件 参考：在 Unity 中使用 Android SDK Unity 打包Android贴图模糊 1.Edit-&gt;Player Settings-&gt;QualitySettings设置Quality Level 2.纹理属性设置（属性详情参考：Unity3D Shader学习之九—纹理） 自定义Skybox有接缝 修改纹理Wrap Mode为Clamp 设置相同的对象不碰撞 设置对象所属Layer，在Edit–Project Setting–Physics 设置Layer之间是否有相互碰撞关系 Unable to install APK to device. Please make sure the Android SDK is installed and is properly configured in the Editor! adb: error: failed to copy Package.apk: no response: Connection reset by peer 更新Android SDK Skybox //修改void Update () { float num = RenderSettings.skybox.GetFloat(&quot;_Rotation&quot;); RenderSettings.skybox.SetFloat(&quot;_Rotation&quot;, num + 0.01f);} //动态加载 资源需放到Resources目录RenderSettings.skybox = Resources.Load(skyboxName).material;RenderSettings.skybox = Resources.LoadAll(skyboxName)[0] as Material; 修改程序材质 ProceduralMaterial mat = uiObject.GetComponent().material as ProceduralMaterial; ;//mat.SetProceduralFloat(“Luminence”, 0);mat.SetProceduralFloat(“Coral_Shape_Tiling”, life + 1); mat.RebuildTextures();//mat.RebuildTexturesImmediately(); 制作天空盒 全景图创建天空盒：pano2vr 星空创建天空盒：Spacescape VR 躺着看场景，视角和正常一样（MojingSDK ） x轴旋转90度，在代码中动态设置，否则视点偏移 mojingMain = GameObject.Find(“MojingMain”);mojingMain.transform.rotation = Quaternion.Euler(90, 0, 0); 启动应用前，手机屏要朝下 Canves层次关系 设置Sort Order Vuforia 相机对焦 Vuforia应用之相机自动对焦功能 模型动画找不到，无法播放 （The animation state “xxx” could not be played because it couldn’t be found”） 选择模型-&gt;Rig-&gt;Animation Type 设置为Legacy android plugin添加权限 在Assets\\Plugins\\Android目录下创建AndroidManifest.xml文件，package要和unity设置一致。如果不知道如何创建，可以在Temp文件夹下搜索到（要打包一次后才生成），复制AndroidManifest.xml，修改添加权限即可！ 暴风魔镜SDK,程序中切成单屏，使用小米4测试，陀螺仪会卡住 设置-电池和性能-神隐模式关掉 相同的场景，显示的效果不一样 选择一个色彩空间(CHOOSING A COLOR SPACE)，场景使用不同的色彩空间Gamma 或Linear Serializable属性-&gt;Inspector中显示自定义类或结构 [System.Serializable]public class ChairColor { public Color inColor; public Color outColor;} [System.NonSerialized] 不被序列化该变量，且不显示在检视面板中。 [HideInInspector] 在检视面板中隐藏 RequireComponent 必须要有相应的组建 SerializeField 序列化域(强制序列化) ExecuteInEditMode 在Editor模式下运行 [ContextMenu] 上下文菜单 [AddComponentMenu] 添加组件菜单 VS 中的快捷键 Ctr+R,Ctr+E 属性自动生成拾取器 引入命名空间：光标移动到目标，Shilt+Alt+F10 移除不用空间：右键 -&gt; 组织 using -&gt; 移除和排序 CullMask camera.cullingMask = ~(1 &lt;&lt; x); // 渲染除去层x的所有层 camera.cullingMask &amp;= ~(1 &lt;&lt; x); // 关闭层x camera.cullingMask |= (1 &lt;&lt; x); // 打开层x camera.cullingMask = 1 &lt;&lt; x + 1 &lt;&lt; y + 1 &lt;&lt; z; // 摄像机只显示第x层,y层,z层. Ran out of trampolines of type 2 in Player Settings AOT中输入： nrgctx-trampolines=8096,nimt-trampolines=8096,ntrampolines=4048 参考：“Ran out of trampolines of type 0/1/2” 运行时间错误 UnityEngine.dll 路径 Mac:Applications/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll Win:Program Files\\Unity\\Editor\\Data\\Managed\\UnityEngine.dll VS 生成后事件 copy “$(TargetDir)*.dll” “..\\..\\bin\\“ //整个文件夹拷贝 copy “$(TargetDir)$(TargetFileName)” “..\\..\\bin\\$(TargetFileName)” //单文件拷贝 Python import xlrd 出错，需要安装xlrd模块 Python3命令：pip3 install xlrd Pyhone2命令：pip install xlrd pip位于\\Python27\\Scripts目录 Unity导出iOS支持arm64位 player settings设置Scripting Backend 为IL2CPP,Architecture选择ARM64或Universal Unity 在macOS下打开黑屏 复制正常Mac电脑下的目录 ~/资源库/Unity/Packages到有问题的电脑 Unity打开项目为空 新建立一个磁盘分区，格式为Mac OS日志扩展类型，将项目移到这个磁盘 注意Unity也需要安装（或复制）到这个磁盘 打包iOS报错：”AssemblyResolutionException: Failed to resolve assembly: ‘UnityEngine, Version=0.0.0.0, Culture=neut” 注意Unity也需要安装（或复制）到这个磁盘 ,运行这个磁盘的Unity 验证签名 jarsigner -verify -verbose -certs xxx.apk 破解 使用DisUnity拆包，DotNetReflector很简单地进行反编译，再通过dot4net进行反混淆 android-ndk-r10e-darwin-x86_64.bin 解压 更改权限，然后解压 chmod a+x android-ndk-r10e-darwin-x86_64.bin ./android-ndk-r10e-darwin-x86_64.bin","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"总结","slug":"总结","permalink":"http://blog.le-more.com/tags/总结/"}]},{"title":"iOS/macOS X使用问题汇总","slug":"ios/macos-x-e4-bd-bf-e7-94","date":"2017-03-19T02:39:43.000Z","updated":"2019-11-08T09:59:30.980Z","comments":true,"path":"2017/03/19/ios/macos-x-e4-bd-bf-e7-94/","link":"","permalink":"http://blog.le-more.com/2017/03/19/ios/macos-x-e4-bd-bf-e7-94/","excerpt":"","text":"系统清理 1.清理不用的设备备份： /Users/Max/Library/Application\\ Support/MobileSync/Backup 2.删除xCode不用的存档，日志等，小心删除个人的配置信息 /Users/Max/Library/Developer/Xcode 读写NTFS外接硬盘 Tuxera NTFS 软件 自动启动 （macOS 10.12下不可用） Mounty 软件 手动启动 “xxx”已被 macOS 使用，不能打开 ls -l 查看到文件的属性 xattr -c . 对目录下所有文件清除附加属性 “Project Name” has conflicting provisioning settings. Code Signing Identity 修改设置统一 ‘UnityDefaultViewController should be used only if unity is set to autorotate’ UnityViewControllerBaseiOS-&gt;supportedInterfaceOrientations函数注销 NSAssert 行 “Image not found” WikitudeNativeSDK 打包iOS时，报这个错误原因有： 1.如果是试用版本，不能修改Bundle Identifier(com.wikitude.unityexample) 2.将WikitudeNativeSDK.framework 加入到Embedded Binaries 设置安全中显示不明来源选项 sudo spctl –master-disable 显示 sudo spctl –master-disable 关闭 显示/隐藏文件夹 文件夹：defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder， 隐藏文件夹：defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder SVN macOS:Cornerstone macOS 运行未知来源程序，报错：程序已经损坏 执行下面命令： sudo spctl –master-disable 访问局域网共享文件夹 前往服务器：smb://192.168.0.10 android-ndk-r10e-darwin-x86_64.bin 解压 更改权限，然后解压 chmod a+x android-ndk-r10e-darwin-x86_64.bin ./android-ndk-r10e-darwin-x86_64.bin vim常用命令： :w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑 Mac 生成Public SSH 1. ssh-keygen -t rsa -b 4096 #生成 2. pbcopy &lt; ~/.ssh/id_rsa.pub #复制到剪切板 无法选择模拟器：Build Settings-&gt;Supported Platforms:iphonsos -&gt;iOS ‘Xcode 7 编译cocos2dx 报libz.dylib,libsqlite3.dylib无法打开解决办法’ Choose “Add other” Once in the file selection window do “CMD”+Shift+G (Go to folder) &amp; type /usr/lib/ From /user/lib you can find the *.dylib files","categories":[{"name":"macOS","slug":"macOS","permalink":"http://blog.le-more.com/categories/macOS/"}],"tags":[]},{"title":"Unity项目优化汇总","slug":"u3d/unity-e9-a1-b9-e7-9b-ae-e14","date":"2017-03-03T01:59:24.000Z","updated":"2019-11-08T09:59:31.026Z","comments":true,"path":"2017/03/03/u3d/unity-e9-a1-b9-e7-9b-ae-e14/","link":"","permalink":"http://blog.le-more.com/2017/03/03/u3d/unity-e9-a1-b9-e7-9b-ae-e14/","excerpt":"","text":"Unity Shader性能优化 Unity5中优化VR 应用的12个技巧 Unity3D开发VR项目优化 官网 Optimization for Mobiles （中文： 移动优化） Optimizing graphics performance （中文：优化图形性能） Introduction to Lighting and Rendering （中文：Unity 5 中的全局光照技术详解）","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"}]},{"title":"Unity5中优化VR 应用的12个技巧","slug":"u3d/unity-vr-e5-ba-94-e7-94-a8","date":"2017-03-03T01:59:01.000Z","updated":"2019-11-08T09:59:31.027Z","comments":true,"path":"2017/03/03/u3d/unity-vr-e5-ba-94-e7-94-a8/","link":"","permalink":"http://blog.le-more.com/2017/03/03/u3d/unity-vr-e5-ba-94-e7-94-a8/","excerpt":"","text":"VR应用比非VR应用需要更强的计算，性能优化是一个很重要的任务。若目标平台是像GearVR这样的手机设备，优化就更重要了。 以下是一些应该试着了解的性能指标： 每只眼睛50次绘制调用。更精确地将其称为SetPass Calls。 场景中顶点数少于50K～100K 且面数少于50～100K 。 下面是一些简单的技巧，用于满足上述要求： 静态批处理 场景中可能存在大量的静态几何体，例如墙体，椅子，灯光和从不移动的网格。在编辑器中将它们标记为静态对象。为烘焙光照贴图，请确保将其标记为静态贴图。不要让每个对象都会导致一次绘制调用，而是把对象标记为可被组合成一个网格的静态对象。 静态批处理有个关键要求：所有对象必须使用相同的材质。若静态墙带有木头材质，静态椅子带有铁材质，所有墙会被批量处理为一次绘制调用，椅子作为单独网格进行另外的绘制调用。 ** 纹理集** 如之前所说，每个材质引发一次绘制调用。直觉可能是木门和铁椅子需要使用不同的材质，由于它们的纹理不同。然而，若使用相同的着色器，就可以用纹理集为它们创建共用的材质。纹理集就是一个包含所有小纹理的大纹理。我们可以使用一个材质加载一个纹理，而非使用多个材质加载多次。每个对象可以对应到纹理集中不同坐标的一个纹理。 你可以的绘制管线中手动生成纹理集，但是Juan Sebastian的Pro Draw Call Optimizer工具非常有用。它可以生成纹理集，并且在替换新对象时不会搞混资源。 动态批处理 非静态对象可以动态批处理为一个单独的绘制调用。我曾注意到该过程大量占用CPU且每帧都在计算，但这是一个很好的优化。这只对使用相同材质且顶点数少于900的对象有效。使用纹理集为所有的动态对象创建一个材质，就可以进行简单的动态批处理啦。 ** LODs（多细节层次）** LOD组是改善性能的简便方法。使用有多个LOD的资源，并用低分辨率的几何体渲染离相机远的对象。Unity可以自动随着相机临近在各个LOD间转换。 填充率，过度绘制及裁剪 这是个值得关注的话题。减少过度绘制，最远的对象最先绘制，随后上面依次绘制更近的对象。这个在平均分辨率为1080P的PC显示器上没什么问题，但对于有极高分辨率的VR和手机设备来说问题就比较严重。大量的过度绘制组成了大量像素从而影响填充率。纹理填充率是限制GPU性能的关键。 一些解决方案提供了遮挡剔除和视锥体剔除。视锥体剔除是指不渲染位于相机视锥体外的对象。不渲染看不到的对象！遮挡剔除是剔除被其它对象挡住的对象。比如，门后的房间可以被整体剔除。默认情况下，遮挡剔除是针对整个场景的，如果关卡设计得当甚至可以让你剔除游戏中的整个关卡。 LOD组当然也可以裁剪离场景很远的对象，进一步使填充率最小化。 关卡设计 若游戏涉及到玩家从一个房间移到另一个房间，简单的解决方法是一个关卡包含整个游戏。缺点在于内存的消耗。尽管每个房间中的各对象和材质都不可见，但其仍会被加载到内存中。将每个房间放置于单独的关卡中，在代码中智能的异步加载关卡可以改善性能。 ** 异步加载** 在玩家即将进入下个房间之前，加载下一个关卡。不要使用Application.LoadLevel()同步加载，因为加载时会导致游戏挂起。由于头盔的跟踪是实时的，这会导致眩晕，对玩家来说体验太糟糕。 使用Application.LoadLevelAsync()来加载关卡。你可以在Oculus Mobile SDK BlockSplosion例子的StartupSample.cs中找到使用方法。 光照烘焙 关掉实时阴影！接受动态阴影的对象不会被批处理，这会导致严重的绘制调用。 在PC机上，使用单个实时方向光就可以实现很好的动态阴影效果。对于大多数现代的PC都可以提供逼真的逐像素阴影。然而在移动平台，你需要烘焙光照而不是实时阴影，以高分辨率烘焙光照结合软硬阴影实现类似的效果。 阴影 尤其是为了高性能的手机体验，对于3D对象的阴影处理要使用传统技巧。可以通过在对象下放置一个简单的带有模糊阴影纹理的2D四边形模拟半真实的阴影。 VR小提示：不要尝试使用阴影缓冲。预处理光照环境并在角色下方使用老套的模糊阴影纹理处理方法。 例如，你Hold不住像《GTA V》中这种在高性能PC机上使用的实时动态阴影。 用如下方法代替：这是一张2002年《GTA Vice City》的游戏截图，你可以在Playstation 2上使用阴影斑点来提供阴影效果的幻觉。 ** Light Probes（光照探针）** 当使用烘培光照时，静态对象效果不错但动态对象还有不妥。对于动态对象可以使用光照探针来模拟简单的动态光照。 光照探针是烘焙好的立方贴图，存储了场景中多个点直接、间接甚至自发光的信息。当动态对象移动时，它在光照探测器附近进行插值获取近似某个点的光照。这是一种在动态对象上模拟实时光照的简便办法，而不用成本高昂的实时光照。 Unity的文档解释了光照探针要如何放置。 ** 避免使用透明和多个材质的对象** 类似玻璃这种使用透明着色器的对象很消耗性能。使墙壁看起来更逼真的常见做法是，用一个带有灰尘或锈斑纹理的透明材质，加上另一个单独的基本漫射材质。多材质的alpha混合是很消耗性能的，每个材质都会增加一次绘制调用！但是请注意：多个纹理并没有问题，使用多个材质才耗费性能。使用一个材质结合着色器来实现多纹理的alpha混合，而非使用多个单独材质。 蒙皮网格渲染器 蒙皮网格渲染器常用于角色身上，它带有动画关节，可以使用物理（布娃娃）变或自定义动画（走，跳等）来实现逼真的网格变形。 坏消息是：蒙皮网格渲染器不支持批处理。对于每只眼睛，场景中各角色都会进行多次绘制调用。目前还没什么解决方案。 ** 扩展阅读** 推荐大家观看Oculus大会上关于GearVR的开发演讲。 原文链接：http://dshankar.svbtle.com/performance-optimization-for-vr-apps 作者：DARSHAN SHANKAR","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"vr","slug":"vr","permalink":"http://blog.le-more.com/tags/vr/"}]},{"title":"Unity3D开发VR项目优化","slug":"u3d/unity3d-e5-bc-80-e5-8f-91","date":"2017-03-03T01:58:18.000Z","updated":"2019-11-08T09:59:31.028Z","comments":true,"path":"2017/03/03/u3d/unity3d-e5-bc-80-e5-8f-91/","link":"","permalink":"http://blog.le-more.com/2017/03/03/u3d/unity3d-e5-bc-80-e5-8f-91/","excerpt":"","text":"对于VR应用来说，如果想要让用户获得好的用户体验，特别是免除恶心眩晕的困扰，在VR开发中进行优化是必不可少的，惟其如此才能达到我们期望的游戏运行帧速。和其它平台上的开发不同，对VR应用的优化应该在项目启动的前期就开始，而且应该贯穿始终，而不是像传统项目那样把优化的工作留到最后去做。此外，在目标设备上进行实际测试也是非常有必要的。 相比非VR项目来说，VR项目是非常消耗计算资源的，其主要原因就是所有的画面都必须为每只眼睛单独渲染一次。因此，在开发VR应用的过程中需要时刻想到这些问题。如果我们能在开启之前就想到这些问题，那么会节省大量的时间。 对于移动VR来说，优化工作就显得尤为重要。不仅仅是因为要运行VR应用，还因为移动设备的运算性能和散热性相比桌面电脑来说都要差上不少。 考虑到实现目标帧速是如此重要，所有的优化方法都必须考虑在内。我们需要在所有可能的地方优化项目代码，关于优化代码，可以参考Unity的Unity - Manual: Optimizing Scripts 。 Oculus的相关资源 在Oculus的官方网站上提供了大量关于如何优化VR应用的信息。 Unity Editor优化工具 Unity提供了一系列有用的工具和方法，可以帮助我们来优化VR内容。 The Profiler profiler可以帮助开发者了解游戏中渲染每一帧所耗费的时间，并将其分为CPU、渲染、内存、音频、物理引擎和网络。学会如何使用Profiler对于检测游戏运行性能是至关重要的。 Frame Debugger 使用Frame Debugger可以让我们冻结某一帧，然后通过单独的draw调用来查看场景是如何生成的，然后来发现需要进行优化的地方。在这个过程中，我们可能会发现渲染了一些不必要进行渲染的对象，这样可以大幅度降低每帧的draw 调用。 VR应用优化的基础知识 考虑到对应用进行优化是个庞大的话题，对不同的平台有不同的要求，我们也提供了延伸阅读的相关信息。 通常来收，现有应用的优化技巧对VR开发也是适用的，因此这些知识也用得上。 Geometry（几何体） 在VR应用我们应尽量删除几何体中用户永远也不会注意到的面。我们没必要在场景中渲染出用户根本看不到的东西。比如，如果某个杯子背靠着墙壁，那么用户可能永远也不会看到它的背面，因此我们可以不必显示模型中的这些面。 对于3D美术设计人员，应该尽可能的简化模型设计。根据目标平台的不同，我们可能会需要查看纹理细节，或许还会希望查看视差映射贴图，和曲面细分。虽然这种方法可能会影响游戏性能，也可能对特定的平台根本无法使用。 Overdraw Overdraw可以让开发者查看哪些对象绘制在其它对象的顶部，但其实是在浪费GPU时间。我们应尽可能的减少使用overdraw。我们可以使用Scene View Control Bar来查看场景视图中的overdraw。 正常的着色视图如下： 启用Overdraw之后的着色视图： Level of Detail(LOD)细节层次 通过使用LOD，可以随着物体和摄像机之间的距离来减少物体渲染的三角形数目。除非所有的物体都离摄像机同样远，否则我们都可以使用LOD来减少硬件的负担。我们可以添加一个LOD组件，然后对远离摄像机的物体提供低精度模型。 使用Simplygon可以自动完成对大多数asset的LOD预处理。 Draw Call 批处理 我们应尽可能的通过Static Batching和Dynamic Batching来实现Draw Call 批处理。Draw Call批处理可以极大的提升游戏性能。具体请参考Unity官方指南的Draw Call Batching。 Light mapping 尽可能减少动态光照，尽量多使用光照烘焙，尽量避免实时阴影。 关于这部分的具体内容，请参考Unity官方的 Lighting and Rendering（Unity 5）。 Light Probes 使用Light probes可以让我们对场景中的光照点取样，然后应用到动态物体上。使用light probes通常更快，而且也能产生绝佳的视觉效果。 Reflection Probes Reflection probes可以保存其周围的立方图，从而实现真实反射效果，而且也会对游戏性能产生影响。需要注意的是，目前在VR中使用实时reflection probes会导致游戏性能大幅降低。 Occlusion Culling Occlusion Culling（遮挡剔除）可以避免渲染那些不可见的物体。例如，如果玩家正处于某个房间中，而另外一个房间的门是关闭的，那么对玩家来说另外一个房间中的所有物体都是不可见的，也就完全没必要进行渲染。 根据项目和目标平台的不同，我们可能会希望实现Occlusion Culling，从而大幅提升游戏性能。 下图是一个frustum culling（视锥体剔除）的示例： 下图是Occlusion Culling（遮挡剔除）的示例： Anti-Aliasing（抗锯齿） 抗锯齿对VR应用来说非常重要，因为使用这种技术可以让图像的边缘显得更加平滑，并减少毛边线下。如果我们在项目中使用Forward Rendering，那么就需要在Quality Setting中启用MSAA。而对于Gear VR项目来说，任何时候我们都需要启用该选项。 当然，在使用Deferred Rendering时我们无法启用MSAA，此时需要启用AntiAliasing作为后处理特效（所谓的“反走样”），或者考虑使用SMAA。 这里提供了一个相关的示例。 GitHub - Chman/SMAA-Unity: A highly customizable implementation of Subpixel Morphological Antialiasing for Unity3D. Textures 通常来说，在VR项目中我们应尽可能的使用Texture Atlasing（纹理贴图），以减少单独纹理和材质的使用量。 为简化和加速这个过程，我们可以考虑使用MeshBaker来烘焙游戏中所使用的纹理、模型和材质。 在Oculus Connect 2开发者大会上，来自Turbo Button的Holden曾分享过优化应用以及使用MeshBaker的相关经验。 有一点需要注意的是，在VR项目中normal maps看起来效果并不好，因此我们应该避免使用。 Shaders 在VR项目中，我们应尽可能使用最基本的shader。在Gear VR上，我们可能会需要考虑使用不那么消耗资源的Mobile&gt;Unlit(Supports Lightmap) shader，并使用lightmap来给场景提供光照。 Fullscreen Effects（全屏特效） 对VR项目来说Fullscreen Effects过于奢侈，因此我们应在Gear VR项目中完全避免使用。 Quality Settings Quality Settings中的选项将直接影响项目的视觉效果。通过调整这些属性，可以某种程度的提升游戏性能，当然代价就是牺牲了部分视觉效果。 RenderScale 调整VRSetting.renderScale可以牺牲画质换取更高的游戏性能。具体可以参考本系列教程的第二篇。 Asynchronous Loading 为了提升性能，我们可以考虑把游戏场景分成诸多小的场景。不过这样做需要注意的是，在加载下一个场景的内容时，应该避免锁定对头部的跟踪，以免产生nausea恶心现象。 为避免出现这种情况，我们可以考虑设计一个允许头部运动跟踪的加载场景，让游戏异步加载新的场景，具体的方法是使用SceneManager.LoadSceneAsync。 示例场景中所用到的优化技巧 为了让用户在DK2和Gear VR上面获得更好的体验，我们在示例场景中使用了一系列的优化技巧。 考虑到我们需要让同一个项目支持两个凭条，因此需要考虑对最低端性能设备的支持，也就是Gear VR。我们选择了低多边形的艺术风格，并使用少量的基本色彩，让物体从环境中脱颖而出。 在使用Forward Rendering时，我们需要在Edit &gt; Project Settings &gt; Quality Settings 中启用4x MSAA，以便获得更好的视觉效果： 让我们简单看看这些场景中所使用的优化技术： Menu 场景中使用的优化技术： 跟该项目中所有的场景一样，Menu场景中使用了低多边形的美术资源，而且避免使用实时光照。 我们在菜单面板上使用了定制的shader，名为SeparableAlpha，可以为一系列的图像定义独立的alpha通道。这就意味着不是每一帧都需要自己的alpha通道。这样做可以节省文件大小，并去掉某些贴图。 Flyer 场景中使用的优化技术： 我们在Flyer场景中动态启用了fog，从而避免让物体突然跳进玩家的视野，并缩短了视距，这也就意味着减少了所需渲染的物体数量。 场景中陨石的顶点数较低，从而可以通过Dynamic Batching来减少draw call。 为了重用某些物体，我们创建了一个对象池，以处理激光、陨石和星门这样的对象。通过这种方式，可以避免昂贵的初始化调用。 对于Flyer场景中的飞船纹理我们同样做了优化，通过使用Detail Map slot中的次级UV 通道，可以只需使用更少的色块。这样一来我们就可以缩减总体的纹理大小。 ** Maze场景中的优化技术** Maze场景中使用了lightmap，从而在运行时获得更好的性能，特别是在Gear VR上。除此之外，该场景没有任何的实时光照和特效。 Shooter180(Target Gallery)和Shooter360(Target Arena)中的场景优化 和其它游戏一样，我们在这些场景中沿用了低多边形风格，并为目标对象创建了object pooling。同时我们使用了低顶点数以启用Dymaic Batching。 看完本篇教程，大家对VR游戏优化应该有了整体的印象，也大概了解了我们应如何使用Unity内置的工具来分析游戏性能，以及如何通过某些技巧来获得更好的游戏表现。 转自：Unity VR游戏开发干货教程：优化VR体验","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"vr","slug":"vr","permalink":"http://blog.le-more.com/tags/vr/"}]},{"title":"经济学必看书箱","slug":"other/e7-bb-8f-e6-b5-8e-e6","date":"2017-02-22T02:00:31.000Z","updated":"2019-11-08T09:59:30.995Z","comments":true,"path":"2017/02/22/other/e7-bb-8f-e6-b5-8e-e6/","link":"","permalink":"http://blog.le-more.com/2017/02/22/other/e7-bb-8f-e6-b5-8e-e6/","excerpt":"","text":"每天忙碌地工作是为了什么？如何保护好我们辛苦劳动所得？如何透明现象看本质？一切都在书中，有了理论结合实际，也许才能更好的过这一生！ 转自：史上最全经济学教材类书单：由浅入深，由深到精 一、入门教材： 1、曼昆《经济学原理》上下册，88元。梁小民教授翻译。曼昆为哈佛高才生，天才横溢，属新古典凯恩斯主义学派，研究范围偏重宏观经济分析。 该书为大学一年级学生而写，主要特点是行文简单、说理浅显、语言有趣。界面相当友好，引用大量的案例和报刊文摘，与生活极其贴近，诸如美联储为何存在，如何运作，Greenspan 如何降息以应付经济低迷等措施背后的经济学道理。该书几乎没有用到数学，而且自创归纳出“经济学10大原理”，为初学者解说，极其便利完全没有接触过经济学的人阅读。学此书，可了解经济学的基本思维，常用的基本原理，用于看待生活中的经济现象。可知经济学之功用及有趣，远超一般想象之外。推荐入门首选阅读。目前国内已经有某些教授依据此书编著《西方经济学》教材，在书中出现“经济学10大原理”一词，一眼便可看出是抄袭而来。 2、 萨缪尔森《经济学》(Economics) 萨缪尔森，新古典综合学派的代表人物，1970年成为第一个荣获诺贝尔经济学奖的美国人。研究范围横跨经济学、统计学和数学多个领域，对政治经济学、部门经济学和技术经济学有独到的见解。目前经济学各种教科书，所使用的分析框架及分析方法，多采用由他1947年的《微观经济分析》发展糅合凯恩斯主义和传统微观经济学而成的“新古典综合学派”理论框架。他一直热衷于把数学工具运用于静态均衡和动态过程的分析，以物理学和数学论证推理方式研究经济。目前经济学理论数学化大行其道，此翁实始作俑者。 《经济学》由美国麦格劳——希尔图公司1948年初版。现已出第16版，通行全世界。国内50年代由高鸿业教授根据英文第10版翻译，商务印书馆于1981年出版。市面之16版，是和诺德豪斯合写，由萧深教授翻译，并拆为《宏观经济学》和《微观经济学》两个单行本出版。 全书结构宏伟，篇幅巨大。可谓博大精深。渗透老萨数十年经济学见解。字里行间，三言两语，每有深意。其中诸如“热情的心，冷静的头脑”、“相关未必因果”等言语，可谓经济学之《老子》。读完该书，可了解经济学所探讨问题在经济学体系中之位置及分析框架，对经济学有一个完备之认识框架。知识庞杂，有一体系框架，则适宜以后更进一步学 习。学之愈深，愈知此框架之重要。尽管该框架在宏观经济学的微观基础方面仍有断层，但不失为一个好框架。此书国内有机工版发行之英文版。建议直接阅读英文版。 3、斯蒂格利姿《经济学》及系列辅助教材。斯蒂格利姿在信息经济学成就甚高，此书可作为前二者的补充，前二者所涉及经济学内容主要是以价格理论及边际分析为基础，不包括不对称信息经济学、不确定性分析部分。斯蒂格利姿之《经济学》可填充前二者之空白。 尽管三位作者政策倾向不同，但教材体现凯恩斯主义的特征稍多一点，总体上讲，教材相当客观和公允。很适宜做入门教材。 4、《经济学、原理、问题与政策》及《经济学原理与问题》、〈经济学案例〉、〈经济学小品〉、《经济学悖论》、〈社会问题经济学〉等。此类书之特点是先提问题，再论原理，主要是针对社会习见问题，逐步解释原理，水平、内容大多较好，唯缺乏体系与框架，适宜略懂经济学者补充学习。 5、国内老师自行编写之《西方经济学》教材：目前国内各大学自己编写的直接冠以《西方经济学》或〈经济学原理〉均属入门教材。如高鸿业、历以宁、宋承先、梁小民、朱锡庆、尹伯成、司春林等等。然皆远逊外国教材。 说明： 1、越基础性之教材越需深入浅出，将复杂抽象的道理联系到生活实际上，才讲的透彻，又能调起初学者之兴趣。国外教材，形成一竞争市场，多极高明之著作，教材之撰写也充分考虑学生学习之便利，如曼昆之教材，以完全不带数学式而著称，又或更新换版本极快，以及时吸收新知识，如斯蒂格利姿《经济学》之增加不对称信息部分。低手所写教材自然被市场淘汰。故市面之基础教材，多为大高手所写就。 2、国内教材，建国以来，除商务系列丛书初期之100年前古典学派部分，政府同意翻译以作为马克思批判之反面教材得以出版外，80年代以前，近50年间国外经济学研究学问之成就，国人皆不得见。80年代末期，邹至庄先生力倡西方经济学，邓大人首肯之后，国内始渐有〈西方经济学〉之类教材出现。此类教材，多为新出道之老师，为进阶升职，凑出版物之数而编抄西人著作而成，机制所限，不敢添加“反动”之知识，又无竞争机制，购买者多为其听课学生。故质量甚差，若非特殊目的如考研指定者，慎勿购买。 3、按经济学有入门低、中级、高级之分。高级乃指其运用之数学工具及阐述观点之纷争更多而言，并非此学问高人一等。一如高等数学未必高初等数学一等之意。越是高级，则越多分歧，也越追求数理逻辑之严谨，反不如低级来的实用。初级的入门教材一般是针对初学者，所以大多举案例和现象，加以文字解释，偶尔插加二维图案，高级教材注重数理逻辑，而二维图案及文字已难以表达、解决所说明之问题，故多用数学证明或代数方程，夹杂现代数学工具。中级教材则介乎其中，界定甚为模糊。教材难度不同，跨度也相差很大。 二、中级微观教材 中级教材一般以微观、宏观两科为主，兼修其他应用科目。传统经济学，本无宏观、微观之分，自凯恩斯针对名义变量进行宏观经济分析之后，始有宏观一科。故历来次序，先修微观，再修宏观，后及其他。 微观经济学为各科之基础。其分析，乃基于马歇尔的一般均衡分析及边际效用学派之边际分析，而后由萨谬而森发展数学方法及框架而成，涵盖范围甚广，大致包括： 基础部分：传统厂商理论（技术、利润、成本）、传统消费者理论（效用、偏好、选择、需求）、局部均衡理论（完全竞争市场之稳定性）、一般均衡理论（福利经济学二大定理、交换方框图） 分支部分：寡占市场理论（寡头、定价、市场细分）、博奕论（纯策略均衡、混合博奕、广延型结构、厂商博奕、颤抖的手）、公共物品理论（公共物品、税收制度设计、投票、外部效应）、不确定性经济学（风险、博采、保险、投资）、信息经济学（不对称信息、逆向选择、信号）、激励理论（委托-代理理论、契约理论）、法和经济学（制度经济学、企业性质分析、法律）、拍卖理论（拍卖机制设计）、匹配理论等。 学习者可根据上述容，与教材所列提纲比较，则可知教材侧重点之所在. 6、《管理经济学》，有版本数种，特点各不相同。此类教材多为mba系列教材。其目的针对生产过程决策而设，故与经济学之中级微观教材相较而言，减少少量分支部分理论，增加回归分析及计量统计部分。目前数种版本中，以人大版〈工商管理经典译从〉难度最低。机工版哈耶所写之〈管理经济学 -战略与决策〉与标准中级教材难度大致相当，内容也接近。唯其中也已采用函数表达式。机工版莫瑞斯（有英文版及中文版，中文为陈章武所译）〈管理经济学〉难度最高，其侧重内容与中级教材大不相同，除回归分析已采用大量数据，要求建立模型，内容接近计量预测外，内容涉及对偶理论、不同代替效应之图解，附录采用微分法，难度较高。此类书籍，侧重经济学中与管理交叉管理。 7、平狄克《微观经济学》。人大版，此书乃标准中级微观经济学教材。在美国多个大学供mba采用，国内英文版有清华版，中文版有人大版。此书内容适中，主题广泛，均是各部分理论之要点，不旁及其他分歧内容，其中定价部分较为详细。图形清晰，语言流畅。所采用数学工具甚浅，有函数但不涉及微分，只用差值。曲线只用标准严格凹性曲线，不及拟凹部分、线性仿射内容，成本函数也均为线性。建议此书应通读，可作进阶之用。 8、曼斯非尔特《微观经济学》人大版，内容、难度、书价与平狄克相仿，唯编排次序不同。体系稍显庞杂，不如平狄克之明晰，然也为一国外通行教材。若修习平狄克有不明之处，则可先参照此教材或先修学其他国内出版之书籍。如北大系列教材之周惠中〈微观经济学〉，北大版朱善利之《微观经济学》等。此书不属必读。 9、《国外经济学教材库》系列之《应用微观经济学》，32开，经济科学出版社。此书有大量案例及微观经济原理之运用，所用数学甚少，读此书，可补充平狄克教材之案例。加深对经济学之了解。 10、〈微观经济学: 现代观点〉(Intermediate microeconomics)[美] 范里安 (Varian, Hal R.)著,费方域翻译。据美国W.W.诺顿图书公司 1990年版译出,三联版。此书是极规范之经济学专业的中级微观教材。美国MIT，哈佛、伯克利经济学本科指定教材。32开，800多页。易懂而深刻。本书为第二版，内容除论述了市场、消费者偏好、需求、技术、利润、生产等问题,还增加了两章, 分别论述了要素供给和信息经济等。内容上相当关注技术细节问题，比平狄克要更深一些。范里安微观经济学与数学造诣极深。然此书乃其为学生所写之中级教材，刻意避免数学之应用，大部分数学推导放于附录，微分运用相当少，适宜学完平狄克后重点阅读。可作平狄克中各部分理论内容之拓展。 三、中级宏观教材 若无意进一步学习高级微观经济学，则可同时学习宏观经济学。微观的特点是精深，宏观则是驳杂。因为宏观流派很多，观点各不相同。 11、《宏观经济学》曼昆，人大版。中文翻译。此书秉承曼昆〈经济学原理〉之优点，以简单，浅显为特点。虽只有很少量的数学，但对原理及内容均提炼得甚为简洁。前半部分写得相当清晰。可读完萨谬而森《经济学》并略懂一点微观后直接学习。适宜一个循环学习，即以书入手，修完《全球视角》后，再回头重修此书，有提纲挈领之用。缺点是作者似乎限于门户之见，对真实周期学派、奥地利学派等其他学派提得很少。建议阅读。 12、《宏观经济学》多恩布什。人大版中文翻译，东北财大有影印英文版。此书是标准的中级宏观教材，属正统教材。体系清楚，描述准确，通行于美国各大学多年。采用凯恩斯IS-LM体系为框架，对各个流派评价及描述相当公平。推荐必读。 13、《宏观经济学》人大版，中文翻译。罗伯特霍尔，整本书显得有点凌乱，适宜读过其他中级宏观再做印证之用，内容比上述两本教材略深。不属必读范围。 14、《宏观经济学》巴罗。清华，影印英文版。巴罗宏观经济学造诣很深，主要研究领域在经济增长理论。但写的书却销路很差。学这本书可作为对上述教材所属凯恩斯学派的一个补充。不属必读范围。 15、《全球视角的宏观经济学》三联版杰佛里萨克斯，32开，1000页。萨克斯成功处理了南美高通货膨胀的问题，但书一样写的相当好，整本书注意细节而有条理。很适宜读完多恩布什《宏观经济学》后进一步阅读。以拓展知识。上述5种教材所用符号各不相同，对学习者实在甚为不便。 16、《国际经济学》 保罗克鲁格曼，今日之宏观经济学，已很难讨论封闭的宏观经济，此书可谓进一步拓展的宏观经济学，包括国际贸易和国际金融两个部分，渗透克鲁格曼的经济思想，所采用框架为AS-AD框架，可作IS-LM框架的补充。推荐阅读。 17、《现代宏观经济学发展与反思》及《现代宏观经济学指南 -各思想流派分析》及《与经济学大师对话》此系列三册，前两册为商务版。此书乃对各不同流派经济学大师的采访和评论，对各个流派的异同可以有清楚的了解，而且是直面经济学大师，可以看到各个大师之间彼此的观点不同，甚至成见立场，互相抨击之处，实在有趣。推荐阅读。 四、其他教材 18、人大版《经济科学译丛》系列之其他大多数教材：《经济思想史》、《财政学》、《公共部门经济学》、《人事经济学》、《金融学》（博迪）、《投资学》、《货币银行学》（米十金）等等实务应用之科目。适当补充阅读〈公共选择理论〉、奥地利学派、哈耶克、剑桥之争、非瓦尔拉斯均衡分析、等等内容。 19、三联丛书黄皮书系列，其中显要者如《公共经济学》(Lectures on public economics)（阿特金森(Atkinson, Anthony B.) [美] 斯蒂格里茨(Stiglitz, Joseph E.)著）、〈政治与市场: 世界的政治—经济制度》、《财产权利与制度变迁: 产权学派与新制度学派译文集》、《经济史中的结构与变迁》、《货币、银行与经济》(Money, Banking, and the Economy)〔美国〕托马斯·梅耶(Thomas Mayer)、〈法和经济学〉等等。可对经济学之应用领域获得一个深刻视角。三联丛书，推荐全部阅读。 20、张五常《卖橘者言》、《佃农理论》、《经济解释》。张老先生近年是国内焦点所在，也写了几本〈随笔〉，发表不少演讲，大体而言，〈随笔〉不堪一读，其中论书法、摄影部分，不关主旨，且水平甚低，多属偏颇之见，今不论之。唯上述专著中之〈佃农理论〉，见解独到，尤有过人之处。建议修完中级微观后仔细阅读。《经济解释》则为论文集，然其中也有不少过激之言论及偏见，不可以教材视之。其中“合约理论”部分，可以一读。论“共产主义”部分，则未必有理。 21、杨小凯〈经济学原理〉〈新兴超边际古典经济学〉，杨先生气魄甚大，欲以一己之力重写传统经济学体系，与汪丁丁先生有异曲同工之妙。可谓经济学之异端，读之可开阔视野。推荐阅读。 22、〈波斯纳文集〉苏力翻译。老先生以法学专才，写〈法之经济学分析〉，实一极高明之人士，于此不可不提。推荐阅读。 23、商务丛书《汉译世界名著》系列：此丛书系列，自二十世纪初商务王云五先生主持，与是事者不计其数，除文革中断十余年外，每年陆续出版，涵盖哲学（红皮）、历史（黄皮）、政治（绿皮）、经济（蓝皮）、语言学、人类学（未成），所翻译者，非经典不收，皆大师之精华，所主持翻译之人，多博学鸿儒或一代大师。单经济一门，翻译之著作，至今已近百种。百年间，传播知识无数，可谓功德无量。读完蓝皮经济类之全部，则可通晓经济学之来龙去脉。 至此，无意于经济学一门谋生者，已然足够。然上述书籍，常人阅读，少者耗时约需1、2年以上。多者3、5年。且其中论著，多高明之作，或有一读再读之需，而读完，也或有“屠龙之技”之感也未之定，一笑！ 五、数学工具： 即所谓数理经济学一科。若数学水平较高，有意进一步玩弄经济学之数学智力游戏，则可参读以下数学工具：中国大学本科考研究生之数学三（高数、线性代数、概率论与数理统计）为必修之基础课，其他之数学工具则包括拓扑学初步（凸集、凹集、微分方程稳定性）、线性规划（代数理论、几何理论、对偶理论）、非线性规划（不等式约束规划）、变分法（欧拉方程、泛函函数、收敛问题、可变端点、横截条件、勒让得必要条件、相图分析）、最优控制理论（最大值原理、汉密尔顿函数）、连续时间优化规划、离散时间优化规划（不动点性质、值函数）、时间序列分析、非线性混沌系统、随机变量等等。 24、 《经济学中的数学》（入门水平） 25、 蒋中一《数理经济学基础》（基础水平） 26、 《动态优化基础》（进阶水平） 27、 高山成（takayama）《经济学中的优化方法》（推荐阅读） 28、 龚六堂《经济学中的优化方法》（推荐阅读） 29、 《经济学中的动态递归方法》（推荐阅读） 30、 〈数理经济学手册〉人大版（重点阅读） 六、中高级微观经济学： 下文书籍，未必尽是高明著作，然国内此类教材甚少，下述书籍，聊胜于无。 31、平新乔的《微观经济学18讲》，北大出版。内容属于中高级微观经济学，涉及微观领域较多，引入大量的数学运算，除文字内容外，强调逻辑推理。惟书中有不少印刷错误，且理论内容跳跃太快，不利学习理解，数学运用庞杂，不够明快清晰。在国内中高级教材中属中上之作，接近国外大学本科高年级水平。最大的优点是书后付有大量需要运算的习题，均需花时间读书和思考才能解决，很适宜学习训练。对从中级到高级过渡有帮助。不属必读范围。 32、张定胜《高级微观经济学》。武大出版。此书属于中高级内容，因涉及主题较少，故比平新乔之〈18讲〉显得清晰。适宜找不到其他中高级教材，而高级教材又甚困难，可以此书做过渡。 33、 Nicholson &lt; Microeconomic Theory&gt;&gt;。国内中文翻译出版。此书微积分运用、数学运算简洁明晰，全书难度、体系一致，排版清楚、内容重点突出，主题有深度，实为一极佳之中高级教材。书后之参考书目适宜进一步学习参考，为中级教材之中，最适宜和高级教材接轨者，唯书价稍贵，习题难度不深，习题量稍显不足。此书似乎出版发行量不多 ，除北大、复旦等处书店有少量可见外，其他大学及城市似甚少见。推荐阅读。 34、蒋殿春《高级微观经济学》，经济管理出版社。此书主题基础部分已达高级水平，难度甚大。至博奕论以后部分，则难度甚浅。或与日本经济学之教授方法有关。对传统的价格理论的数学描述相当清楚。数学证明部分清楚。推荐阅读。 35、张维迎〈高级微观经济学〉，此书张教授5、6年前在香港做访问学者时已准备出版，张五常之论著中，多处注释引自此教材，多种丛书翘首以待，均将此书名印于丛书之中，以待出版。然数年一去悠悠，至今未见面世。张教授微观造诣甚深，想来此书必也不错。估列于此处，他日或可望出版，若有见张教授者，也可代问此书出版之日。呵呵。 36、范里安《高级微观经济学》经济管理出版社。这是范里安在《微观经济学 -现代观点》的基础上的标准高级教材。每一章均相当简短但精要。阅读时需要对中级教材有比较深入的学习。但翻译质量不佳。建议直接读英文版。接近研究生一年级水平。推荐阅读。 37、武康平《高级微观经济学》，清华版。进一步学习数理经济学之用。不属于必读范围。 38、《微观经济学》《microeconomics theory》andrew.mas-colell Green等，社科院，中文版，北大翻译。110元。经典中的经典目前所见，顶级教材，研究生一年级水平。推荐阅读。 七、高级宏观经济学： 39、 《高级宏观经济学》戴维 罗默。商务版。推荐阅读 40、 布兰查德《高级宏观经济学》 41、 萨金特《动态宏观经济理论》 42、 龚六堂《高级宏观经济学》、《经济增长理论》。推荐阅读 八、其他教材： 43、《计量经济学》、《数理经济学》、《数量经济学》、《经济增长理论》、《金融经济学》《产业组织理论》、（泰勒尔）。属于研究生初级教材。 44、中国社会科学文献出版社《哈佛剑桥经济学著作译丛》：《经济理论的进展》（上下）、《公共选择理论》、《治理机制》、《不确定性与信息分析》、《经济学中的制度》推荐全部阅读。 45、社会科学出版社〈国外经济学名著丛书〉系列：《企业经济学》、《农业发展的国际分析》（速水右次郎）、《同意的计算》（布坎南）、《货币数量论研究》（佛里德曼）推荐全部阅读。 46、经济科学出版社《国外经济学教材库》系列：此系列水平介于本科与研究生之间，若学完上述其他教材，此系列可不必阅读。聊记于此。 47、邹恒甫主编：〈金融丛书系列〉：以让拉丰〈激励理论〉为最高水平，其他尚可。 48、中国社会科学出版社《当代经济学教科书译丛》系列。 （转载请标注扑克投资家，微信号：puoketrader）","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"程序员必看书籍","slug":"other/e7-a8-8b-e5-ba-8f-e5","date":"2017-02-20T02:37:38.000Z","updated":"2019-11-08T09:59:30.995Z","comments":true,"path":"2017/02/20/other/e7-a8-8b-e5-ba-8f-e5/","link":"","permalink":"http://blog.le-more.com/2017/02/20/other/e7-a8-8b-e5-ba-8f-e5/","excerpt":"","text":"计算机程序的构造和解释SICP (Structure and Interpretation of Computer Programs) 深入理解计算机系统 代码大全2 人件 人月神话 软件随想录 算法导论（麻省理工学院出版社） 离散数学及其应用 设计模式 编程之美 黑客与画家 编程珠玑 The Little Schemer Simply Scheme_Introducing_Computer_Science C++ Prime Effective C++ TCP/IP详解 Unix 编程艺术 技术的本质 软件随想录 计算机程序设计艺术 职业篇：程序员的自我修养,程序员修炼之道,高效能程序员的修炼 《精神分析引论》弗洛伊德 《失控》《科技想要什么》《技术元素》凯文凯利 程序开发心理学 天地一沙鸥 搞定：无压力工作的艺术 转自： 【福利】成为专业程序员路上用到的各种优秀资料、神器及框架","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"TCP连接建立与释放","slug":"server/tcp-e8-bf-9e-e6-8e-a5-e5","date":"2017-02-07T09:43:09.000Z","updated":"2019-11-08T09:59:30.999Z","comments":true,"path":"2017/02/07/server/tcp-e8-bf-9e-e6-8e-a5-e5/","link":"","permalink":"http://blog.le-more.com/2017/02/07/server/tcp-e8-bf-9e-e6-8e-a5-e5/","excerpt":"","text":"TCP是一个面向连接的传输层协议，所以无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条传输连接。 一、TCP首部 TCP数据在IP数据报中的位置 TCP数据结构 TCP报文段首部的前20个字节是固定的，后面有4N字节是根据需要而增加的选项。因此TCP报文段的最小长度为20个字节。 首部固定部分的各字段的意义如下： 1、源端口和目的端口：加上IP首部的源IP地址和目的IP地址，确定唯一的一个TCP连接。另外通过目的端口来决定TCP将数据报交付于那个应用程序，从而实现TCP的分用功能。 2、序号：占4个字节，序号的范围为[0,4284967296]。由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号。另外，序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0。 3、确认号：当ACK标志位为1时有效，表示期望收到的下一个报文段的第一个数据字节的序号。确认号为N，则表明到序号N-1为止的所有数据字节都已经被正确地接收到了。 4、头部长度：TCP报文段的头部长度，它指出TCP报文段的数据部分的起始位置与TCP报文段的起始位置的距离。头部长度占4个字节，但它的单位是32位字，即以4字节为计算单位，因此头部长度的最大值为15*4=60个字节，这就意味着选项的长度不超过40个字节。 5、保留位：必须为0. 6、下面的六个控制位说明报文段的性质： 1)URG：与首部中的紧急指针字段配合使用。URG为1时，表明紧急指针字段有效，发送应用进程告诉发送方的TCP有紧急数据要传送，于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而其后面仍是普通数据。 2)ACK：仅当ACK=1时确认号字段才有效，当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送报文段都必须把ACK置1。 3)PSH：如果发送的报文段中PSH为1，则接收方接受到该报文段后，直接将其交付给应用进程，而不再等待整个缓存都填满后再向上交付。 4)RST：复位标志，RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立运输连接。 5)SYN：同步序号，用来发起一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段，若对方同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。 6)FIN：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。 7、窗口：接收方让发送方下次发送报文段时设置的发送窗口的大小。 8、校验和：校验的字段范围包括首部和数据这两部分。 9、紧急指针：紧急指针当URG=1时才有效，它指出本报文段中的紧急数据的字节数。值得注意的是，即使窗口为0时，也可发送紧急数据。 10、选项与填充：选项应该为4字节的整数倍，否则用0填充。最常见的可选字段是最长报文大小MSS(Maximum Segment Size)，每个连接方通常都在通信的第一个报文段中指明这个选项。它指明本端所能接收的最大长度的报文段。该选项如果不设置，默认为536(20+20+536=576字节的IP数据报)，其中ip首部和tcp首部各20个字节，而internet 上标准的MTU (最小)为576B。 二、TCP传输连接建立单方主动连接的TCP连接建立过程在TCP/IP协议体系结构中的TCP协议也是使用三次握手（three-way handshake）机制来建立传输连接的。具体流程如下图所示，具体步骤如下： （1）首先是服务器初始化的过程，从CLOSED（关闭）状态开始通过顺序调用SOCKET、BIND、LISTEN和ACCEPT原语创建Socket套接字，进入LISTEN（监听）状态，等待客户端的TCP传输连接请求。 （2）客户端最开始也是从CLOSED状态开始调用SOCKET原语创建新的Socket套接字，然后在需要再调用CONNECT原语，向服务器发送一个将SYN字段置1（表示此为同步数据段）的数据段（假设初始序号为i），主动打开端口，进入到SYN SENT（已发送连接请求，等待对方确认）状态。 TCP传输连接建立的三次握手过程 （3）服务器在收到来自客户端的SYN数据段后，发回一个SYN字段置1（表示此为同步数据段），ACK字段置1（表示此为确认数据段），ack（确认号）=i+1的应答数据段（假设初始序号为j），被动打开端口，进入到SYN RCVD（已收到一个连接请求，但未进行确认）状态。这里要注意的是确认号是i+1，而不是i，表示服务器希望接收的下一下数据段序号为i+1。 （4）客户端在收到来自服务器的SYN+ACK数据段后，向服务器发送一个ACK=1（表示此为确认数据段），序号为i+1，ack=j+1的确认数据段，同时进入ESTABLISHED（连接建立）状态，建立单向连接。要注意的是，此时序号为i+1，确认号为j+1，表示客户端希望收到服务器的下一个数据段的序号j+1。 （5）服务器在收到客户端的ACK数据段后，进入ESTABLISHED状态，完成双向连接的建立。 连接可以由任一方或双方发起，一旦连接建立，数据就可以双向对等地流动，而没有所谓的主从关系。三次握手是连接两端正确同步的充要条件，因为TCP建立在不可靠的分组传输服务之上，报文可能丢失、延迟、重复和乱序，因此协议必须使用超时和重传机制。如果重传的连接请求和原先的连接请求在连接正在建立时到达，或者当一个连接已经建立、使用和结束之后，某个延迟的连接请求才到达，就会出现问题。采用三次握手协议就可以解决这些问题。如客户端发送的ACK数据段就是为了避免因网络延迟而导致的重复连接，因为这时客户端就可通过检查ACK数据段中的确认号就可得知该连接请求是否已失效。 问题：为什么一定要进行三次握手呢? 前两次的握手很显然是必须的，主要是最后一次，即客户端收到服务端发来的确认后为什么还要想服务端再发送一次确认呢?这主要是为了防止已失效的请求报文段突然又传送到了服务端而产生连接的误判。 考虑如下的情况：客户端发送了一个连接请求报文段到服务端，但是在某些网络节点上长时间滞留了，而后客户端又超时重发了一个连接请求报文段该服务端，而后正常建立连接，数据传输完毕，并释放了连接。如果这时候第一次发送的请求报文段延迟了一段时间后，又到了服务端，很显然，这本是一个早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，于是向客户端发出确认报文段，并同意建立连接。假设不采用三次握手，这时服务端只要发送了确认，新的连接就建立了，但由于客户端比你更没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务器的资源。而如果采用三次握手，客户端就不会向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。 三、TCP传输连接的释放TCP 连接建立起来后，就可以在两个方向传送数据流。当 TCP的网络应用进程再没有数据需要发送时，就可以发出关闭连接命令，释放连接。TCP协议是通过发送FIN字段置1的数据段来作为关闭传输连接的命令，关闭本端数据流的，但是本端仍然还可以继续接收来自对端的数据，直到对端也使用了同样的方法关闭那个方向的数据流，这时整个双方传输连接就彻底关闭了。 单方主动关闭的TCP连接释放过程相对TCP传输连接建立的三次握手过程来说，TCP传输连接的释放过程要稍微复杂一些，需要经过四次握手过程。这是因为TCP的半关闭（half-close）特性造成的，即因这一个TCP连接是全双工（即数据在两个方向上能同时传递），每个方向必须单独地进行关闭。TCP传输连接关闭的原则是：当一方完成它的数据发送任务后就可以发送一个FIN字段置1的数据段来终止这个方向的数据发送；当另一端收到这个FIN数据段后，必须通知它的应用层“对端已经终止了那个方向的数据传送”。而FIN数据段的发送是由应用层调用CLOSE服务原语的结果。TCP连接释放的四次握手过程如下图所示，具体描述如下： （1）一开始，通信双方都处于ESTABLISHED（连接建立）状态。如果客户端认为数据全部发送完了，想结束本次传输连接，则由应用层的对应应用进程调用CLOSE服务原语，然后向服务器发出一个FIN字段置1的数据段（假设此数据段的序号为m），客户端进入FIN WAIT 1状态，等待服务器的确认。 （2）服务器在收到客户端发来的FIN数据段后，确认客户端没有新的数据要发送了，向客户端发送一个ACK字段置1，确认号为m+1（假设此数据段序号为w，服务器与客户端的数据段序号可以不一样），表示前面的数据已全部收到了，然后进入到CLOSE WAIT（关闭等待）状态。与此同时服务器的TCP实体通知对应的应用层进程，释放从客户机到服务器方向的传输连接，进入半关闭状态。但此时服务器仍可以向客户端发送数据段；客户端也可接收来自服务器的数据。而且这可能要持续一段时间，直到服务器的数据也全部发送完。 TCP传输连接释放的四次握手过程 （3）当客户端收到服务器的ACK数据段后便进入到了FIN WAIT 2状态，进一步等待服务器发出连接释放的数据段。 （4）当服务器发送完全部的数据后，其对应的应用进程也会通知TCP实体释放此方向的TCP传输连接，向客户机发送FIN字段置1，ACK字段置1，ack=m+1（假设此时的数据段序号已变为w）的确认数据段。这时服务器进入LAST ACK（最后确认）状态，等待客户端的确认。 （5）客户端在收到服务器的FIN+ACK数据段后，向服务器发送一个ACK字段置1，ack=w+1，序列号为m+1的数据段，进入到TIME WAIT状态。但此时TCP连接还没有释放，必须等待2MSL时间（RFC 793建议设MSL为2分钟）后，客户端才进入到CLOSED状态，彻底释放了TCP连接。 （6）服务器在收到客户端发来的ACK数据段后，也进入CLOSED状态，彻底释放连接。完成整个TCP传输连接释放过程。 问题：为什么A在TIME—WAIT状态必须等待2MSL时间呢? 1、为了保证A发送的最后一个ACK报文段能够到达B。该ACK报文段很有可能丢失，因而使处于在LIST—ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B可能会重传这个FIN+ACK报文段，而A就在这2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入CLOSED状态。如果A在TIME—WAIT状态不等待一段时间就直接释放连接，到CLOSED状态，那么久无法收到B重传的FIN+ACK报文段，也就不会再发送一次确认ACK报文段，B就无法正常进入CLOSED状态。 2、防止已失效的请求连接出现在本连接中。在连接处于2MSL等待时，任何迟到的报文段将被丢弃，因为处于2MSL等待的、由该插口(插口是IP和端口对的意思，socket)定义的连接在这段时间内将不能被再用，这样就可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。 补充： 当客户端执行主动关闭并进入TIME—WAIT是正常的，服务端执行被动关闭，不会进入TIME—WAIT状态，这说明，如果终止了一个客户程序，并立即重启该客户程序，则新的客户程序将不再重用相同的本地端口，而是使用新的端口，这不会带来什么问题，因为客户端使用本地端口，而并不关心这个端口是多少。但对于服务器来说，情况就不同了，服务器总是用我们熟知的端口，那么在2MSL时间内，重启服务器就会出错，为了避免这个错误，服务器给出了一个平静时间的概念，这是说在2MSL时间内，虽然可以重新启动服务器，但是这个服务器还是要平静的等待2MSL时间的过去才能进行下一次连接 参考： [基础教程：TCP连接的建立和释放](http://network.chinabyte.com/229/13310229.shtml)； [TCP传输连接建立与释放详解](http://www.cnblogs.com/suncoolcat/p/3320148.html)； TCP-IP详解(卷一、二、三)","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.le-more.com/categories/Server/"}],"tags":[]},{"title":"iOS真机调试免费证书","slug":"ios/ios-e7-9c-9f-e6-9c-ba-e8","date":"2017-01-20T07:04:59.000Z","updated":"2019-11-08T09:59:30.980Z","comments":true,"path":"2017/01/20/ios/ios-e7-9c-9f-e6-9c-ba-e8/","link":"","permalink":"http://blog.le-more.com/2017/01/20/ios/ios-e7-9c-9f-e6-9c-ba-e8/","excerpt":"","text":"运行Xcode，点击左上角菜单Xcode -&gt; Preferences 点击Accounts，然后点下面的+号，在弹出菜单中点击Add Apple ID 在弹框中输入账号和密码，然后点击Add 成功后，点击帐户。在右侧列表中选择xxx(Personal Team) User，双击打开 在打开的列表中选择 iOS Development点击Create 点击Done，就成功创建了！ 点击项目-&gt;Targets(下第一个)-&gt;General页面，在Signing部分Team选择刚创建的Personal Team","categories":[{"name":"macOS","slug":"macOS","permalink":"http://blog.le-more.com/categories/macOS/"}],"tags":[]},{"title":"CocoaPods 使用总结","slug":"ios/pod-e4-bd-bf-e7-94-a8","date":"2017-01-09T03:25:42.000Z","updated":"2019-11-08T09:59:30.981Z","comments":true,"path":"2017/01/09/ios/pod-e4-bd-bf-e7-94-a8/","link":"","permalink":"http://blog.le-more.com/2017/01/09/ios/pod-e4-bd-bf-e7-94-a8/","excerpt":"","text":"解决源问题： 国内的镜像：https://gems.ruby-china.org/ 安装 sudo gem install -n /usr/local/bin cocoapods 升级更新 sudo gem update –system 如果上一步提示无法获取，需要更新源： gem sources –remove https://rubygems.org/gem sources -a https://gems.ruby-china.com 再执行 $ sudo gem update --system $ sudo gem install cocoapods -n/usr/local/bin初始化第三方库信息 pod setup 更新第三方库信息 pod repo update 解析Podfile，安装 pod install 解析Podfile，升级 pod update 搜索 pod search chartboost 一般步骤： 1.初始化 pod init 2.打开Podfile添加源 3.安装源 pod install 一般通过这三步就OK了！ 问题: 执行pod install后显示:Setting up CocoaPods master repo卡住不动 cd ~/.cocoapods/reposgit clone https://github.com/CocoaPods/Specsopen . 然后把Specs目录改名为master(未验正通过) Setting up CocoaPods master repo卡住不动 使用：du -sh *查看目录（~/.cocoapods/repos）是否有变化，我的问题实际上是变化的只是下载的时间有点长 参考：一遍成功安装”Cocoapods”","categories":[{"name":"macOS","slug":"macOS","permalink":"http://blog.le-more.com/categories/macOS/"}],"tags":[]},{"title":"U3D试题汇总","slug":"u3d/u3d-e8-af-95-e9-a2-98-e6","date":"2017-01-07T07:18:27.000Z","updated":"2019-11-08T09:59:31.017Z","comments":true,"path":"2017/01/07/u3d/u3d-e8-af-95-e9-a2-98-e6/","link":"","permalink":"http://blog.le-more.com/2017/01/07/u3d/u3d-e8-af-95-e9-a2-98-e6/","excerpt":"","text":"备注：来源于网络 1.Unity中碰撞器(Collider)和触发器(Trigger)的区别? 要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。 物体发生碰撞的必要条件: 两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。 在Unity3D中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。 碰撞器： 一群组件，它包含了很多种类，比如：Box Collider（ 盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。 触发器 ，只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。 碰撞器（Collider）:IsTrigger=false，根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数 触发器(Trigger):isTrigger=true，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数 如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器 例子： 碰撞器：汽车被撞飞、皮球掉在地上又弹起效果 触发器：人站在靠近门的位置门自动打开效果 2.物体发生碰撞的必要条件？ 必须带有collider碰撞器和rigibody刚体属性或者人物控制器，其实人物控制器就包含了前两者，另外一个物体也要必须带有Collider，Collider分类：网格碰撞器，盒子碰撞器，胶囊碰撞器，球型碰撞器，地形碰撞器！ 3.CharacterController和Rigidbody的区别？ Rigidbody具有完全真实物理的特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的。 4.物体发生碰撞时，有几个阶段，分别对应的函数？ 三个阶段，OnCollisionEnter/Stay/Exit函数 5.物体发生碰撞时，几种施加压力的方式，描述出来？ rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数 6.Unity3d提供了几种光源，分别是什么？ 共4种，DirectionalLight、PointLight、SpotLight、AreaLight（用于烘焙） 7.物理更新一般在哪个系统函数里？ FixedUpdate,每固定帧绘制时执行一次，和update不同的是FixedUpdate是渲染帧执行，如果你的渲染帧效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适合用于物理引擎的计算，因为是跟每帧的渲染有关。Update就比较适合做控制。 8.移动相机动作在哪个函数里，为什么在这个函数里。 LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。 9.简述一下对象池,你觉得在FPS游戏里哪些东西适合使用对象池？ 对象池就存放需要被反复调用资源的一个空间，比如游戏中要常被大量复制的对象，子弹，敌人，以及任何重复出现的对象。 10.有限状态机 1). 机枪兵在平时站立时，处于 空闲 状态； 初始化状态机，并将 空闲 状态作为初始状态放入状态机堆栈中；状态机堆栈：【空闲】 2). 机枪兵发现敌人，并且敌人在射程范围内，机枪兵开始攻击敌人；此时，机枪兵进入 攻击 状态； 进入 攻击 状态；状态机堆栈：【攻击】【空闲】 3). 敌人死亡，机枪兵停止攻击；此时，机枪兵回到 空闲 状态； 退出当前状态；状态机堆栈：【空闲】 4). 此时玩家发出进攻命令，此进攻命令是用A键点了远处的一个地面 place1 ，也就是没有具体目标的进攻；此时，机枪兵进入 移动进攻 状态； 进入 移动进攻 状态；状态机堆栈：【移动进攻】【空闲】 5). 在移动过程中，机枪兵发现了敌人，所以他要脱离原来的路径，走向发现的敌人；此时，机枪兵进入 追击 状态； 进入 追击 状态；状态机堆栈：【追击】【移动进攻】【空闲】 6). 机枪兵和敌人的距离小于了自己的射程之后，机枪兵停下来，并且攻击敌人；此时，机枪兵进入了 攻击 状态； 切换到 攻击 状态；状态机堆栈：【攻击】【移动进攻】【空闲】 7). 敌人死亡后，机枪兵重新寻路到place1，继续前进；此时机枪兵回到步骤4，回到了 移动进攻 状态。 退出当前状态；状态机堆栈：【移动攻击】【空闲】 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 1. 请简述值类型与引用类型的区别 区别： 1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。 2.值类型存取快，引用类型存取慢。 3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。 4.栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放。 5.值类型继承自System.ValueType,引用类型继承自System.Object。 可参考http://www.cnblogs.com/JimmyZhang/archive/2008/01/31/1059383.html 2.C#中所有引用类型的基类是什么 引用类型的基类是System.Object 值类型的基类是System.ValueType 同时，值类型也隐式继承自System.Object 3.请简述ArrayList和List的主要区别 ArrayList就是一个List而已。 泛型集合的优势就是类型安全和无装箱。 4.请简述GC（垃圾回收）产生的原因，并描述如何避免？ GC回收堆上的内存 避免：1）减少new产生对象的次数 2）使用公用的对象（静态成员） 3）将String换为StringBuilder 5.请描述Interface与抽象类之间的不同 从某种意义上说，interface是一种特殊形式的 abstract class。 抽象类：表示该类中可能已经有一些方法的具体定义 接口：是只能定义各个方法的声明 ，不能有具体的实现代码。 类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。 实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。 6.下列代码在运行中会产生几个临时对象？ string a = new string(“abc”);a = (a.ToUpper() + “123”).Substring(0, 2); 答：其实在C#中第一行是会出错的（Java中倒是可行）。应该这样初始化： string b = new string(new char[]{‘a’,’b’,’c’}); 7.下列代码在运行中会发生什么问题？如何避免？ List ls = new List(new int[] { 1, 2, 3, 4, 5 });foreach (int item in ls){ Console.WriteLine(item * item); ls.Remove(item);} 会产生运行时错误，因为foreach是只读的。不能一边遍历一边修改。 8.请简述关键字Sealed用在类声明和函数声明时的作用 类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。 9.请简述private，public，protected，internal的区别 public：对任何类和成员都公开，无限制访问 private：仅对该类公开 protected：对该类和其派生类公开 internal：只能在包含该类的程序集中访问该类 protected internal：protected + internal 10.反射的实现原理？ 反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等 得到程序集中的属性和方法。 实现步骤： 1,导入using System.Reflection; 2，Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly 3， foreach (Type type in assembly.GetTypes()) { string t = type.Name; } 得到程序集中所有类的名称 4,Type type = assembly.GetType(“程序集.类名”);获取当前类的类型 5,Activator.CreateInstance(type); 创建此类型实例 6,MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法 7,mInfo.Invoke(null,方法参数); 11. .Net与Mono的关系？ Mono官网主页：Mono is a software platform designed to allow developers to easily createcross platform applications. Sponsored by Xamarin, Mono is an open sourceimplementation of Microsoft’s .NET Framework based on the ECMA standards for C# and the Common Language Runtime. mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。 12.简述Unity3D支持的作为脚本的语言的名称 Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。 Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。 JavaScript：和网页中常用的JavaScript不一样，它编译后的运行速度很快，语法方面也会有不少区别。 C# Boo：可以看做是Python语言的变种，又糅合了Ruby和C#的特性，它是静态类型语言 13.Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？ 仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用 支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。 注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象 参考http://www.unitymanual.com/3821.html 14.Unity3D的协程和C#线程之间的区别是什么？ 多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。 除主线程之外的线程无法访问Unity3D的对象、组件、方法。 Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。而LoadLevelAsync则允许你在后台加载新资源和场景，所以再利用协同，你就可以前台用loading条或动画提示玩家游戏未卡死，同时后台协同处理加载的事宜asynchronous[e ɪˈ s ɪŋ kr ə n ə s] .synchronous同步。 参考：http://blog.csdn.net/kongbu0622/article/details/8775037 15.U3D中用于记录节点空间几何信息的组件名称，及其父类名称 Transform 父类是 Component 16.简述四元数的作用，四元数对欧拉角的优点？ 四元数用于表示旋转 相对欧拉角的优点： 1）能进行增量旋转 2）避免万向锁 3）给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式） 17.向量的点乘、叉乘以及归一化的意义？ 1）点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影 2）叉乘得到的向量垂直于原来的两个向量 3）标准化向量：用在只关系方向，不关心大小的时候 18.矩阵相乘的意义及注意点 用于表示线性变换：旋转、缩放、投影、平移、仿射 注意矩阵的蠕变：误差的积累 19.为何大家都在移动设备上寻求U3D原生GUI的替代方案 不美观，OnGUI很耗费时间，使用不方便 20.请简述如何在不同分辨率下保持UI的一致性 NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。 21.为什么dynamic font在unicode环境下优于static font Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。 使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。 22.Render的作用？描述MeshRender和SkinnedMeshRender的关系与不同 A renderer is what makes an objectappear on the screen。 Mesh就是指模型的网格（同名组件是用于调整网格属性的），MeshFilter一般是用于获得模型网格的组件，而MeshRender是用于把网格渲染出来的组件， 23.简述SkinnedMesh的实现原理 http://blog.csdn.net/n5/article/details/3105872 24.在场景中放置多个Camera并同时处于活动状态会发生什么？ 实际看到的画面由多个camera的画面组成，由depth、Clear Flag、Culling Mask都会影响最终合成效果。 25.Prefab的作用？如何在移动环境的设备下恰当地使用它？ 在游戏运行时实例化，prefab相当于一个模版，对你已有的素材、脚本、参数做一个默认配置，以便于以后修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。 http://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html 26.如何销毁一个UnityEngine.Object及其子类 Destory 27.为什么Unity3D中会发生在组件上出现数据丢失的情况？ 组件上绑定的对象被删除了 28.如何安全的在不同工程间安全地迁移asset数据？三种方法 1).将Assets目录和Library目录一起迁移 2).导出包 3).用unity自带的assets Server功能 29.MeshCollider和其他Collider的一个主要不同点？ Meshcollider再快也是基于V3顶点~~ 建议还是用boxcollider，boxcollider本身是基于算法，没有面的概念。 30.当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ 穿透（碰撞检测失败） http://forum.unity3d.com/threads/3353-collision-detection-at-high-speed (碰撞体变大，FixedUpdate, 代码限制) 31.OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？ Awake -》OnEnable-》Start OnEnable在同一周期中可以反复地发生 http://answers.unity3d.com/questions/217941/onenable-awake-start-order.html 32.请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？ 当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。 33.Unity3D如何获知场景中需要加载的数据？ Resource.Load AssetBundle 34.MeshRender中material和sharedmaterial的区别？ 修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。 不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 1.请描述游戏动画有哪几种，以及其原理。 主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画。 关节动画把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活Quake2中使用了这种动画。 单一网络模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，由关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画。（骨骼动画是由关节动画发展而来的，如今基本都使用骨骼动画来实现角色动画） 2.alpha blend 工作原理 实际显示颜色 = 前景颜色*Alpha/255 + 背景颜色*(255-Alpha)/255 3.写光照计算中的diffuse的计算公式 实际光照强度 I= 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular); 环境光：Iambient= Aintensity* Acolor; (Aintensity表示环境光强度，Acolor表示环境光颜色) 漫反射光：Idiffuse = Dintensity*Dcolor*N.L; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) 镜面反射光：Ispecular = Sintensity*Scolor*(R.V)^n; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量，n称为镜面光指数) 4.lod是什么，优缺点是什么 LOD技术即Levels of Detail的简称，意为多细节层次。LOD技术指根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。 优点：可根据距离动态地选择渲染不同细节的模型 缺点：加重美工的负担，要准备不同细节的同一模型，同样的会稍微增加游戏的容量。 5.两种阴影判断的方法工作原理 阴影由两部分组成：本影与半影 本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域） 半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域） 求阴影区域的方法：做两次消隐过程 一次对每个光源进行消隐，求出对于光源而言不可见的区域L； 一次对视点的位置进行消隐，求出对于视点而言可见的面S； shadow area= L ∩ S 阴影分为两种：自身阴影和投射阴影 自身阴影：因物体自身的遮挡而使光线照射不到它上面的某些可见面 工作原理：利用背面剔除的方法求出，即假设视点在点光源的位置。 投射阴影：因不透明物体遮挡光线使得场景中位于该物体后面的物体或区域受不到光照照射而形成的阴影 工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程） 若是动态光源此方法就无效了。 5.Vertex Shader是什么？怎么计算？ 顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。 Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。 6.MipMap是什么？作用？ 在三维计算机图形的贴图渲染中有一个常用的技术被称为Mipmapping。为了加快渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为 MIP map 或者 mipmap。 7.用u3d实现2d游戏，有几种方式？ 1).利用引擎自带的GUI 2).把摄像机设为Orthographic，用面片作为2d元素 3).利用第三方插件：NGUI、2dToolkit 8.什么叫做链条关节 Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。（简单说就是弹簧） 9.物体自旋转使用的函数叫什么 transform.Rotate 10.物体绕某点旋转使用函数叫什么 transform.RotateAround 11.u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数 PlayerPrefs.SetInt 与 PlayerPrefs.GetInt 12.unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。 Awake –&gt;OnEnable –&gt; Start –&gt; Update –&gt; FixedUpdate –&gt; LateUpdate –&gt; OnGUI –&gt; Reset –&gt; OnDisable –&gt; OnDestroy 13.当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。 做一个pool，游戏开始时预先实例化足够的数量，然后用的时候取不用的时候收回 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 1、在类的构造函数前加上static会报什么错?为什么? 构造函数格式为 public+类名，如果加上static会报错（静态构造函数不能有访问修饰符） 原因：静态构造函数不允许访问修饰符，也不接受任何参数； 无论创建多少类型的对象，静态构造函数只执行一次； 运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数； 静态构造函数执行先于任何实例级别的构造函数； 显然也就无法使用this和base来调用构造函数。 2、C# String类型比stringBuilder类型的优势是什么? 如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而stringBuilder是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用stringBuilder这样比较节约内存。但是string 类的方法和功能仍然还是比stringBuilder类要强。 3、C# 函数Func(string a, string b)用 表达式怎么写? Func(string a, string b) Str = (a,b)=&gt;{//define}; (a,b) =&gt; {}; 4、数列1,1,2,3,5,8,13…第n位数是多少?用C#递归算法实现 通项公式应该是an = a(n-1) + a(n-2) 这样就可以做递归了 int f(int n) { if (n &gt; 1) { return f(n - 1) + f(n - 2); } else { return n; }} 5、一个简单的游戏,怪物会走动\\攻击\\死亡,游戏角色会走动,跳跃\\攻击\\格挡\\死亡,还会接受玩家从输入端输入的指令,NPC会走动,他们彼此之间可以互相通信.请画出以上三种角色的UML图示. 6、NGUI Button怎样接受用户点击并调用函数,具体方法名称是什么 .OnClick()主要是在UICamera脚本中用射线判断点击的物体并通过SendMessage调用OnClick() OnPress()等函数，可以说NGUI的按钮是通过发消息这个方式调用的。 7、怎么判断两个平面是否相交?不能用碰撞体,说出计算方法. 对于两个平面Ax+By+Cz+D=0与ax+by+cz+d=0，只要(A,B,C)与(a,b,c)不成比例，这两个平面就是相交的 8、&lt;愤怒的小鸟&gt;给予初速度以后,怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹,说出具体的计算方法. Vector3 v代表初速度v’代表现在的速度，假设小鸟是沿的z轴也就是transform.forward方向运动的质量为1，那么v‘=v-new Vector3(0,g*t,f*t)，transform.Translate(v’)做的就是抛物线运动（g为重力加速度不要用现实中的需要自己调试，f为阻力也要自己调试设置，t为时间） 一、什么是渲染管道？ 是指在显示器上为了显示出图像而经过的一系列必要操作。渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中。主要步骤有： 本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化。 二、如何优化内存？ 有很多种方式，例如： 1.压缩自带类库； 2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉； 3.释放AssetBundle占用的资源； 4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小； 5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。 三、动态加载资源的方式？ 1.Resources.Load(); 2.AssetBundle 四、什么是协同程序？ 在主线程运行时同时开启另一段逻辑处理，来协助当前程序的执行。换句话说，开启协程就是开启一个线程。可以用来控制运动、序列以及对象的行为。 五、你用过哪些插件？ (多熟悉几个插件更好，问的时候好回答) 待续….","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[]},{"title":"Unity3D Shader学习之十四—内置函数和变量","slug":"u3d/e7-bd-ae-e5-87-bd-e6-95","date":"2017-01-05T15:00:56.000Z","updated":"2019-11-08T09:59:31.014Z","comments":true,"path":"2017/01/05/u3d/e7-bd-ae-e5-87-bd-e6-95/","link":"","permalink":"http://blog.le-more.com/2017/01/05/u3d/e7-bd-ae-e5-87-bd-e6-95/","excerpt":"","text":"转自： Unity3D Shader性能排行整体上，性能由高到低： Unlit，仅为纹理，光线不产生效果 VertexLit Diffuse 漫反射 Normal Mapped 法线贴图 Specular 高光 Normal Mapped Specular Parallax Normal Mapped Parallax Normal Mapped Specular 另外，unity3d还内置有一些简化的用作移动平台的shader/着色器。 推荐文章 内置shader详解（带图） Shader性能影响因素：着色器性能影响因素较多，最主要有二： shader本身 Rendering Paths （渲染路径？） 性能最优的两款 内置着色器： Deffered shader Vertex Lit 仅做绘制一次，性能只取决于纹理数。 在Forward rendering path：性能仅取决于shader本身和场景中光源。 Pixel Lit 性能更差，效果更好，多次绘制，故能实现（阴影，法线，高光等） Vertex Lit 性能更佳，所有灯光影响仅绘制一次 对内置Shader的通俗理解（转）：1.Vertex-Lit： 基于： 基于顶点计算的光照模型 正方体： 【直接照射到的地方不会非常亮】【光照照射不到的平面无效果】 圆形： 【直接照射到的地方非常亮】【光照照射不到的地方有高光效果】 支持： 设备自动选择【可编程管线】和【固定管线】 参数： 【主色color】【SpecColor光照颜色】【EmissiveColor自发光颜色】【Shininess光照强度】 渲染代价： 比较小 2.Diffuse： 基于： 基于简单的光照模型 lambertian 正方体： 【直接照射到的地方会非常亮】【光照照摄不到的平面无效果】 圆形： 【直接照射到的地方非常亮】【光照照射不到的地方无效果】 支持： 设备需要支持【可编程管线】如果不支持将自动使用【Vertex-Lit】 参数： 【主色color】 渲染代价： 比较小 3.Specular 基于： 和Diffuse相同的光照模型，多了一个观察角度相关的反射高光(#pragma surface surf BlinnPhong) 正方形： 【直接照射到的地方会非常亮】【光照照摄不到的平面无效果】【观察角度和光入射角度会产生反射光】 圆形： 【直接照射到的地方非常亮】【光照照射不到的地方无效果】【观察角度和光入射角度会产生反射光】 支持： 设备需要支持【可编程管线】如果不支持将自动使用【Vertex-Lit】 参数： 【主色color】【SpecularColor反射光照颜色】【Shininess反射光照强度】 渲染代价： 比较大 4.Bumped Diffuse 基于： 和Diffuse相同的光照模型，同时使用了法线贴图normal mapping技术(UnpackNormal)【灰度图，白色表示凹起，黑色表示凹进】 正方形： 和【Diffuse】一样，【多了凹凸感】 圆形： 和【Diffuse】一样，【多了凹凸感】 支持： 如果设备不支持，将自动使用【Diffuse】 参数： 【主色color】【多了法线贴图】 渲染代价： 比较大 5.Bumped Specular 凹凸反射 【Bumped Diffuse】与【Specular】的合并 支持： 如果设备不支持，将使用【Specular】 6.Parallax Diffuse 基于： 和Bumped Diffuse一样的光照模型lambertian,也使用normal mapping技术(UnpackNormal)，同时使用HeightMap(ParallaxOffset)实 现更加逼真的凹凸感【高度图在法线贴图的alpha通道保存，全黑表示么有高度，白色表示高低】 支持： 设备无法使用，会自动使用【Bumped Diffuse】 参数： 【主色color】【多了法线贴图】【多了高度贴图】【height设置高度参数】 渲染代价： 比【Bumped Diffuse】更大 7.Parallax Specular 基于： 使用【Bumped Specular】+【高度图】 支持： 设备无法使用，会自动使用【Bumped Specular】 8.Decal 【贴花】 基于： 与Diffuse一样基于Lambert，增加第二张贴图，然后融合色彩(lerp)覆盖在主纹理之上【注：DiffusDetail的融合是rgb*rgb】 支持： 设备需要支持【可编程管线】如果不支持将自动使用【Vertex-Lit】 参数： 【主色color】【两张贴图】 9.Diffuse Detail 【细节贴图】 基于： 与Diffuse一样基于Lambert，多了一张贴图与之融合(rgb*rgb),一般用于地形，摄像机拉近时额外的细节会出现。 说明： Detail 纹理是覆盖在主纹理上面的。Detail 纹理中深色的部分将会使得主纹理变深，而淡色的部分将会使主纹理变亮， Detail 纹 理通常是浅灰色。(与Decal 里面 Decal 纹理不同的是，Decal 纹理是 RGBA，通过 alpha 控制 DecalTexture 与 Main Texture 的融合，而 Detail 的纹理是 RGB，直接是两张纹理的rgb 通道分别相乘再*2，就是说，Detail 纹理中颜色数值 = 0.5 不会改变主纹理颜色，&gt;0.5 会变亮，&lt;0.5 加深) 参考参考文章 shader实例（五）如何在unity中更好的运用shader 参考文档 Usage and Performance of Built-in Shaders","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"游戏开发之数学知识汇总","slug":"game/e5-bc-80-e5-8f-91-e4","date":"2017-01-05T03:04:33.000Z","updated":"2019-11-08T09:59:30.978Z","comments":true,"path":"2017/01/05/game/e5-bc-80-e5-8f-91-e4/","link":"","permalink":"http://blog.le-more.com/2017/01/05/game/e5-bc-80-e5-8f-91-e4/","excerpt":"","text":"在程序开发过程遇到的数学问题，将其原理记录下来，这样针对性的学习总结要比全部捡起，更有可行性、更靠谱！ 坐标系 为了表示位置，距离，方向等相关关系，使用三维的笛卡尔坐标系。 左手坐标和右手坐标系的鉴别方法：拇指食指中指分别代表xyz，指头方向为正方向。如果左手和当前坐标轴对应就是左手坐标系，反之为右手坐标系。上图为左手坐标系。 左手法则和右手法则，在左手坐标系里使用左手法则；在右手坐标系里使用右手法则。比如（0，0，1）在坐标系统中绕Y轴正方向旋转90度（旋转后坐标为（1,0,0）左右坐标系都一样），判断正方向的方法是在左手坐标系中，使用左手握住Y轴，4个指头指向的方向就是正方向。右手坐标系统则使用右手。 在unity3d中Vector3的forward，right，up在左手坐标系中，forward表示z轴的前方，right表示x轴正方向，up表示y轴正方向。（左手坐标系：右手指向x轴，头顶y轴，面向z轴） 矢量运算 矢量与标量相乘除：K_V = _(K_Vx+ KVy+KVz) 矢量与矢量相加减：A_ + B = (A_x+Bx,Ay+By,Az+Bz),三角形法则如下图： 矢量的模： 单位矢量：模为1的矢量（归一化） 零矢量：V=_（0，0，0） 矢量的点积公式一： 矢量点乘的几何意义：矢量b在单位矢量a上的投影 )公式二： 矢量的叉积公式一： 公式二： 矩阵运算 矩阵与标量相乘： 矩阵与矩阵相乘：A(r行n列)乘以B(n行c列)得AB(r行c列)，A的列数必须与B的行数相同 AB元素的值：A的i行矢量乘以B的j列矢量，公式为： 矩阵类型： 方阵（对角矩阵）：行列相同 单位矩阵(I)：MI=IM = M 转置矩阵：A(r行c列)转置为A(c行r列) 逆矩阵：必须为方阵(非零)MM = MM = I (M为逆矩阵)称为可逆的非奇异的否则称为不逆的，奇异的逆矩阵的逆矩阵为自己;I的逆矩阵为I;转置矩阵的逆矩阵是逆矩阵的转置；AB的逆等于B（逆）乘以A（逆） 正交矩阵：MM = MM = I(M为转置矩阵)，M（转置） = M（逆） 正交基：基矢量相互垂直 标准正交基：正交基的所有基矢量长度为1 行矩阵列矩阵：Unity中矢量是列矩阵的形式表示的，放在矩阵的右侧 矩阵 = 变换（旋转缩放平移） 线性变换：矢量加和标量乘（旋转，缩放，错切，镜像，正交投影） 仿射变换：合并线性变换和平移变换（非线性变换），4x4的矩阵表示，即齐次坐标空间 基础变换：仅平移，仅旋转，仅缩放 M(3x3)表示旋转和缩放，t(3x1)表示平移，0(1x3)零矩阵，右下角为标量1. 平移矩阵： 缩放矩阵： k(x),k(y),k(z)相同为统一缩放，否则为非统一缩放 旋转矩阵： 复合变换： 从右向左，先缩放，再旋转，再平移（绝大多数情况下） 复合缩放：unity顺利zxy 直线方程的公式有以下几种： 斜截式：y=kx+b 点斜式：y-y1=k(x-x1) 两点式：(y-y1)/(x-x1)=(y-y2)/(x-x2) 截距式：x/a+y/b=1 一般式 点(x0,y0)到直线：Ax+By+C=0的距离： |AXo+BYo+C|/√(A²+B²) 直线的方向向量：(1,k) 点到直线的距离公式: 公式描述：公式中的直线方程为Ax+By+C=0，点P的坐标为(x0,y0)。 负数的二进制 负数以其正值的补码形式表示的，如： 5的二进制：00000000 00000000 00000000 00000101 5的二进制反码：11111111 11111111 11111111 11111010 5的二进制补码：11111111 11111111 11111111 11111011 （反码加1） [-1,1]映射到[0,1]:pixel = (normal +1)/2 位运算符有：按位与、按位或、按位非、按位异或。 与：&amp; 都为1则为1 或：| 有一个为1则为1 非(取反)：~ 按位取反 异或：^ 不同为1(如1和0，0和1)，相同为0(0和0,1和1) 位运算的几个经典用途： 1. 取x串中的低四位：x&amp;0xF2. 将x串中低四位变成1，其他位不变：x|0xF 3. 将x串中低四位取反：x^0xF 4. 将x串的低四位变成0：x&amp;~0xF 中缀算式和后缀算式，原理？ 中缀:（3+X*Y）-2Y/3 后缀：3 X Y * + 2 Y * 3 / - 二叉树 性质： 1、非空二叉树的第n层上至多有2^(n-1)个元素。 2、深度为h的二叉树至多有2^h-1个结点。 遍历： 前序遍历：根节点-&gt;左子树-&gt;右子树 A B D G H E C K F I J 中序遍历：左子树-&gt;根节点-&gt;右子树 G D H B E A K C I J F 后序遍历：左子树-&gt;右子树-&gt;根节点 G H D E B K J I F C A 右乘和左乘 v1 = (x,y,z) 行矩阵1x3；v2 = (x,y,z)(v1的转置) 列矩阵3x1; 左乘：工程数学中，用到两个矩阵相乘的时候，矩阵A×矩阵B，那么就称为A左乘以B。 矩阵相乘才有左乘和右乘的区别 矩阵左乘是行变换，右乘列变换 求和公式 自然数1..n求和： 自然数n..m求和： 等差求和： 等比求和： 速度，加速度，距离 Vt:末速 Vo:初速 a:加速度 S:位移 t:时间 等加速度五个公式,每个公式都取其中四个量来运算：(其中Vo^2=初速平方,以此类推) S=Vo^2+a(t^2)/2 S=Vt^2+a(t^2)/2 Vt=Vo+at S=(Vo+Vt)*t/2 Vt^2=(Vo^2)+ 2aS 斜抛的公式H=V^2 * sin^2 x / 2g T=2VsinX/g R=V^2 * sin2x /g 四元数 Quaternion = (xi + yj + zk + w ) = (x,y,z,w)，(x,y,z) 跟旋转轴有关, w 与绕旋转轴旋转的角度有关,因为它们都要经过代数运算才能得出旋转轴和旋转角度 在unity3d中, quaternion 的乘法操作 (operator * ) 有两种操作: (1) quaternion * quaternion , 例如 q = t * p; 这是将一个点先进行t 操作旋转,然后进行p操作旋转. (2) Quaternion * Vector3, 例如 p : Vector3, t : Quaternion , q : Quaternion; q = t * p; 这是将点p 进性t 操作旋转; 我进行的是第2种操作,即对一个向量进行旋转; 首先 ,Quaternion 的基本数学方程为 : Q = cos (a/2) + i (x * sin(a/2)) + j (y * sin(a/2)) + k(z * sin(a/2)) (a 为旋转角度) Q.w = cos (angle / 2) Q.x = axis.x * sin (angle / 2) Q.y = axis.y * sin (angle / 2) Q.z = axis.z * sin (angle / 2) 我们只要有角度就可以给出四元数的四个部分值,例如我想要让点M=Vector3(o,p,q) 绕x轴顺时针旋转90度;那么对应的quaternion数值就应该为: Q : Quaternion; Q.x = 1 * sin(90度/2) = sin(45度) = 0.7071 Q.y = 0; Q.z = 0; Q.w = cos(90度/2) = cos (45度) = 0.7071 Q = (0.7071, 0 , 0 , 0.7071); m = Q * m; （将点m 绕 x轴(1,0,0) 顺时针旋转了90度) var m : Vector3; var t1 : Quaternion; m = Vector3(1,0,0); t1 = Quaternion(0.7,0,0,0.7); m = t1*m;这是quaternion 的最基本用法,主要给出角度，就可以算出Quaternion，然后对点坐标进行旋转。原文 未完","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"Unity3D Shader学习之十三—内置函数和变量","slug":"u3d/b0-e5-92-8c-e5-8f-98","date":"2017-01-04T07:09:28.000Z","updated":"2019-11-08T09:59:31.010Z","comments":true,"path":"2017/01/04/u3d/b0-e5-92-8c-e5-8f-98/","link":"","permalink":"http://blog.le-more.com/2017/01/04/u3d/b0-e5-92-8c-e5-8f-98/","excerpt":"","text":"Unity 中Shader函数 uint CreateShader(enum type) 创建空的shader object，type: VERTEX_SHADER, void ShaderSource(uint shader, sizeicount, const **string, const int *length) 加载shader源码进shader object；可能多个字符串 void CompileShader(uint shader) 编译shader object，shader object有状态 表示编译结果 void DeleteShader( uint shader ) 删除 shader object; void ShaderBinary( sizei count, const uint *shaders, enum binaryformat,const void *binary, sizei length ) 加载预编译过的shader 二进制串； uint CreateProgram( void ) 创建空的program object,programe object组织多个shader object，成为 executable; void AttachShader( uint program, uint shader ) 关联shader object和program object； void DetachShader( uint program, uint shader ) 解除关联； void LinkProgram( uint program ) program object准备执行，其关联的shader object必须编译正确且符合限制条件； void UseProgram( uint program ) 执行program object； void ProgramParameteri( uint program, enum pname, int value ) 设置program object的参数； void DeleteProgram( uint program ) 删除program object； shader 常用变量: qualifier:默认无修饰符，普通变量读写， 与外界无连接； const:常量 const vec3 zAxis = vec3(0.0, 0.0, 1.0); attribute:申明传给vertex shader的变量;只读;不能为array或struct; attribute vec4 position; uniform: 表明整个图元处理中值相同；只读； uniform vec4 lightPos; varying:被差值；读写； varying vec3 normal; in, out, inout; shader变量的精度：highp, mediump, lowp shader内置变量： gl_Position: 用于vertex shader, 写顶点位置；被图元收集、裁剪等固定操作功能所使用;其内部声明是： highp vec4 gl_Position; gl_PointSize: 用于vertex shader, 写光栅化后的点大小，像素个数;其内部声明是：mediump float gl_Position; gl_FragColor: 用于Fragment shader，写fragment color；被后续的固定管线使用； mediump vec4 gl_FragColor; gl_FragData: 用于Fragment shader，是个数组，写gl_FragData[n] 为data n；被后续的固定管线使用； mediump vec4 gl_FragData[gl_MaxDrawBuffers]; gl_FragColor和gl_FragData是互斥的，不会同时写入； gl_FragCoord: 用于Fragment shader,只读， Fragment相对于窗口的坐标位置 x,y,z,1/w; 这个是固定管线图元差值后产生的；z 是深度值; mediump vec4 gl_FragCoord; gl_FrontFacing: 用于判断 fragment是否属于 front-facing primitive；只读； bool gl_FrontFacing; gl_PointCoord: 仅用于 point primitive; mediump vec2 gl_PointCoord; shader内置常量： const mediump int gl_MaxVertexAttribs = 8; const mediump int gl_MaxVertexUniformVectors = 128; const mediump int gl_MaxVaryingVectors = 8; const mediump int gl_MaxVertexTextureImageUnits = 0; const mediump int gl_MaxCombinedTextureImageUnits = 8; const mediump int gl_MaxTextureImageUnits = 8; const mediump int gl_MaxFragmentUnitformVectors = 16; const mediump int gl_MaxDrawBuffers = 1; shader内置函数（一般默认都用弧度） radians(degree) : 角度变弧度； degrees(radian) : 弧度变角度； sin(angle), cos(angle), tan(angle) asin(x): arc sine, 返回弧度 [-PI/2, PI/2]; acos(x): arc cosine,返回弧度 [0, PI]; atan(y, x): arc tangent, 返回弧度 [-PI, PI]; atan(y/x): arc tangent, 返回弧度 [-PI/2, PI/2]; pow(x, y): x的y次方； exp(x): 指数 log(x)：返回以e为底的对数。 exp2(x): 2的x次方 log2(x):返回以2为底的对数。 log10：返回以10为底的对数。 sqrt(x): x的根号； inversesqrt(x): x根号的倒数 abs(x): 绝对值 sign(x): 符号, 1, 0 或 -1 {sign(x)或者Sign(x)叫做符号函数，在数学和计算机运算中，其功能是取某个数的符号(正或负): 当x&gt;0，sign(x)=1; 当x=0，sign(x)=0; 当x&lt;0， sign(x)=-1;} floor(x): 底部取整 ceil(x): 顶部取整 fract(x): 取小数部分 mod(x, y): 取模， x - y*floor(x/y) fmode(x,y):返回x/y的余数，符号同x。如果y为0，结果不可预料。 min(x, y): 取最小值 max(x, y): 取最大值 clamp(x, min, max): min(max(x, min), max); mix(x, y, a): x, y的线性混叠， x(1-a) + y*a; step(edge, x): Returns (x &gt;= edge) ? 1 : 0 smoothstep(edge0, edge1, x): threshod smooth transition时使用。 edge0&lt;=edge0时为0.0， x&gt;=edge1时为1.0 length(x): 向量长度 distance(p0, p1): 两点距离， length(p0-p1); dot(x, y): 点积，各分量分别相乘 后 相加 cross(x, y): 差积，x[1]*y[2]-y[1]*x[2], x[2]*y[0] - y[2]*x[0], x[0]*y[1] - y[0]*x[1] normalize(x): 归一化， length(x)=1; faceforward(N, I, Nref): 如 dot(Nref, I)&lt; 0则N, 否则 -N reflect(I, N): I的反射方向， I -2*dot(N, I)*N, N必须先归一化 refract(I, N, eta): 折射，k=1.0-eta*eta*(1.0 - dot(N, I) * dot(N, I)); 如k&lt;0.0 则0.0，否则 eta*I - (eta*dot(N, I)+sqrt(k))*N matrixCompMult(matX, matY):矩阵相乘, 每个分量 自行相乘， 即 r_[j] = x[j]*y[j];_ 矩阵线性相乘，直接用 * lessThan(vecX, vecY): 向量 每个分量比较 x &lt; y lessThanEqual(vecX, vecY): 向量 每个分量比较 x&lt;=y greaterThan(vecX, vecY): 向量 每个分量比较 x&gt;y greaterThanEqual(vecX, vecY): 向量 每个分量比较 x&gt;=y equal(vecX, vecY): 向量 每个分量比较 x==y notEqual(vecX, vexY): 向量 每个分量比较 x!=y any(bvecX): 只要有一个分量是true， 则true all(bvecX): 所有分量是true， 则true not(bvecX): 所有分量取反 saturate(x) ：Clamps x to the range [0, 1],如果x是矢量，则对每个分量截取 texture2D(sampler2D, coord): texture lookup texture2D(sampler2D, coord, bias): LOD bias, mip-mapped texture texture2DProj(sampler2D, coord): texture2DProj(sampler2D, coord, bias): texture2DLod(sampler2D, coord, lod): texture2DProjLod(sampler2D, coord, lod): textureCube(samplerCube, coord): textureCube(samplerCube, coord, bias): textureCubeLod(samplerCube, coord, lod): Unity常用的包含文件: UnityCG.cginc:包含最常用的帮助函数，宏和结构体； UnityShaderVariables.cginc:包含内置的全局变量，自动包含； Lighting.cginc:包含各种内置的光照模型，如果是表面着色器会自动包含； HLSLSupport.cginc:声明用于跨平台编译的宏和定义，自动包含； UnityCG.cginc 中常用的结构体 appdeat_base:顶点着色器的输入，包含顶点位置，顶点法线，第一组纹理坐标 appdata_tan:顶点着色器的输入，包含顶点位置，顶点切线，顶点法线，第一组纹理坐标； appdata_full:顶点着色器的输入，包含顶点位置，顶点切线，顶点法线，四个纹理坐标； appdata_img:顶点着色器的输入，包含顶点位置，第一组纹理坐标； v2f_img:顶点着色器的输出，裁剪空间的位置，纹理坐标； UnityCG.cginc常用的帮助函数 float3 WorldSpaceViewDir(float4 v):输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向； float3 UnityWorldSpaceViewDir(float4 v):输入一个世界空间中的顶点位置，返回世界空间中从从该点到摄像机的观察方向 float3 ObjSpaceLightDir(float4 v):输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察位置； float3 ObjSpaceViewDir(float4 v):输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向 float3 WorldSpaceLightDir(float4 v):仅用于前向渲染。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化; float3 ObjSpaceLightDir(float4 v):仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向。没有被归一化； float3 UnityObjectToWorldNormal(float3 normal):把法线方向从模型空间转换到世界空间中； float3 UnityObjectToWorldDir(float3 dir):把方向矢量从模型空间变换到世界空间中； float3 UnityWorldToObjectDir(float3 dir):把方向矢量从世界空间变换到模型空间中； 其他 TANGENT_SPACE_ROTATION:计算模型到切线的矩阵 UnpackNormal：获取切线坐标下的法线 UNITY_LIGHTMODEL_AMBIENT:环境光 _MainTex_TexelSize _{TextureName}`TexelSize\\- a float4 property contains texture size information:xcontains 1.0/widthycontains 1.0/heightzcontains widthw` contains height 部分转自：http://blog.sina.com.cn/s/blog_49b531af0102wcm7.html","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之十二—着色器模板","slug":"u3d/unity3d-shader-e5-ad-a6-e7","date":"2017-01-04T07:08:42.000Z","updated":"2019-11-08T09:59:31.032Z","comments":true,"path":"2017/01/04/u3d/unity3d-shader-e5-ad-a6-e7/","link":"","permalink":"http://blog.le-more.com/2017/01/04/u3d/unity3d-shader-e5-ad-a6-e7/","excerpt":"","text":"在Unity5版本创建Shader时，提供5种模板供选择： 分别是： Standard Surface Shader:包含了标准的光照模型的表面着色器模板； Unlit Shader :不包含光照，包含雾效的基本模板； Image Effect Shader:包含屏幕后处理效果的模板； Computer Shader:利用GPU并行性进行一些与常规渲染流水线无关的计算 未完….","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Cocos OpenGL/ES学习之一—你好，三角形（3）OpenGL ES 着色器与程序","slug":"cocos/ef-bc-89opengl-es-api","date":"2016-12-28T03:53:34.000Z","updated":"2019-11-08T09:59:30.973Z","comments":true,"path":"2016/12/28/cocos/ef-bc-89opengl-es-api/","link":"","permalink":"http://blog.le-more.com/2016/12/28/cocos/ef-bc-89opengl-es-api/","excerpt":"","text":"OpenGL ES使用着色器渲染需要创建着色器对象和程序对象。着色器对象负责加载、编译着色器程序源码，程序对象负责连接着色器对象，可以连接多个着色器对象。在OpenGL ES中程序对象只能并且至少连接一个顶点着色器对象和一个片段着色器对象。 具体的步骤： 创建一个顶点着色器对象和一个片段着色器对象； 着色器对象连接相应的源代码； 编译着色器对象； 创建一个程序对象； 程序对象连接着色器对象 链接程序对象。 创建着色器 函数原型：int glCreateShader (int type)方法参数：GL_VERTEX_SHADER (顶点shader)GL_FRAGMENT_SHADER (片元shader) 加载着色器源码 函数原型：void glShaderSource (int shader, String string)参数含义：shader是代表shader容器的id（由glCreateShader返回的整形数）；string是包含源程序的字符串数组。 编译着色器 函数原型：void glCompileShader (int shader)参数含义：shader是代表shader容器的id。 创建程序 函数原型：int glCreateProgram ()如果函数调用成功将返回一个正整数作为该着色器程序的id。 连接着色器对象 函数原型：void glAttachShader (int program, int shader)参数含义：program是着色器程序容器的id；shader是要添加的顶点或者片元shader容器的id。 链接程序对象 函数原型：void glLinkProgram (int program)参数含义：program是着色器程序容器的id。 函数原型：void glUseProgram (int program)参数含义：program是要使用的着色器程序的id。 上面分别列出了各步骤中用到的关键函数。 其他OpenGL ES API： 编译阶段使用glGetShaderiv获取编译情况 函数原型：void glGetShaderiv (int shader, int pname, int[] params, int offset)参数含义：shader是一个shader的id；pname使用GL_COMPILE_STATUS；params是返回值，如果一切正常返回GL_TRUE代，否则返回GL_FALSE。 编译阶段使用glGetShaderInfoLog获取编译错误 函数原型：String glGetShaderInfoLog (int shader)参数含义：shader是一个顶点shader或者片元shader的id。 在连接阶段使用glGetProgramiv获取连接情况 函数原型：void glGetProgramiv (int program, int pname, int[] params, int offset)参数含义：program是一个着色器程序的id；pname是GL_LINK_STATUS；param是返回值，如果一切正常返回GL_TRUE代，否则返回GL_FALSE。 在连接阶段使用glGetProgramInfoLog获取连接错误 函数原型：String glGetProgramInfoLog (int program)参数含义：program是一个着色器程序的id。 清理shader的glDeleteShader方法 函数原型：void glDeleteShader (int shader)；参数含义：shader是要被排除的顶点shader或者片元shader的id。 在cocos引擎的renderer/CCGLProgram文件定义GLProgram封装了着色器和程序操作。 步骤1到3包含在GLProgram::compileShader函数中: bool GLProgram::compileShader(GLuint* shader, GLenum type, const GLchar* source, const std::string&amp; convertedDefines){ GLint status; if (!source) { return false; } //拼接着色器源码 //根据不同平台设置精度类型 //设置统一变量 const GLchar *sources\\[\\] = {#if CC_TARGET_PLATFORM == CC_PLATFORM_WINRT (type == GL_VERTEX_SHADER ? “precision mediump float;\\n precision mediump int;\\n” : “precision mediump float;\\n precision mediump int;\\n”),#elif (CC_TARGET_PLATFORM != CC_PLATFORM_WIN32 &amp;&amp; CC_TARGET_PLATFORM != CC_PLATFORM_LINUX &amp;&amp; CC_TARGET_PLATFORM != CC_PLATFORM_MAC) (type == GL_VERTEX_SHADER ? “precision highp float;\\n precision highp int;\\n” : “precision mediump float;\\n precision mediump int;\\n”),#endif COCOS2D_SHADER_UNIFORMS, convertedDefines.c_str(), source}; //创建着色器 shader = glCreateShader(type); //加载源码 glShaderSource(\\shader, sizeof(sources)/sizeof(*sources), sources, nullptr); //编译着色器 glCompileShader(*shader); //查询状态 glGetShaderiv(*shader, GL\\_COMPILE\\_STATUS, &amp;status); if (! status) { GLsizei length; glGetShaderiv(*shader, GL\\_SHADER\\_SOURCE_LENGTH, &amp;length); GLchar* src = (GLchar *)malloc(sizeof(GLchar) * length); glGetShaderSource(*shader, length, nullptr, src); CCLOG(&quot;cocos2d: ERROR: Failed to compile shader:\\\\n%s&quot;, src); if (type == GL\\_VERTEX\\_SHADER) { CCLOG(&quot;cocos2d: %s&quot;, getVertexShaderLog().c_str()); } else { CCLOG(&quot;cocos2d: %s&quot;, getFragmentShaderLog().c_str()); } free(src); return false; } return (status == GL_TRUE);} 步骤4(创建程序对象)到5(连接程序与着色器)在下面函数中 bool GLProgram::initWithByteArrays(const GLchar* vShaderByteArray, const GLchar* fShaderByteArray, const std::string&amp; compileTimeDefines){ //创建程序对象 _program = glCreateProgram(); CHECK_GL_ERROR_DEBUG(); // convert defines here. If we do it in &quot;compileShader&quot; we will do it twice. // a cache for the defines could be useful, but seems like overkill at this point std::string replacedDefines = &quot;&quot;; replaceDefines(compileTimeDefines, replacedDefines); \\_vertShader = \\_fragShader = 0; if (vShaderByteArray) { if (!compileShader(&amp;\\_vertShader, GL\\_VERTEX_SHADER, vShaderByteArray, replacedDefines)) { CCLOG(&quot;cocos2d: ERROR: Failed to compile vertex shader&quot;); return false; } } // Create and compile fragment shader if (fShaderByteArray) { if (!compileShader(&amp;\\_fragShader, GL\\_FRAGMENT_SHADER, fShaderByteArray, replacedDefines)) { CCLOG(&quot;cocos2d: ERROR: Failed to compile fragment shader&quot;); return false; } } if (_vertShader) { //连接程序与着色器 glAttachShader(\\_program, \\_vertShader); } CHECK\\_GL\\_ERROR_DEBUG(); if (_fragShader) { //连接程序与着色器 glAttachShader(\\_program, \\_fragShader); } _hashForUniforms.clear(); CHECK\\_GL\\_ERROR_DEBUG(); return true;} 6链接程序： bool GLProgram::link(){ CCASSERT(_program != 0, “Cannot link invalid program”); GLint status = GL_TRUE; bindPredefinedVertexAttribs(); //链接程序 glLinkProgram(_program); // Calling glGetProgramiv(...GL\\_LINK\\_STATUS...) will force linking of the program at this moment. // Otherwise, they might be linked when they are used for the first time. (I guess this depends on the driver implementation) // So it might slow down the &quot;booting&quot; process on certain devices. But, on the other hand it is important to know if the shader // linked succesfully. Some shaders might be downloaded in runtime so, release version should have this check. // For more info, see Github issue #16231 glGetProgramiv(\\_program, GL\\_LINK_STATUS, &amp;status); if (status == GL_FALSE) { CCLOG(&quot;cocos2d: ERROR: Failed to link program: %i&quot;, _program); GL::deleteProgram(_program); _program = 0; } else { parseVertexAttribs(); parseUniforms(); clearShader(); } return (status == GL_TRUE);} 使用着色器 void GLProgram::use(){ GL::useProgram(_program);} 删除与清理 inline void GLProgram::clearShader(){ if (_vertShader) { glDeleteShader(_vertShader); } if (_fragShader) { glDeleteShader(_fragShader); } \\_vertShader = \\_fragShader = 0;} cocos引擎renderer/CCGLProgramCache文件定义GLProgramCache单例类缓存管理GLProgram 对象(shaders)，同时管理众多内置的Shaders。 在链接程序中如下的函数： bool GLProgram::link(){ … //绑定顶点着色器的变量名称与位置 //从程序传给shader变量，比如：顶点位置，颜色，UV坐标等 bindPredefinedVertexAttribs(); ... if (status == GL_FALSE) { ... } else { //将顶点的属性变量的名称及位置存储与类变量：_vertexAttribs parseVertexAttribs(); //将顶点的属性常量的名称及位置存储与类变量：_userUniforms parseUniforms(); ... } return (status == GL_TRUE);} 这些函数将在下一节将介绍：顶点属性、顶点数组和缓冲区对象。 示例程序开源托管在Github: CocosShader 这一篇对过程介绍的比较清楚，推荐阅读：OpenGL ES 2.0 Shader相关介绍","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Cocos OpenGL/ES学习之一—你好，三角形（2）着色器GLSL","slug":"cocos/e8-a7-92-e5-a8glsl","date":"2016-12-15T04:25:42.000Z","updated":"2019-11-08T09:59:30.972Z","comments":true,"path":"2016/12/15/cocos/e8-a7-92-e5-a8glsl/","link":"","permalink":"http://blog.le-more.com/2016/12/15/cocos/e8-a7-92-e5-a8glsl/","excerpt":"","text":"在上一篇介绍在cocos中如果使用自定义shader，通过OpenGL ES绘制一个三角形，下面来对其实现进行分析一下。 初始化部分加载一个顶点着色器和一个片段着色器，下面对两个着色器做一个简单的注解： 顶点着色程序： //输入变量，顶点位置attribute vec4 a_position;//输入变量，顶点颜色attribute vec4 a_color; //输出变量片段颜色varying vec4 v_fragmentColor; void main(){ //顶点位置通过模型、视图、投影矩阵点乘顶点坐标转化为裁剪空间位置 //CC_MVPMatrix 是cocos提供的实现（待确定） gl_Position = CC_MVPMatrix * a_position; v_fragmentColor = a_color;} 片段着色器 //输入变量varying vec4 v_fragmentColor; void main(){ //给内置片段着色变量赋值 gl_FragColor = v_fragmentColor;} 当前cocos版本（3.13）使用的OpenGL ES版本是2.0，和最新的3.0规范不同。在着色器程序的开头一般有版本的声明： #version 300 es 如果开头没有版本声明，默认是OpenGL ES 2.0的着色器程序，但要注意声明的版本号不是200，因为OpenGL ES 2.0区别与1.0，1.1是第一个可编程的API，它的着色器版本是1.0。 着色器程序中的变量限定符转自一篇博文说的很清楚：原文地址 1.uniform变量 uniform变量是外部application程序传递给（vertex和fragment）shader的变量。因此它是application通过函数glUniform**（）函数赋值的。在（vertex和fragment）shader程序内部，uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。（shader只能用，不能改） 如果uniform变量在vertex和fragment两者之间声明方式完全一样，则它可以在vertex和fragment共享使用。（相当于一个被vertex和fragment shader共享的全局变量）uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。 以下是例子： uniform mat4 viewProjMatrix; //投影+视图矩阵 uniform mat4 viewMatrix; //视图矩阵 uniform vec3 lightPosition; //光源位置 2.attribute变量 attribute变量是只能在vertex shader中使用的变量。（它不能在fragment shader中声明attribute变量，也不能被fragment shader中使用）。一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。 在application中，一般用函数glBindAttribLocation（）来绑定每个attribute变量的位置，然后用函数glVertexAttribPointer（）为每个attribute变量赋值。 以下是例子： uniform mat4 u_matViewProjection; attribute vec4 a_position; attribute vec2 a_texCoord0; varying vec2 v_texCoord; void main(void) { gl_Position = u_matViewProjection * a_position; v_texCoord = a_texCoord0; } 3.varying变量 varying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。application不能使用此变量。 以下是例子： // Vertex shader uniform mat4 u_matViewProjection; attribute vec4 a_position; attribute vec2 a_texCoord0; varying vec2 v_texCoord; // Varying in vertex shader void main(void) { gl_Position = u_matViewProjection * a_position; v_texCoord = a_texCoord0; } // Fragment shader precision mediump float; varying vec2 v_texCoord; // Varying in fragment shader uniform sampler2D s_baseMap; uniform sampler2D s_lightMap; void main() { vec4 baseColor; vec4 lightColor; baseColor = texture2D(s_baseMap, v_texCoord); lightColor = texture2D(s_lightMap, v_texCoord); gl_FragColor = baseColor * (lightColor + 0.25); } （1）attribute变量(属性变量)只能用于顶点着色器中，不能用于片元着色器。一般用该变量来表示一些顶点数据，如：顶点坐标、纹理坐标、颜色等。 （2）uniforms变量(一致变量)用来将数据值从应用程其序传递到顶点着色器或者片元着色器。该变量有点类似C语言中的常量（const），即该变量的值不能被shader程序修改。一般用该变量表示变换矩阵、光照参数、纹理采样器等。 （3）varying变量(易变变量)是从顶点着色器传递到片元着色器的数据变量。顶点着色器可以使用易变变量来传递需要插值的颜色、法向量、纹理坐标等任意值。在顶点与片元shader程序间传递数据是很容易的，一般在顶点shader中修改varying变量值，然后片元shader中使用该值，当然，该变量在顶点及片元这两段shader程序中声明必须是一致的。例如：上面代码中应用程序中由顶点着色器传入片元着色器中的vColor变量。 （4）gl_Position为内建变量，表示变换后点的空间位置。顶点着色器从应用程序中获得原始的顶点位置数据，这些原始的顶点数据在顶点着色器中经过平移、旋转、缩放等数学变换后，生成新的顶点位置。新的顶点位置通过在顶点着色器中写入gl_Position传递到渲染管线的后继阶段继续处理。 参考下面两张图来理解上面的定义： ) 两个着色器程序很简单，但在OpenGL ES中必须至少包含一个顶点着色器程序和一个片段程序，否则不会出现任何图形。 初始化着色器: auto glProgram = GLProgram::createWithByteArrays(vShaderStr, fShaderStr);auto state = GLProgramState::getOrCreateWithGLProgram(glProgram);setGLProgramState(state); cocos通过上面代码加载，编译着色器程序，欲了解cocos对OpenGL ES封装，下一篇再介绍。 示例程序开源托管在Github: CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Cocos OpenGL/ES学习之一—你好，三角形（1）概览","slug":"cocos/ef-bc-8c-e4-b8-89","date":"2016-12-14T03:27:00.000Z","updated":"2019-11-08T09:59:30.973Z","comments":true,"path":"2016/12/14/cocos/ef-bc-8c-e4-b8-89/","link":"","permalink":"http://blog.le-more.com/2016/12/14/cocos/ef-bc-8c-e4-b8-89/","excerpt":"","text":"cocos 版本为3.13.1，后续可能会根据cocos版本的升级变的不同。 本篇基于cocos引擎，使用OpenGL/ES实现一个三角形。 先看一下效果图： 函数声明： //函数声明//重载父类函数virtual void draw(cocos2d::Renderer *renderer, const cocos2d::Mat4 &amp;transform, uint32_t flags) override;//自定义绘图函数void onDraw(const cocos2d::Mat4&amp; transform, uint32_t flags); 函数实现： void Triangle::draw(Renderer *renderer, const Mat4 &amp;transform, uint32_t flags){ _customCommand.init(_globalZOrder, transform, flags); _customCommand.func = CC_CALLBACK_0(Triangle::onDraw, this, transform, flags); renderer-&gt;addCommand(&amp;_customCommand);} void Triangle::onDraw(const Mat4&amp; transform, uint32_t flags){ //获取程序对象 auto glProgram = getGLProgram(); //设置为活动程序 glProgram-&gt;use(); //设置统一变量（通过API传送给着色器源码的只读常量） glProgram-&gt;setUniformsForBuiltins(); auto winSize = Director::getInstance()-&gt;getWinSize(); //顶点坐标 float vertercies[] = { 0, 0 ,winSize.width, 0, winSize.width / 2, winSize.height }; //顶点颜色 float color[] = { 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1 }; //启用position和color的vertex attribute GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POSITION | GL::VERTEX_ATTRIB_FLAG_COLOR); //glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer):加载顶点数据 //index:顶点属性的索引值 //size:每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）） //type:顶点的数据类型 //normalized:是否归一化 //stride:顶点属性之间的偏移量 //pointer:指定第一个组件在数组的第一个顶点属性中的偏移量 glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertercies); glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_FLOAT, GL_FALSE, 0, color); //glDrawArrays (GLenum mode, GLint first, GLsizei count):绘制三角形 //mode:GL_POINTS、GL_LINES、GL_LINE_LOOP、GL_LINE_STRIP、GL_TRIANGLES、GL_TRIANGLE_STRIP、GL_TRIANGLE_FAN //first: 9 //count: 3 glDrawArrays(GL_TRIANGLES, 0, 3); //添加draw batches和顶点数目 CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, 3); //检测是否产生错误，如果有打印错误信息 CHECK_GL_ERROR_DEBUG();} 初始化： bool Triangle::init(){ bool ret = false; do { CC_BREAK_IF(false == TestCase::init()); char vShaderStr\\[\\] = &quot;attribute vec4 a_position; \\\\n&quot; &quot;attribute vec4 a_color; \\\\n&quot; &quot;varying vec4 v_fragmentColor; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; gl\\_Position = CC\\_MVPMatrix * a_position;\\\\n&quot; &quot; v\\_fragmentColor = a\\_color; \\\\n&quot; &quot;} \\\\n&quot;; char fShaderStr\\[\\] = &quot;varying vec4 v_fragmentColor; \\\\n&quot; &quot;void main() \\\\n&quot; &quot;{ \\\\n&quot; &quot; gl\\_FragColor = v\\_fragmentColor; \\\\n&quot; &quot;} \\\\n&quot;; // init shader //auto glProgram = GLProgram::createWithFilenames(&quot;Shaders/vert.vsh&quot;, &quot;Shaders/frag.fsh&quot;); auto glProgram = GLProgram::createWithByteArrays(vShaderStr, fShaderStr); auto state = GLProgramState::getOrCreateWithGLProgram(glProgram); setGLProgramState(state); ret = true; } while (0); return ret;} 通过上面的代码及设置，就可以使用自定义的Shader了。在下一篇中对上面的代码进行一下分析。 示例程序开源托管在Github: CocosShader","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"Wordpress 手动更新","slug":"tools/wordpress-e6-89-8d","date":"2016-12-13T03:39:05.000Z","updated":"2019-11-08T09:59:31.005Z","comments":true,"path":"2016/12/13/tools/wordpress-e6-89-8d/","link":"","permalink":"http://blog.le-more.com/2016/12/13/tools/wordpress-e6-89-8d/","excerpt":"","text":"注意更新前要备份！ 删除原版本目录： wp-includes wp-admin 删除新版本中的目录： wp-content 复制新版本中的所有文件到原版本中（覆盖）。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"Unity3D Shader学习之十一—Shader性能优化","slug":"u3d/unity-e6-80-a7-e8-83-bd-e13","date":"2016-12-02T02:21:18.000Z","updated":"2019-11-08T09:59:31.025Z","comments":true,"path":"2016/12/02/u3d/unity-e6-80-a7-e8-83-bd-e13/","link":"","permalink":"http://blog.le-more.com/2016/12/02/u3d/unity-e6-80-a7-e8-83-bd-e13/","excerpt":"","text":"使用常识 编写功能必要的部分，舍弃不必要的Shader(同样适用于代码，资源优化) 模型数&lt;顶点数&lt;像素数，能在脚本能实现的不要在顶点着色器去实现，能在顶点着色器做的不要在片段着色器做。 需要针对平台进行优化，不要使用PC着色器直接用于移动平台 计算精度当使用Cg/HLSL来写着色器的时候，主要会用到三种基本的数据类型：float，half和fixed（以及由他们组成的向量和矩阵变量，即half3和float4x4） float：高精度浮点型。一般是32位，就像是正规编程语言中的单精度浮点类型。 half：中等精度浮点型。一般是16位，范围是-60000到+60000以及3.3 的十进制数字的精度。 fixed：低精度浮点型。一般是11位，范围是-2.0到+2.0以及1/256th 精度。 尽可能地使用最低的精度，这点对于iOS和Android平台特别重要。推荐的经验法则： 对于颜色和单位长度的向量，使用fixed. 对于其他的，如果范围和精度允许的话，使用half，否则使用float。 在移动平台上，关键是在片段着色器中使用尽可能多低精度数据计算。在大多数移动设备的GPU中，在低精度 （fixed/lowp） 类型上应用swizzles是比较耗时的；同时，在fixed/lowp 和高精度类型之间进行转换也是需要付出很大代价的。 如果用GLSL ES编写的着色器，浮点精确度规定如下： highp - 32位浮点格式，适合用于顶点变换，但性能最慢。 mediump - 16位浮点格式，适用于纹理UV坐标和比highp 大约快两倍 lowp - 10位的顶点格式，适合对颜色，照明计算和其它高性能操作，速度大约是highp 的4倍 如果是用CG编写的着色器或是一个表面着色器，指定精度如下： float - 类似于在GLSL ES 的highp ，最慢 half - 类似于在GLSL ES 的mediump ，比float大约快两倍 fixed - 类似于在GLSL ES的lowp，速度大约是float 的4倍使用技巧 fixed / lowp 用于颜色，灯光信息和法线 half / mediump 用于纹理UV坐标 float / highp 避免在像素着色器，而是使用顶点着色器，计算顶点的位置。 复杂的数学运算 复杂的数学函数（如pow，exp，log，cos，sin，tan等等）会大大增加GPU负担，所以一个好的经验法则是，每一个片段不超过一个这样的操作。考虑使用查找纹理作为替代品。 不要尝试编写自己的normalize，dot，inversesqrt 等操作。然而如果您使用内置的，会为你产生更好的代码。 紧记discard 操作，会使你的帧速度变慢。 Alpha测试固定函数AlphaTest或者与其等功能的可编程函数clip()在不同的平台上拥有不同的性能特点： 一般来说，用它在大多数平台上来剔除完全透明的像素具有一点小小的优势。 但是，在IOS设备上的PowerVR GPU和一些Android设备中，alpha test是比较耗时的。不要尝试应用它来优化性能，因为它将使性能变得更慢。 4.颜色掩码 在某些平台上 （大多是iOS移动设备上的GPU和Android 设备），使用 ColorMask 中删除一些通道(例如 ColorMask RGB) 也是比较昂贵的，因此，除非真有必要，否则不要使用它。 性能瓶颈CPU draw call 复杂的脚本或物理模拟 GPU 顶点处理 1.顶点数目 2.顶点计算 片元处理 1.片元数目 2.逐片元计算 带宽 纹理尺寸及压缩 分辨率过高的帧缓存 性能优化 动态批处理 静态批处理 优化几何体-移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离 LOD（Level of Detail） 遮挡剔除技术 控制绘制顺序 注意透明物体 减少实时光照和阴影 其他 纹理优化 代码优化 分析工具 Unity编辑器Game窗口的Stats Unity编辑器Windows/Profiler Unity编辑器Windows/Frame Debug 整理自官网及Unity圣典（翻译），入门精要（书籍），主要针对Shader开发，对于其他优化待续 官网：Optimization for Mobiles Optimizing graphics performance 圣典：优化图形性能 移动优化","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"},{"name":"优化","slug":"优化","permalink":"http://blog.le-more.com/tags/优化/"}]},{"title":"Git 常用命令及使用总结","slug":"tools/git-e5-b8-b8-e7-94-a8","date":"2016-11-25T10:22:51.000Z","updated":"2019-11-08T09:59:31.001Z","comments":true,"path":"2016/11/25/tools/git-e5-b8-b8-e7-94-a8/","link":"","permalink":"http://blog.le-more.com/2016/11/25/tools/git-e5-b8-b8-e7-94-a8/","excerpt":"","text":"git init 初始化一个版本库 git clone 签出一个版本库 git add 添加资源到本地版本库 git commit 提交改动到本地版本库 git pull 从服务端拉取，如果有改动合并到本地。将服务端同步到本地 git push 将本地修改推送到服务端，将本地同步到服务端 工作流程： 1.开始 git clone 签出版本 2.工作 一天开始—》同步服务端到本地（git pull ）—》增删改项目（git add、git delete 本地操作）—》同步本地到服务端（git push）—》一天结束 这些是基本的git命令，实际工作中使用TortoiseGit 要方便一些。多人时会遇到冲突及手动合并的操作。 .gitignore 文件的创建1.使用Git Bash Here 打开命令窗口 2. 输入 vim .gitignore 3. :wq 保存并退出。 签出指定分支签出远程工程到本地目录git clone https://github.com/EpicGames/UnrealEngine.git列出所有分支git branch -a签出远程 origin/4.13分支到本地4.13分支,并切换到这个分支git checkout -b 4.13 origin/4.13切换到4.13分支git checkout 4.13 撤销指定提交//查看loggit log //撤销到指定版本号git reset –soft f8be079b545a66fe3cecff5af87b126d6e8c9874 //强制提交到服务端git push origin winsdk –force 删除指定分支：#. update the references in our local machinegit fetch -p origin #.查看本地和远程分支git branch -a #. 先切换到其他分支git checkout master #.删除远程分支git push origin –delete dev_xue # 删除后，再次查看分支情况git branch -a # 删除本地分支git branch -d dev_xue 问题：Please make sure you have the correct access rights //生成public keyssh-keygen -t rsa -C “xue_huashan@163.com“,//xue_huashan@163.com是你git操作的账号。 Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xuegang-pc/.ssh/id_rsa): //回车Enter passphrase (empty for no passphrase): //回车Enter same passphrase again: //回车Your identification has been saved in /c/Users/xuegang-pc/.ssh //显示内容cat /c/Users/xuegang-pc/.ssh/id_rsa.pub //将内容复制到Web帐户中的SSH Keys","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"Github 创建项目","slug":"tools/github-e5-88-9b-e5-bc","date":"2016-11-25T05:01:03.000Z","updated":"2019-11-08T09:59:31.003Z","comments":true,"path":"2016/11/25/tools/github-e5-88-9b-e5-bc/","link":"","permalink":"http://blog.le-more.com/2016/11/25/tools/github-e5-88-9b-e5-bc/","excerpt":"","text":"1.注册帐户，登录； 2.下载git 客户端安装，下载地址：git-for-windows； 3.在github 首页点击”Start a project”； 4.输入项目名称以前其他设置； 5.快速设置项目； 在这个步骤中，提供设置项目的几种情况，全新项目选择：…or create a new repository on the command line 6.根据第5步，在本地磁盘，创建UnityShader目录，鼠标右击选择Git Bash Here； 7.使用第5步选择的命令依次执行。 Git Client: https://git-scm.com/downloads TortoiseGit: https://tortoisegit.org/download/ 习惯了使用Tortoise SVN,Tortoise Hg,还是使用这个比较好","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"Unity3D Shader学习之十—释疑解惑","slug":"u3d/unity3d-shader-e5-ad-a6-e6","date":"2016-11-10T04:11:48.000Z","updated":"2019-11-08T09:59:31.032Z","comments":true,"path":"2016/11/10/u3d/unity3d-shader-e5-ad-a6-e6/","link":"","permalink":"http://blog.le-more.com/2016/11/10/u3d/unity3d-shader-e5-ad-a6-e6/","excerpt":"","text":"总结一下自己在学习过程中，令人困惑不解的问题及解答。 1、OpenGL/OpenGL ES、DirectX是什么？ 在GPU发展的早期，是不支持编程的。随着产品的更新换代、技术的革新，逐渐放开了控制接口，即固定功能着色器，但开始只能通过低级语言来使用有限的控制。接着 vertex programmability（顶点着色器编程）和 fragment programmability （片段着色器编程）相继出现，就诞生了GPU编程。GPU编程与硬件有很大的关系，GPU的品牌又很多，与硬件无关的图形开发库存在就可以解决这个问题，这个开发库就是OpenGL、DirectX，开发者可以绕过各种硬件，直接使用图形接口就可以开发出支持众多的显卡。但前提是各显示需要在硬件驱动程序中支持OpenGL或DirectX。 可见OpenGL/DirectX就是图形应用程序编程接口，GPU开发者藉此以开发图形应用程序。 2、3D模型是什么？材质，着色器，纹理,贴图定义与区别？UV是什么？ 3D模型是指通过软件制作出来的三维立体图形，在Unity里是通过3DMax或Maya等软件制作导入，支持读取FBX，DAE（collada一种开源的3D格式），3DS ,DFX和OBJ格式的模型 材质（Material）是描述渲染模型对象时的属性和资源，如使用什么着色器，使用什么纹理。材质应用到模型上，来改变模型的属性与外观。 材质是着色器的实例，相同的着色器可以创建不同的材质（配置和参数不同）！ 着色器（Shader）包含定义要使用的属性和资源类型的代码（顶点着色器、片段着色器），着色器需要通过材质才能发挥作用。 纹理(Textures) 使网格 (Meshes)、粒子 (Particles) 和界面变得生动！它是覆盖或环绕对象的图像或电影文件。纹理分为2D纹理，2D纹理数组，3D纹理，立方图(Cubemap)纹理。纹理是应用到一个网格表面，为其添加网格的几何形状无法表达的额外的信息。 对于材质，纹理只是用于提供某种基于像素的数据的图像。这些数据可能是对象的颜色、光泽度、透明度以及各种其他方面。 贴图美术人员称之为贴图，图形渲染中称之为纹理，Unity中没有贴图概念，纹理概念与之对应。贴图一般有法线贴图(Normal)、高光贴图（Specular），金属贴图(Metalic)等 UV纹理映射坐标（texture-mapping coordinates）存储在每个顶点上，区别于顶点的位置(x,y,z),使用(u,v,w)来表示顶点在纹理上的位置，纹理经常以2D图片的形式提供，所以就称为UV坐标。 从前面的各定义可知网格 (Meshes)包含—材质(Material)包含—着色器(Shader)包含—纹理（Textures）/贴图。 UV坐标属于顶点的属性。 3、顶点是什么？ 在图形API中，基本的绘制图元有三角形、直线、点精灵。顶点数目分别是3、2、1；一个立方体模型是由6个面组成，每个面由2个三角形构成的，因此只有8个顶点（重合一部分）。顶点包含顶点位置（POSITION）、切线（TANGENT）、法线（NORMAL）、纹理坐标（TEXCOORD0TEXCOORD6）、颜色（COLOR）属性。 4、顶点着色器的输入及调用是怎么样的？片段着色器呢？ 顶点着色器(Vertex) 函数的输入来自应用程序中模型。调用是逐顶点调用的，模型有多少顶点就调用多少次。输入的参数内容就是顶点的位置（POSITION）、切线（TANGENT）、法线（NORMAL）、纹理坐标（TEXCOORD0TEXCOORD6）、颜色（COLOR）属性。 片段着色器(Fragment)函数输入来自顶点着色器，逐片段调用的，每个片元(像素?)调用一次。输入的参数有裁剪空间坐标（SV_POSITION），顶点颜色（COLOR0~COLOR1)，纹理坐标(TEXCOORD0-TEXCOORD7) 5、POSITION、TEXCOORD0什么意思？ 这些在Unity Shader中叫做语义，可以理解为属性在Shader编程中内定的含义。比如下面的定义： //应用程序(Application)传到顶点(Vertex)struct a2v{ float4 vertex : POSITION;//vertex表示顶点的位置 float3 normal : NORMAL;//normal变量表示顶点的法向量}; 格式是 [类型] [变量名] : [语义] 6、Unity 5系统自带的着色器模板有哪些？ Unity5中有4种模板: Standard Surface Shader:包含标准光照模型（物理渲染）的表面着色器模板； Unlit Shader:不包含光照 ，包含雾效的顶点/片段着色器； Image Effect Shader:屏幕后期处理特效模板； Compute Shader:利用GPU的并行性进行与常规渲染无关的计算。 7、颜色相加与颜色相乘 相加：多种光源作用在同一材质上，比如：实际光照强度 I= 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular) 相乘：颜色的非等比缩放，例如，光通過有色玻璃時，玻璃吸收某百分比的紅、藍、綠，就可以把光的紅藍綠強度分別乘以對應的百分比","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之九—Shader Debug","slug":"u3d/unity3d-shader-e5-e4shader-debug","date":"2016-11-10T02:14:32.000Z","updated":"2019-11-08T09:59:31.035Z","comments":true,"path":"2016/11/10/u3d/unity3d-shader-e5-e4shader-debug/","link":"","permalink":"http://blog.le-more.com/2016/11/10/u3d/unity3d-shader-e5-e4shader-debug/","excerpt":"","text":"无论编程技术如何炉火纯青，编写的程序都无法避免出现Bug。于是一个好的排错工具尤为重要，下面来介绍下Shader开发中如何Debug Cg代码。 …","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader示例之—AR涂涂乐实现方法","slug":"u3d/ar-e6-b6-82-e6-b6-82","date":"2016-11-07T03:22:39.000Z","updated":"2019-11-08T09:59:31.009Z","comments":true,"path":"2016/11/07/u3d/ar-e6-b6-82-e6-b6-82/","link":"","permalink":"http://blog.le-more.com/2016/11/07/u3d/ar-e6-b6-82-e6-b6-82/","excerpt":"","text":"Unity3D Shader示例之—AR涂涂乐项目实战 在上一篇中分析了涂涂乐的实现原理，下面来分析一下具体的实现方法。 动态的提取摄像机获取的图像颜色应用于模型就需要着色器来实现了， //着色器命名，在编程器右键菜单中除了展示其他着色器，还会展示Samples&gt;TextureSampleShader “Samples/TextureSample” { //属性定义，会在编辑器中显示 Properties { //[内部名称]([编辑器显示名],类型) = 默认值 _MainTex(“Base (RGB)”, 2D) = “white” {} _Uvpoint1(“point1”, Vector) = (0 , 0 , 0 , 0) _Uvpoint2(“point2”, Vector) = (0 , 0 , 0 , 0) _Uvpoint3(“point3”, Vector) = (0 , 0 , 0 , 0) _Uvpoint4(“point4”, Vector) = (0 , 0 , 0 , 0) } SubShader { //Queue 渲染队列,控制渲染的顺序，在渲染透明模型时需要注意 //“RenderType”=”Transparent”渲染透明类型,控制渲染的类型 Tags { “Queue”=”Transparent” “RenderType”=”Transparent” } //Level of Detail 为200 LOD 200 Pass{ //开启混合，并设置混合因子，源颜色（该片元产生的颜色）会乘以SrcFactor,而目标颜色(已经存在于颜色缓冲区的颜色)会乘以DstFactor，然后把两者相加后再存入颜色缓冲区 //混合后的颜色：DstColor = SrcAlpha x SrcColor + (1 - SrcAlpha) x DstColor Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert//顶点着色器 #pragma fragment frag//片段着色器 #include &quot;UnityCG.cginc&quot;//包含内置文件 //定义与属性声明内部名称一样的的变量名，才能使用属性部分的值 sampler2D _MainTex; //\\_MainTex\\_ST.xy存储的是缩放，\\_MainTex\\_ST.zw存储的是偏移 float4 \\_MainTex\\_ST; float4 _Uvpoint1; float4 _Uvpoint2; float4 _Uvpoint3; float4 _Uvpoint4; //vertex to fragment 顶点传到片段的结构定义 struct v2f { float4 pos : SV_POSITION;//裁剪空间的顶点坐标 float2 uv : TEXCOORD0;//第一组纹理坐标 float4 fixedPos : TEXCOORD2;//第三组纹理坐标 } ; /* 带有位置、法线和一个纹理坐标的顶点着色器输入 struct appdata_base { float4 vertex : POSITION;//位置 float3 normal : NORMAL;//法线 float4 texcoord : TEXCOORD0;//纹理坐标 }; / v2f vert (appdata_base v) { v2f o; //UNITY_MATRIX_MVP：当前模型观察*投影矩阵 //把顶点坐标转换到齐次裁剪坐标系下 //用于将顶点/方向矢量从模型空间变换到裁剪空间 o.pos = mul(UNITY_MATRIX_MVP,v.vertex); //拿顶点的uv去和材质球的tiling和offset作运算，确保材质球里的缩放和偏移设置是正确的（v.texcoord就是模型顶点的uv） //为给定的纹理计算其uv坐标，即根据mesh上的uv坐标(v.texcoord)来计算真正的纹理上对应的位置 //等同于 o.uv = v.texcoord.xy *_MainTex_ST.xy + _MainTex_ST.zw; //对顶点纹理进行运算得到最终的纹理坐标 o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); //lerp(a,b,f)==(1-f)\\*a + b\\*f = a + (b-a)*f //获取修正后的坐标 //根据当前的uv坐标获取在x方向和y方向的线性插值 float4 top = lerp(\\_Uvpoint1, \\_Uvpoint3, o.uv.x); float4 bottom = lerp(\\_Uvpoint2, \\_Uvpoint4, o.uv.x); //fixedPos为世界坐标 float4 fixedPos = lerp(bottom, top, o.uv.y); //UNITY\\_MATRIX\\_VP:用于将顶点/矢量从世界空间变换到裁剪空间 //ComputeScreenPos:裁剪空间坐标转换为屏幕空间坐标 //世界坐标-》裁剪坐标-》屏幕坐标 o.fixedPos = ComputeScreenPos(mul(UNITY\\_MATRIX\\_VP, fixedPos)); return o; } float4 frag (v2f i) : COLOR { //i.fixedPos.xy / i.fixedPos.w得到视口空间中的坐标,视口坐标范围\\[(0,0),(1,1)\\] //i.fixedPos是屏幕坐标，齐次除法后得到视口坐标 //tex2D 二维纹理查询 在一张贴图中对一个点进行采样的方法，返回一个float4 return tex2D(_MainTex, i.fixedPos.xy / i.fixedPos.w); } ENDCG } } //FallBack “Diffuse”} 在上面的着色器代码中，定义了一个纹理输入属性和和四个矢量属性。着色通过四个位置定义获取纹理的颜色采样。将此着色器应用于将要展示的涂涂乐模型。 着色器的输入就需要通过程序来动态提供了： using UnityEngine;using Vuforia; public class Coloring3DBehaviour : MonoBehaviour{ Camera cam; RenderTexture renderTexture; ImageTargetBehaviour targetBehaviour; void Start() { targetBehaviour = GameObject.Find(&quot;ImageTarget&quot;).GetComponent&lt;ImageTargetBehaviour&gt;(); //GetComponentInParent&lt;ImageTargetBehaviour&gt;(); gameObject.layer = 31; } void Renderprepare() { if (!cam) { GameObject go = new GameObject(&quot;__cam&quot;); cam = go.AddComponent&lt;Camera&gt;(); go.transform.parent = transform.parent; cam.hideFlags = HideFlags.HideAndDontSave; } cam.CopyFrom(Camera.main); cam.depth = 0; cam.cullingMask = 31; if (!renderTexture) { renderTexture = new RenderTexture(Screen.width, Screen.height, -50); } cam.targetTexture = renderTexture; cam.Render(); GetComponent&lt;Renderer&gt;().material.SetTexture(&quot;_MainTex&quot;, renderTexture); } void OnWillRenderObject() { if (!targetBehaviour || targetBehaviour.ImageTarget == null) return; //一半的大小是(0.5,0.3) //识别图大小是(512,326) //targetBehaviour.GetSize()是ImageTarget在Unity场景的中单位(Unity scene units)大小(1,0.6) //Vuforia默认的单位是米 Vector2 halfSize = targetBehaviour.GetSize() * 0.5f; //获取世界坐标，识别图的4个拐角世界坐标 //图片(模型)坐标原点在中心点，因是二维的所以y为0,通过一半的大小参数得到4个角的局部坐标 Vector3 targetAnglePoint1 = transform.parent.TransformPoint(new Vector3(-halfSize.x, 0, halfSize.y)); Vector3 targetAnglePoint2 = transform.parent.TransformPoint(new Vector3(-halfSize.x, 0, -halfSize.y)); Vector3 targetAnglePoint3 = transform.parent.TransformPoint(new Vector3(halfSize.x, 0, halfSize.y)); Vector3 targetAnglePoint4 = transform.parent.TransformPoint(new Vector3(halfSize.x, 0, -halfSize.y)); Renderprepare(); //设置Shader参数 GetComponent&lt;Renderer&gt;().material.SetVector(&quot;_Uvpoint1&quot;, new Vector4(targetAnglePoint1.x, targetAnglePoint1.y, targetAnglePoint1.z, 1f)); GetComponent&lt;Renderer&gt;().material.SetVector(&quot;_Uvpoint2&quot;, new Vector4(targetAnglePoint2.x, targetAnglePoint2.y, targetAnglePoint2.z, 1f)); GetComponent&lt;Renderer&gt;().material.SetVector(&quot;_Uvpoint3&quot;, new Vector4(targetAnglePoint3.x, targetAnglePoint3.y, targetAnglePoint3.z, 1f)); GetComponent&lt;Renderer&gt;().material.SetVector(&quot;_Uvpoint4&quot;, new Vector4(targetAnglePoint4.x, targetAnglePoint4.y, targetAnglePoint4.z, 1f)); } void OnDestroy() { if (renderTexture) DestroyImmediate(renderTexture); if (cam) DestroyImmediate(cam.gameObject); }} 将上面的代码添加到涂涂乐模型上即可。代码比较简单，不再详述。 着色器和代码来自国内一家提供增强现实服务的公司，他们的AR SDK中有相应的示例，感兴趣可移步这里","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"},{"name":"ar","slug":"ar","permalink":"http://blog.le-more.com/tags/ar/"}]},{"title":"Unity3D Shader示例之—AR涂涂乐实现原理","slug":"u3d/unity3d-shader-e5-ad-a6-e4","date":"2016-11-06T04:30:52.000Z","updated":"2019-11-08T09:59:31.030Z","comments":true,"path":"2016/11/06/u3d/unity3d-shader-e5-ad-a6-e4/","link":"","permalink":"http://blog.le-more.com/2016/11/06/u3d/unity3d-shader-e5-ad-a6-e4/","excerpt":"","text":"Unity3D Shader示例之—AR涂涂乐项目实战 当传统游戏日渐泛滥的今天，通过新的技术能迅速找到突破口，AR/VR就是当前比较热门的技术。前段时间引爆全球的口袋怪物，以及通过AR打造自己IP的小熊尼奥（口袋动物园，口袋交通等），还有比较知名的游戏AR涂涂乐等。现在就来分析一下AR涂涂乐之技术实现。 先看下面两张图：（来自于AR涂涂乐，第二张是我PS涂的） 功能描述：一张卡片，上面或是人物、动物或其他物体的空白图片（如上图左），涂上颜色（如上图右）。通过AR识别上图（右），展示跳舞的小女孩（小女孩的颜色就是刚涂的颜色）。 技术分析：1、通过AR识别图片展示模型；2、通过提取所涂颜色应用于模型。 具体实现： 一、通过AR识别图片展示模型 通过AR sdk实现单张图片识别，当前使用的是Vuforia，开发环境Unity3D。因为这个较为简单，不再详述，特别提示遇到一个看似简单但困惑的问题。 二、通过提取所涂颜色应用于模型 首先通过摄像头获得涂抹后的图片，然后提取涂抹颜色应用于模型指定区域。如何将识别的图片，将涂抹区域能正确的映射到模型上呢？就需要在制作模型将UV区域分配到涂抹图片的位置。查看下面图片： 原理看似很简单，具体究竟是如何实现呢？ 请看下节的具体的实现细节。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之九—纹理","slug":"u3d/unity3d-shader-e5-ad-a6-e5","date":"2016-11-05T04:11:14.000Z","updated":"2019-11-08T09:59:31.031Z","comments":true,"path":"2016/11/05/u3d/unity3d-shader-e5-ad-a6-e5/","link":"","permalink":"http://blog.le-more.com/2016/11/05/u3d/unity3d-shader-e5-ad-a6-e5/","excerpt":"","text":"纹理使你的网格、粒子、和界面更生动！它们是你覆盖或环绕着对象的图片或影片文件。由于它们是如此的重要，它们有很多的属性。 详情参考官方文档：Textures Texture Type 纹理类型： Texture:通常这是适用于所有纹理的最常用设置; 法线纹理（Normal map):将把颜色通道变成一个适合于实时法向映射的格式; GUI 图形用户界面(已经废弃)：如果你的纹理是要用于任何HUD（平面显示器） / GUI的控制，使用该项; 立方图纹理(Cubemap):也称Reflection 反射,用于创建纹理的反射（使用全景图片，创建天空盒）; Cookie:这将设置带基本参数的纹理用于你的光源的Cookie Advanced 高级:当你想要有纹理的具体参数并想拥有纹理的完全控制的时候选择该项。 属性： Wrap Mode:当纹理坐标超出[0,1]如何显示 Repeat:纹理重复（平铺）本身； Clamp：超出截取到[0,1]纹理的边缘得到延伸（创建天空盒时，纹理设置此选项，否则有空隙） Filter Mode：选择纹理通过三维变换得到拉伸时如何过滤。 Point：纹理在近距离变成块状； Bilinear：纹理在近距离变模糊； Trilinear：类似双线性，但纹理也在不同的mipmap层次之间变模糊。 性能消耗依次增大。 Aniso Level 在一个过高角度看纹理时提高纹理质量。适用于地板与地面纹理。 Alpha from Grayscale:透明通道的值将会由每个像素的灰度值生成,将依据图像的现有明暗值产生一个alpha透明度通道 Bumpiness 凹凸:控制凹凸的总量 Filtering 过滤: 确定凹凸如何计算出来 1.Smooth 平滑:这会产生比较平滑的法线贴图; 2.Sharp 锐化:也称为索贝尔过滤。这会产生出比标准更清晰的法线贴图 Mapping 映射：这将决定纹理如何映射到一个立方体贴图上 1. Sphere Mapped 球面映射：纹理映射到一个”球状” 立方体贴图上 2. Cylindrical 圆柱：纹理映射到一个圆柱体，当你要使用类似圆柱对象的反射时，使用该项。 3. Simple Sphere 简单球形：纹理映射到一个简单的球形，当你旋转它时变形反射 4.Nice Sphere 精细球形：纹理映射到一个球形，当你旋转它时变形，但你仍然可以看到纹理的外观 Light Type 光源类型 纹理将应用的光源类型。（可以是聚光灯、点光源或方向光）。对于方向光纹理将平铺，所以在纹理检视面板中必须设置边缘模式为重复（Repeat）；对于聚光灯，你应该保持你的cookie纹理的边缘为纯黑色，以获得正确的效果。在纹理检视面板中，设置边缘模式为钳制（Clamp） Non Power of 2 不是2的幂：如果纹理大小不是2的幂，这将定义在导入时的缩放行为 1.None 无：纹理将被填充到下一个较大的2的幂大小以便与GUI纹理组件使用 2.To nearest 到最近的：纹理在导入时将被缩放到最近的幂大小。例如257x511纹理将成为256x512。请注意，PVRTC格式要求纹理是正方形（宽度与高度相等），因此最终大小将变换到512x512。 PVRTC是一种有损的纹理压缩技术，主要用于iPhone，iPod touch和iPad。 3.To larger 到较大的：纹理在导入时将被缩放到下一个较大的幂大小。例如257x511纹理将成为512x512。 4.To smaller 到较小的：纹理在导入时将被缩放到下一个较小的幂大小。例如257x511纹理将成为256x256。 Generate Cube Map 生成立方贴图：使用不同的生成方法从一个纹理生成一个立方体贴图。 Read/Write Enabled 读/写 启用 选择此项将允许从脚本（GetPixels，SetPixels和其他Texture2D函数）访问纹理数据。但是注意，一个纹理数据副本将产生，由此必将为纹理资源消耗双倍的内存量。只有在绝对必要时使用。默认情况下禁用。 Generate Mip Maps 生成Mip Maps 选择此项将启用Mipmap生成。当纹理在屏幕上非常小的时候，Mipmaps是可供使用的纹理的较小版本。欲了解更多信息，请参阅下文的Mip maps。 Correct Gamma 校正伽马 启用每Mip级别伽玛校正 Border Mip Maps 边缘Mip Maps 为了避免色彩渗出到mip较低层次的边缘。用于光源cookies Mip Map Filtering：Mip Map过滤，mip map过滤的两种方式可供优化图像质量： 1. Box 盒：最简单的方式淡出mipmap – 随着尺寸的减小mip级别变得更平滑。 2. Kaiser 凯撒：凯撒算法是随着尺寸的减小锐化mip maps运行。如果你的纹理在远距离变模糊，试试这个选项。 Fade Out Mips 淡出Mips 启用此项将使mipmaps随着mip级别的进展褪色为灰色，这个用于细节贴图。最左边的滚动条是开始淡出的第一个mip级别。最右边的滚动条定义mip级别在哪里完全变灰。 Generate Normal Map 生成法线贴图 启用此项将转变颜色通道成一个适合于实时法线贴图的格式 Normal Map 法线贴图 如果你想了解法线贴图如何被应用到你的纹理，选择此项。 Lightmap 光照贴图 如果你想作为光照贴图使用纹理，选择此项。 平台相关：纹理的最大尺寸（Max Size）和格式(Format) 查看文档 细节： Supported Formats 支持的格式 Unity支持下面的文件格式：PSD, TIFF, JPG, TGA, PNG, GIF, BMP, IFF, PICT。应注意，Unity可以导入多层PSD和TIFF文件，在导入时，层将自动被塌陷，因此你不必浪费时间，直接使用源文件类型。这点很重要，允许只有一个纹理拷贝，使用从Photoshop，三维建模程序导入到Unity。 Texture Sizes 纹理大小 这些尺寸如下：2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 或 2048像素。纹理可不必是正方形，即宽度和高度可以不同。 可以使用其他非二次方纹理尺寸，当用于GUI纹理时，非二次方纹理最好，但是，如果在别的使用，它们将被转换为未压缩的RGBA32位格式。这意味着它们将使用更多的内存（相比PVRT(iOS)/DXT(Desktop)压缩的纹理），将使较慢加载和和较慢渲染（如果是iOS模式）。一般来说，非二次方的纹理仅用于GUI。 非二次方纹理资源可以在导入时在导入设置中高级纹理类型使用Non Power of 2（非二次方)选项设置缩放。Unity将按需缩放纹理，并在游戏中，它们的行为就像其他纹理一样，因此他们仍然可以被压缩，加载非常快。 UV Mapping（UV贴图） 当映射一个2D纹理到一个3D模型上，要设定循环模式（平铺方式）。这就是三维建模程序中，被称为UV贴图。在Unity，可以使用Materials缩放移动纹理。缩放法线和地形细节贴图尤其有用。 纹理映射坐标：定义了该顶点在纹理中的对应2D坐标，通过用二维变量(u,v)来表示，其中u是横向坐标，v是纵向坐标，也叫UV坐标，在Unity中，原点在左下角(?) Mip Maps 多级纹理 多级纹理是逐步缩小图像版本的一个列表，用来优化实时3D引擎的性能。远离相机的物体使用较小的纹理版本。使用多级纹理，将多使用33％以上的内存，但不使用它们将有巨大的的性能损失。应该为游戏总是使用多级纹理，唯一例外的是，用于不会缩小的纹理（例如GUI纹理）。多级渐远纹理技术(mipmap)：有点类似于LOD技术，但是不同的是，LOD针对的是模型资源，而Mipmap针对的纹理贴图资源。使用Mipmap后，贴图会根据摄像机距离的远近，选择使用不同精度的贴图。 缺点：会占用内存，因为mipmap会根据摄像机远近不同而生成对应的八个贴图，所以必然占内存！ 优点：会优化显存带宽，用来减少渲染，因为可以根据实际情况，会选择适合的贴图来渲染，距离摄像机越远，显示的贴图像素越低，反之，像素越高！在纹理导入设置中Texture Type选择Advanced，选择Generate Mip Maps。 Normal Maps 法线贴图 法线贴图用于法线贴图着色器，使低多边形模型看起来有更多的细节。Unity使用的法线贴图作为RGB图像编码，还可以选择从一个灰度高度图来生成一个法线贴图。 Detail Maps 细节贴图 如果想创建一个地形，通常使用主纹理来显示那些草、岩砂区域，等等。如果地形非常大，它最终会非常模糊。细节纹理隐藏实际的淡出，小细节作为更接近的主纹理。 但绘制细节纹理，中性灰是不可见的，白色是主纹理两倍亮，黑色是主纹理完全变黑。 Reflections (Cube Maps) 反射（立方体贴图） 如果你想使用纹理用于反射贴图（例如使用内置的反射着色器），必须使用立方图纹理。 Anisotropic filtering 各项异性过滤 当从掠角（grazing angle）观看，各向异性过滤提高纹理质量，有一些渲染成本消耗（完全是显卡成本）。为地面和地板纹理，增加各向异性等级通常是一个好主意。在质量设置中各向异性过滤，可以强制用于所有纹理或完全禁用。纹理应用于Shader 单张纹理 单张纹理应用 v2f vert(a2v v) { v2f o; o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = v.texcoord.xy * \\_MainTex\\_ST.xy + \\_MainTex\\_ST.zw; // Or just call the built-in function//o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o;} fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); // Use the texture to sample the diffuse color fixed3 albedo = tex2D(\\_MainTex, i.uv).rgb * \\_Color.rgb; fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} 高度纹理 用高度图实现凹凸映射，存在的是强度值。颜色浅越凸，深则凹。 法线纹理 模型下的法线纹理：直观、实现简单；边界平滑； 切线空间下的法线纹理：顶点是原点，x轴是切线方向t，y轴是副切线方向b,z轴是法线方向n；自由度高；可实现uv动画；法线纹理可重用；可压缩。 切线空间下计算： v2f vert(a2v v) { v2f o; o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); o.uv.xy = v.texcoord.xy * \\_MainTex\\_ST.xy + \\_MainTex\\_ST.zw; o.uv.zw = v.texcoord.xy * \\_BumpMap\\_ST.xy + \\_BumpMap\\_ST.zw; // Compute the binormal// float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w;// // Construct a matrix which transform vectors from object space to tangent space// float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); // Or just use the built-in macro TANGENT\\_SPACE\\_ROTATION; // Transform the light direction from object space to tangent space o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; // Transform the view direction from object space to tangent space o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o;} fixed4 frag(v2f i) : SV_Target { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); // Get the texel in the normal map fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; // If the texture is not marked as &quot;Normal map&quot;// tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;// tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); // Or mark the texture as &quot;Normal map&quot;, and use the built-in funciton tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(\\_MainTex, i.uv).rgb * \\_Color.rgb; fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} 世界空间下计算： v2f vert(a2v v) { v2f o; o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); o.uv.xy = v.texcoord.xy * \\_MainTex\\_ST.xy + \\_MainTex\\_ST.zw; o.uv.zw = v.texcoord.xy * \\_BumpMap\\_ST.xy + \\_BumpMap\\_ST.zw; float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // Compute the matrix that transform directions from tangent space to world space // Put the world position in w component for optimization o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o;} fixed4 frag(v2f i) : SV_Target { // Get the position in world space float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); // Compute the light and view dir in world space fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); // Get the normal in tangent space fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); bump.xy *= _BumpScale; bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy))); // Transform the narmal from tangent space to world space bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 albedo = tex2D(\\_MainTex, i.uv).rgb * \\_Color.rgb; fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir)); fixed3 halfDir = normalize(lightDir + viewDir); fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} 渐变纹理 实践： v2f vert(a2v v) { v2f o; o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; o.uv = TRANSFORM\\_TEX(v.texcoord, \\_RampTex); return o;} fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; // Use the texture to sample the diffuse color fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; fixed3 diffuseColor = tex2D(\\_RampTex, fixed2(halfLambert, halfLambert)).rgb * \\_Color.rgb; fixed3 diffuse = _LightColor0.rgb * diffuseColor; fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} 遮罩纹理 实践： v2f vert(a2v v) { v2f o; o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); o.uv.xy = v.texcoord.xy * \\_MainTex\\_ST.xy + \\_MainTex\\_ST.zw; TANGENT\\_SPACE\\_ROTATION; o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o;} fixed4 frag(v2f i) : SV_Target { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv)); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(\\_MainTex, i.uv).rgb * \\_Color.rgb; fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); // Get the mask value fixed specularMask = tex2D(\\_SpecularMask, i.uv).r * \\_SpecularScale; // Compute specular term with the specular mask fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask; return fixed4(ambient + diffuse + specular, 1.0);} 参考(部分摘录)：二维纹理 Texture 2D","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之八—光照","slug":"u3d/unity3d-shader-e5-ad-a6-e9","date":"2016-11-03T04:06:16.000Z","updated":"2019-11-08T09:59:31.034Z","comments":true,"path":"2016/11/03/u3d/unity3d-shader-e5-ad-a6-e9/","link":"","permalink":"http://blog.le-more.com/2016/11/03/u3d/unity3d-shader-e5-ad-a6-e9/","excerpt":"","text":"部分摘录自：Unity 5 中的全局光照技术详解 全局光照(GI):是一个用来模拟光的互动和反弹等复杂行为的算法 实时照明(REALTIME LIGHTING) 代表这些灯源会把光线照射到场景并以每一帧的频率更新，由于光源是可以在场景内移动的对象，场景灯光的更新是实时的，你可以在游戏窗口和场景窗口看到改变 烘焙全局光照(BAKEDGI LIGHTING） 预计算全局光照(PRECOMPUTED REALTIME GI LIGHTING) 能帮我们实时运算复杂的场景光源互动，透过这种方法，就能建立昏暗的环境带有丰富的全局光照反射，并实时反映光源的改变 着色路径 前向渲染（Forward Rendering） 每个对象著色是根据每个影响对象的光，透过”Pass”来著色，所以有可能一个对象被重复著色了好几次，取决于有几盏灯在作用范围里。 优点：快速，也代表硬件需求低，此外，这种正向著色提供了广泛的自定义”着色模型”，可以快速处理透明度，也支持像是多重采样柔边(MSAA)的硬件功能，等等有些在其他路径上是无法实现的功能，对于图形质量有很大的影响。 缺点：要为每盏灯光付出相对应的成本，也就是说，对象被越多盏灯光影响，花费的运算成本就越高，有些类型的游戏必需要大量的光源，就会令人望之却步，反观如果你能管理好你的灯光数量，那这个路径会是一个非常快速的解决方案。 延迟渲染（Deferred） 延迟了光的遮蔽与混合信息直到第一次接收到的表面的位置 法线 以及材质数据著色到一个”几何缓冲器”(G-buffer)作为一个屏幕空间的贴图，最后合成这些结果 优点：照明的著色成本是和像素数量成正比，而非灯光数量，因此你不用再管控场景灯光数量，某些游戏类型将会是一个关键优势。 缺点：呈现可预见的效能特点，但通常需要较强大的硬件，对于手机平台支持度也较低。 色彩空间(COLOR SPACE) 色彩空间决定采用哪种算法来计算照明或材质加载时的颜色混合，这会对游戏的画面真实感有很大的影响，但大多数情况下，太超过的色彩空间设定可能会被目标平台的硬件强制限制。 Linear 接近真实的色彩空间,优点是会让场景内的提供给着色器的颜色也会因为光强度增加变亮 另一个好处是着色器能在没有Gamma补偿的情况下对贴图进行取样，这有助于确保颜色质量在经过著色管道还能保持一致性，能提高色彩和计算的精度，最后屏幕的输出结果更为真实 缺点：有些手机平台甚至有些游戏机不支持，应该说PC或是一些新手机硬件和次世代游戏机才会支持Linear颜色空间 Gamma 缺点：亮度马上会转为以白色做为参考，这将不利于图像的质量 高动态范围(HDR)： 色调映射(TONEMAPPING)： 环境光(AmbientLighting)： 反射源(REFLECTIONSOURCE)： 反射探头(REFLECTIONPROBES)： 光源类型 定向光（DIRECTIONALLIGHTS） 无坐标、只有方向；光线平行、无衰减，适用于模拟太阳光 点光源（POINT LIGHTS） 亮度从中心最强一直到范围属性(Range)设定的距离递减到0为止，光的强度从光源到距离成反比；适合用来制作像是灯泡, 武器发光或是从物体发射出来的爆炸效果； 开启阴影运算是很耗效能；预计算GI时，不支持阴影的间接反射； 聚光灯（SPOTLIGHTS） 投射一个锥体在他的Z轴前方，这个锥体的宽度由投射角度(Spot Angle)属性控制着，光线会从源头到设定的范围慢慢衰减到0，同时越靠近锥体边缘也会衰减，把投射角度的值加大会让锥体宽度加大，同时也让边缘淡化的力度变大，这现象学名叫做”半影”； 用来模拟路灯, 壁灯,手电筒；预计算GI时，不支持间接光阴影； 区域光(AREA LIGHTS) 可以当作是摄影用的柔光灯，在Unity里面他们被定义为单面往Z轴发射光线的矩形，目前只能和烘焙GI一起使用，区域光会均匀的照亮作用区域，虽然区域光没有范围属性可以调整，但是光的强度也是会随着距离光源越远而递减；适用于建立柔和的照明效果；适合当作天花板壁灯或是背光灯； 发光材质(EMISSIVE MATERIALS) 可以让物体表面发光，他们可以反射场景内像是颜色或是光强度等等能在游戏内改变的光源，自发光(Emission)是一个在标准着色器(Standard Shader)内的属性，允许静态对象成为一个发光体，预设情况下是0，代表指定了这个材质并不会有任何的自发光反应；没有范围属性，但从材质发出的光会以二的次方速度递减，自发光材质只会作用在有标记为”Static”或”LightmapStatic”卷标的对象；适合来模拟霓虹灯等类似的光源； 光探头(LIGHT PROBES) 静态对象只被Unity全局光照GI系统计算，光探头可用于动态对象能够和静态场景接收到的光影信息互动；光探头允许移动对象接受由全局光照GI所计算出来复杂的反射光源，对象在著色网格的时候会判断附近光探头的位置并且把光的信息一并融合计算，这是透过找寻由光探头所产生的一个四面体，然后决定哪个四面体的落入对象的轴向，这样就能让场景内的动态对象正确地接受光信息，如果没有放置光探头，动态对象就无法接受全局光照的信息，造成动态对象比场景还要暗。 光照模型着色：根据材质属性、光源信息（方向，辐照度），使用一个等式去计算沿某个观察方向的出射度的过程。这个等式称为光照模型。 自发光c_emissive_：当给定一个方向时，一个表面本身会向该方向发射多少辐照量。通常在实时渲染中，不会照亮别的物体，计算时使用材质的自发光颜色： cemissive = m_emissive _ 高光反射cspecular:当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。反射方向公式： r = 2(n.l)n-l Phong模型高光反射计算公式： cspecular = (clight.mspecular)pow(max(0,v.r),mgloss) 其中mgloss是材质的光泽度、反光度，用于控制亮点大小。mspecular_材质的高光反射颜色，clight光源颜色。v是视角方向。Blinn模型： h = (v +l)/|v+l| c_specular = (clight.mspecular)pow(max(0,n.h),mgloss) 逐顶点光照实现： v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); // Get ambient term fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; // Transform the normal from object space to world space fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject)); // Get the light direction in world space fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); // Get the reflect direction in world space fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); // Get the view direction in world space fixed3 viewDir = normalize(\\_WorldSpaceCameraPos.xyz - mul(unity\\_ObjectToWorld, v.vertex).xyz); // Compute specular term fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); o.color = ambient + diffuse + specular; return o;} 逐像素光照实现： v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); // Transform the normal from object space to world space o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); // Transform the vertex from object spacet to world space o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; return o;} fixed4 frag(v2f i) : SV_Target { // Get ambient term fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); // Get the reflect direction in world space fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); // Get the view direction in world space fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); // Compute specular term fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} BlinnPhong： v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY_MATRIX_MVP, v.vertex); // Transform the normal from object space to world space o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); // Transform the vertex from object spacet to world space o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; return o;} fixed4 frag(v2f i) : SV_Target { // Get ambient term fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); // Get the view direction in world space fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); // Get the half direction in world space fixed3 halfDir = normalize(worldLightDir + viewDir); // Compute specular term fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} BlinnPhong Use Build In Functions： v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); // Use the build-in funtion to compute the normal in world space o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o;} fixed4 frag(v2f i) : SV_Target { fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); // Use the build-in funtion to compute the light direction in world space // Remember to normalize the result fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); // Use the build-in funtion to compute the view direction in world space // Remember to normalize the result fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = \\_LightColor0.rgb * \\_Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} 漫反射cdiffuse:当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。符合兰伯特定律：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比，计算公式： cdiffuse = (clight . mdiffuse)max(0,n.l) n是表面法线，l是指向光源的单位矢量，m_diffuse_是材质的漫反射颜色，c_light_是光源颜色 逐顶点光照实现： v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); // Get ambient term fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; // Transform the normal from object space to world space fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject)); // Get the light direction in world space fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * saturate(dot(worldNormal, worldLight)); o.color = ambient + diffuse; return o;} 逐像素光照实现： v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); // Transform the normal from object space to world space o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); return o;} fixed4 frag(v2f i) : SV_Target { // Get ambient term fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; // Get the normal in world space fixed3 worldNormal = normalize(i.worldNormal); // Get the light direction in world space fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1.0);} 半兰伯特定律： cdiffuse = (clight.mdiffuse)(α(n.l) + β) α,β通常为0.5 cdiffuse = (clight.mdiffuse)(0.5(n.l) + 0.5) 把** n.l**结果从【-1，1】映射到【0，1】，该定律无物理依据，仅仅是一个视觉加强技术 v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.pos = mul(UNITY\\_MATRIX\\_MVP, v.vertex); // Transform the normal from object space to world space o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject); return o;} fixed4 frag(v2f i) : SV_Target { // Get ambient term fixed3 ambient = UNITY\\_LIGHTMODEL\\_AMBIENT.xyz; // Get the normal in world space fixed3 worldNormal = normalize(i.worldNormal); // Get the light direction in world space fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // Compute diffuse term fixed halfLambert = dot(worldNormal, worldLightDir) * 0.5 + 0.5; fixed3 diffuse = \\_LightColor0.rgb * \\_Diffuse.rgb * halfLambert; fixed3 color = ambient + diffuse; return fixed4(color, 1.0);} 环境光cambient:用于描述其他所有的间接光照。通常是一个全局变量： cambient = gambient 在unity中通过Windows-&gt;Lights-&gt;Ambient Source/Ambient Color/Ambient Intensity控制；在Shader中通过UNITY_LIGHTMODEL_AMBIENT获取颜色及强度 待续 参考： Introduction to Lighting and Rendering （中文：Unity 5 中的全局光照技术详解）《UnityShader 入门精要》","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之七—坐标空间与三维转换","slug":"u3d/b4-e4-b8-8e-e4-b8-89","date":"2016-11-01T04:00:10.000Z","updated":"2019-11-08T09:59:31.011Z","comments":true,"path":"2016/11/01/u3d/b4-e4-b8-8e-e4-b8-89/","link":"","permalink":"http://blog.le-more.com/2016/11/01/u3d/b4-e4-b8-8e-e4-b8-89/","excerpt":"","text":"使用顶点和片段程序时，程序将关闭图形硬件中的大部分硬编码功能（“固定功能管道”）。如完全关闭标准三维转换、照明和纹理坐标生成功能。 因此，在开发顶点和片段着色器时，需要对坐标空间、三维转换和光照有全面了解。下面将分别介绍。 Unity 内置的一些有用的着色器变量，它们在UnityShaderVariables.cginc声明，着色器自动包含这个文件。 内置Shader系统 文件：windows:Unity\\Editor\\Data\\CGIncludes 空间转换的内置变量，这些变量都是float4x4的矩阵： Name Value UNITY_MATRIX_MVP Current model * view * projection matrix. 当前的模型观察投影矩阵，用于将顶点/方向矢量模型空间变换到裁剪空间 UNITY_MATRIX_MV Current model * view matrix.当前的模型观察矩阵,用于将顶点/矢量模型空间变换到观察空间 UNITY_MATRIX_V Current view matrix.当前的观察矩阵，用于将顶点/方向矢量从世界坐标变换到观察空间 UNITY_MATRIX_P Current projection matrix.当前的投影矩阵，用于将顶点/方向矢量从观察空间变换到裁剪空间 UNITY_MATRIX_VP Current view * projection matrix.当前的观察投影矩阵，用于将顶点/方向矢量从世界空间变换到裁剪空间 UNITY_MATRIX_T_MV Transpose of model * view matrix.模型观察矩阵的转转置 UNITY_MATRIX_IT_MV Inverse transpose of model * view matrix.模型观察矩阵的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可用于得到UNITY_MATRIC_MV的转置矩阵 _Object2World Current model matrix.当前的模型矩阵，用于将顶点/方向矢量从模型空间变换到世界空间 _World2Object Inverse of current world matrix.模型空间的逆矩阵，用于将顶点/方向矢量从世界空间变换到模型空间 从上面的表格中我们可以知道在Unity（图形渲染）中含有，模型空间（局部空间）&gt;&gt;世界空间&gt;&gt;观察空间（摄像机空间）&gt;&gt;裁剪空间（齐次裁剪空间）&gt;&gt;屏幕空间。模型上的顶点依次通过这些空间的变换最终展示到显示屏幕上。 坐标系 为了表示位置，距离，方向等相关关系，使用三维的笛卡尔坐标系。 左手右手坐标系，鉴别方法拇指食指中指分别代表xyz，指头方向为正方向。如果左手和当前坐标轴对应就是左手坐标系，反之为右手坐标系。上图为左手坐标系。 空间变换 世界空间》模型空间 脚本：transform.worldToLocalMatrix的MultiplyPoint()和MultiplyVector() Shader: 左乘_World2Object 模型空间》世界空间 脚本：Transform的localToWorldMatrix的MulitplayPoint()和MultiplyVector() Shader:_Object2World 世界空间》摄相机空间 脚本：Camera组件的worldToCameraMatrix Shader:UNITY_MATRIX_MV 直接从模型空间转到摄相机空间 摄相机空间》世界空间 脚本：Camera组件的cameraToWorldMatrix Shader:UNITY_MATRIX_T_MV 直接从摄相机空间转到模型空间（UNITY_MATRIX_MV是正交矩阵） 世界空间》裁剪空间 Shader:UNITY_MATRIX_VP用于将顶点/矢量从世界空间变换到裁剪空间 裁剪空间》屏幕空间 Shader:ComputeScreenPos裁剪空间坐标转换为屏幕空间坐标 屏幕空间》视口空间 Shader:屏幕空间坐标Pos.xy / Pos.w得到视口空间中的坐标,视口坐标范围[(0,0),(1,1)] 注意：关于坐标空间，矢量运算，矩阵变换等，请查看相关资料。不再赘述！（Unity Shader入门精要第4章介绍的很清楚，有PDF版本，入门建议阅读）","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之六—顶点和片段着色器","slug":"u3d/unity3d-shader-e5-ad-a6-e11","date":"2016-10-31T09:05:47.000Z","updated":"2019-11-08T09:59:31.030Z","comments":true,"path":"2016/10/31/u3d/unity3d-shader-e5-ad-a6-e11/","link":"","permalink":"http://blog.le-more.com/2016/10/31/u3d/unity3d-shader-e5-ad-a6-e11/","excerpt":"","text":"基于上一篇文章的内容，将重点放在顶点和片段着色器。 下面是顶点和片段着色器的基本结构： //着色器的名称，将出现在编辑器中所列出的材质检视器列表中Shader “MyShaderName” {//着色器可以有一系列属性。着色器中定义的任何属性都显示在 Unity 内的材质检视器中。典型属性有物体颜色和纹理，或者只是着色器使用的任意值。Properties {// … properties here … }//数目不定，但至少要有一个，Unity会选择最适合的SubShader运行到指定平台SubShader {// … subshader for graphics hardware A …//数据不定，但至少要有一个，通道 (Pass) 块使对象的几何结构被渲染一次Pass {// … pass commands … }// … more passes if needed … }SubShader {// … subshader for graphics hardware B … }// … Optional fallback …//如果所有子着色器都无法在该硬件上运行，就运行此着色器，异常处理FallBack “VertexLit”} 各部分详细说明： Name： Shader “name“ { [Properties] Subshaders [Fallback] } 定义一个着色器 可以支持/，在编辑中以目录的形式展示，例如： Shader “Test/ShaderTest” {} Properties： 属性 (Properties) { Property [_Property …_] }定义属性块。括号内，多个属性定义如下。 name (“display name“, Range (min, max)) = number_定义浮点属性，代表检视器中从_最小值 (min) 到_最大值 (max)_的滑块。 name (“display name“, Color) = (number,number,number,number)定义颜色属性。 name (“display name“, 2D) = “name“ { options }定义二维纹理属性。 name (“display name“, Rect) = “name“ { options }定义矩形（非 2 的幂）纹理属性。 name (“display name“, Cube) = “name“ { options }定义立方体贴图纹理属性。 name (“display name“, Float) = _number_定义浮点属性。 name (“display name“, Vector) = (number,number,number,number)定义四分量向量属性。 如果您想在着色器程序中访问那些属性中的一些属性，您需要声明一个具有相同名称和匹配类型的 Cg/HLSL 变量。例如，以下这些着色器属性： _MyColor (“Some Color”, Color) = (1,1,1,1)_MyVector (“Some Vector”, Vector) = (0,0,0,0)_MyFloat (“My float”, Float) = 0.5_MyTexture (“Texture”, 2D) = “white” {}_MyCubemap (“Cubemap”, CUBE) = “” {} 将在 Cg/HLSL 代码中被声明为： fixed4 _MyColor; // 精度低的类型对颜色来说已足够float4 _MyVector;float _MyFloat;sampler2D _MyTexture;samplerCUBE _MyCubemap; SubShader: Subshader { [Tags_] [_CommonState_] _Passdef [Passdef …_] }定义子着色器为可选的标记、普通状态和一系列通道定义。 Pass: Pass { _[Name and Tags] [RenderSetup] [TextureSetup] }基本通道命令包含了渲染设置命令的可选列表，后面可跟随一系列纹理以供使用。 Pass结构是这样的，Cg 程序代码片段被编写在 CGPROGRAM 和 ENDCG 之间。 Pass { // …常用的通道状态设置… CGPROGRAM // 该代码片段的编译指令，例如： #pragma vertex vert #pragma fragment frag // Cg 代码自身 ENDCG // ...通道设置的剩余部分... } FallBack: Fallback”name”回退到有给定名称的着色器。 Fallback Off 回退关闭,明确表示即使没有子着色器可以在该硬件上运行，也不会有回退以及应打印的警告。 顶点着色器示例： Shader “VertexInputSimple” { SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc” //vertex to fragment struct v2f { float4 pos : SV_POSITION; fixed4 color : COLOR; }; //appdata_base 包含application to vertex参数 v2f vert (appdata_base v) { v2f o; o.pos = mul (UNITY\\_MATRIX\\_MVP, v.vertex); o.color.xyz = v.normal * 0.5 + 0.5; o.color.w = 1.0; return o; } // fixed4 frag (v2f i) : COLOR0 { return i.color; } ENDCG } }} 看示例中的蓝色部分： 1.#pragma vertex vert #pragma指令，指定vertex函数为vert,常用的指令有： #pragma vertex 名称 - 将函数_名称_编译为顶点着色器。 #pragma fragment 名称 - 将函数_名称_编译为片元着色器。 #pragma geometry 名称 - 将函数_名称_编译为 DX10 几何结构着色器。要使这个选项自动打开 #pragma target 4.0 #pragma hull 名称 - 将函数_名称_编译为 DX11 外壳着色器。要使这个选项自动打开 #pragma target 5.0 #pragma domain 名称 - 将函数_名称_编译为 DX11 域着色器。要使这个选项自动打开 #pragma target 5.0 2.#include “UnityCG.cginc” Unity可包含引入预定义变量和帮助函数的文件，其他内置文件有： HLSLSupport.cginc- （自动包含） 用于跨平台着色器编译的帮助宏和定义。 UnityCG.cginc- 常用的全局变量和帮助函数。 AutoLight.cginc- 光照和阴影功能，例如，表面着色器在内部使用此文件。 Lighting.cginc- 标准表面着色器光照模型；当您编写表面着色器时自动将其包含。 TerrainEngine.cginc- 用于地形 (Terrain) 和植被 (Vegetation) 着色器的帮助函数。 3.appdata_base 是一个数据结构，提供顶点数据给 Cg/HLSL 顶点程序，几个常用的顶点结构定义在UnityCG.cginc 包含文件，大多数情况下只使用它们就足够了。其它结构有： appdata_base: 顶点由位置、法线和一个纹理坐标构成。 appdata_tan: 顶点由位置、切线、法线和一个纹理坐标构成。 appdata_full: 顶点由位置、切线、法线、两个纹理坐标以及颜色构成 结构成员必须是下面列出的成员： float4 vertex 是顶点位置 float3 normal 是顶点法线 float4 texcoord 是第一个 UV 坐标 float4 texcoord1 是第二个 UV 坐标 float4 tangent 是切线向量（用于法线贴图） float4 color 是逐顶点颜色 顶点着色器是如何知道这些成员的含义的呢？是由成员定义时后跟冒号加字符串指定的！这些字符串就是语义。例如appdata_base定义如下（请查看UnityCG.cginc源文件）： struct appdata_full { float4 vertex : POSITION;//模型空间的顶点位置 float4 tangent : TANGENT;//模型空间的顶点切线 float3 normal : NORMAL;//模型空间的顶点法线 float4 texcoord : TEXCOORD0;//顶点的第一组纹理坐标 float4 texcoord1 : TEXCOORD1;//顶点的第2组纹理坐标 float4 texcoord2 : TEXCOORD2;//顶点的第3组纹理坐标 float4 texcoord3 : TEXCOORD3;//顶点的第4组纹理坐标#if defined(SHADER_API_XBOX360) half4 texcoord4 : TEXCOORD4;//顶点的第5组纹理坐标 half4 texcoord5 : TEXCOORD5;//顶点的第6组纹理坐标#endif fixed4 color : COLOR;//顶点颜色}; 4.SV_POSITION，COLOR0 上面提到了语义，SV_POSITION也是语义。但这个是顶点到片段着色器的语义。顶点到片段着色器的语义列表： SV_POSITION：裁剪空间坐标，必须包含COLOR0:输出第一组顶点颜色，可选COLOR1:输出的第二组颜色，可选TEXCOORD0-TEXCOORD7:输出纹理坐标，可选 5.UNITY_MATRIX_MVP Unity 内置的空间变换矩阵，位于HLSLSupport.cginc，上面提到了是自动包含的，所以着色器可以直接使用。其他变换矩阵及其含义，在下一篇会详细介绍！ 要想了解每个部分的详细含义及内容，请查看官方文档。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之五—Shader三种类型","slug":"u3d/unity3d-shader-e5-shader-e7","date":"2016-10-28T06:56:55.000Z","updated":"2019-11-08T09:59:31.035Z","comments":true,"path":"2016/10/28/u3d/unity3d-shader-e5-shader-e7/","link":"","permalink":"http://blog.le-more.com/2016/10/28/u3d/unity3d-shader-e5-shader-e7/","excerpt":"","text":"Unity Shader有三种类型，分别是固定功能着色器 (Fixed Function Shaders)、表面着色器（Surface Shaders）、顶点和片段着色器。 固定功能着色器 (Fixed Function Shaders)适用于不支持可编程着色器的旧硬件，固定功能着色器完全使用 ShaderLab 语言（类似于 Microsoft’s .FX 文件或 NVIDIA’s CgFX）进行编写。 表面着色器（Surface Shaders）如需让您的着色器受到光线和阴影的影响，那么表面着色器 (Surface Shaders) 是您最好的选择，表面着色器可让您以简单的方法编写复杂的着色器 - 这是与 Unity 照明管道的更高层次交互提取。大部分表面着色器自动支持正向和延迟照明。可用数行 Cg/HLSL 编写表面着色器，且其中将生成更多代码。如果着色器未对光线进行任何处理，请勿使用表面着色器 顶点和片段着色器如果着色器无需与照明互动，或者需要制作一些表面着色器无法实现的非凡效果，则需使用顶点和片段着色器。按此方法编写的着色器程序可让您以最灵活的方式制作所需的效果，也可使用 Cg/HLSL 编写这些着色器。 固定功能着色器主要针对旧硬件，图形接口API仅支持通过修改配置进行控制，这些完全可以通过编程API来实现，在Unity内部也会把固定功能着色器编译为顶点和片段着色器。 同样的表面着色器最终也会编译为顶点和片段着色器，故对于Unity Shader可以认为只有一种类型，学习时把主要精力放在顶点和片段着色器就行了（个人观点）。 固定功能着色器示例： Shader “Tutorial/Basic” { Properties { _Color (“Main Color”, Color) = (1,0.5,0.5,1) } SubShader { Pass { Material { Diffuse [_Color] } Lighting On } }} 表面着色器示例 Shader “Example/Diffuse Simple” { SubShader { Tags { “RenderType” = “Opaque” } CGPROGRAM #pragma surface surf Lambert struct Input { float4 color : COLOR; }; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = 1; } ENDCG } Fallback “Diffuse” } 顶点和片段着色器示例 Shader “VertexInputSimple” { SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc” struct v2f { float4 pos : SV_POSITION; fixed4 color : COLOR; }; v2f vert (appdata_base v) { v2f o; o.pos = mul (UNITY\\_MATRIX\\_MVP, v.vertex); o.color.xyz = v.normal * 0.5 + 0.5; o.color.w = 1.0; return o; } fixed4 frag (v2f i) : COLOR0 { return i.color; } ENDCG } }} 表面着色和顶点和片段着色器的区别是：表面着色器的定义是在SubShader块中，顶点着色器的定义是在Pass中。","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之四—Unity Shader基本概念","slug":"u3d/unity3d-shader-unity-shader","date":"2016-10-28T05:10:47.000Z","updated":"2019-11-08T09:59:31.036Z","comments":true,"path":"2016/10/28/u3d/unity3d-shader-unity-shader/","link":"","permalink":"http://blog.le-more.com/2016/10/28/u3d/unity3d-shader-unity-shader/","excerpt":"","text":"GPU(Graphic Process Unit) 图形处理单元，位于显卡中； DirectX 微软开发的图形编程库，支持Windows平台； HLSL(High Level Shading Language) 属于DirectX,仅支持Windows平台； OpenGL(Open Graphic Library) 跨平台的高级3D图形应用程序编程接口； OpenGL ES(OpenGL for Embedded Systems) 以手持和嵌入式设备为目标的OpenGL编程接口。在智能手机中占据统治地位的图形API; GLSL(OpenGL Shading Language) OpenGL的着色器语言，支持跨平台，但有局限性； Cg(C for Graphic) NVIDIA开发提供。支持跨平台，语法类似于HLSL。目前已经不再支持更新，但仍有学习价值； Unity Shader Unity 编辑器支持着色器方式，是对Cg语言的二次封装，提供一层编译器，根据发布平台不同，编译成不同的着色器(HLSL/GLSL)。 ShaderLab Unity 配置了一种强大的着色和材质语言。其语言风格类似于 CgFX 和 Direct3D Effects (.FX) 语言 – 可描述显示材质 (Material) 所需的一切信息。 GPU发展的历史，可以参考《GPU 编程与CG 语言之阳春白雪下里巴人》第一章绪论，了解过去，是为了更好的了解现在，以及未来!","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之三—渲染流程","slug":"u3d/unity3d-shader-e5-ad-a6-e10","date":"2016-10-28T05:04:31.000Z","updated":"2019-11-08T09:59:31.029Z","comments":true,"path":"2016/10/28/u3d/unity3d-shader-e5-ad-a6-e10/","link":"","permalink":"http://blog.le-more.com/2016/10/28/u3d/unity3d-shader-e5-ad-a6-e10/","excerpt":"","text":"Shader编程，只是图形编程的很小的一部分。如果能对GPU的工作原理有一定的了解，对于学习好Shader会有很大的益处！下面来了解下GPU的渲染流程。 下图来自《GPU 编程与CG 语言之阳春白雪下里巴人》3.1节，从图中我们可以完整的了解从应用程序到生成用于显示的Frame Buffer的过程。 下图是OpenGL 图形管线，来自《OPENGL ES 3.0编程指南(原书第2版)》1.1节，在灰色部分就是可编程部分。 再来看下面的图，更为清晰。这是来自 上图来自《Unity Shader入门精要》2.3节，这本书浅显易懂，对于基础不好的，推荐大家看这本书。然后再结合《GPU 编程与CG 语言之阳春白雪下里巴人》等入门会更快！ 对于顶点数据是什么，3D程序或游戏场景等数据在这个流程中怎样在最后呈现在屏幕下，就需要继续了解坐标变换相关内容！","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之二—入门BOOK","slug":"u3d/unity3d-shader-e5-book","date":"2016-10-26T02:59:46.000Z","updated":"2019-11-08T09:59:31.034Z","comments":true,"path":"2016/10/26/u3d/unity3d-shader-e5-book/","link":"","permalink":"http://blog.le-more.com/2016/10/26/u3d/unity3d-shader-e5-book/","excerpt":"","text":"一手一本入门书，对于基础不是很牢固的还是看这样简明扼要的书比较好！ 从亚马逊网店购得，包装挺好的。还是正版书纸质没得说！ 本希望看电子书，怎奈找不到这本书的电子版本！支持一下正版吧，哈哈！","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"Unity3D Shader学习之一---取之有道","slug":"u3d/unity3d-shader-e5-ad-a6-e8","date":"2016-10-20T05:02:25.000Z","updated":"2019-11-08T09:59:31.033Z","comments":true,"path":"2016/10/20/u3d/unity3d-shader-e5-ad-a6-e8/","link":"","permalink":"http://blog.le-more.com/2016/10/20/u3d/unity3d-shader-e5-ad-a6-e8/","excerpt":"","text":"技术入门往往很简单，从网上搜索一下教程然后实现一下就说自己学会了一门技术。这样的人是肤浅的，学习的方法也不是最佳的（当然也要分情况区分）。如果从事3D引擎开发，就需要深入的学习。掌握甚至精通需要一定的学习方法。有哪些方法和步骤呢？ 一、搜索引擎 迅速了解一项技能，最直接、最快速的方法是通过搜索，找到前人走过的路。按照别人的方法一步步获得最基本的了解！我看到过的有： 猫都能学会的Unity3D Shader入门指南 二、官方文档 搜索到的教程往往比较简单，入门级别的。无法全面深入的了解。这时候官方文档是必不可少的：Graphics Tutorials Shader Reference 如果看英文难以理解，可以看游戏蛮牛上已经翻译好的文档。 三、精益求精 文档看起来会感觉零散，无法深入理解。这时候就需要阅读专业的书籍。 GPU 编程与CG 语言之阳春白雪下里巴人; Unity Shader入门精要（推荐）; Unity Shaders and Effects Cookbook（中译版：Unity着色器和屏幕特效开发秘笈 文中示例主要用表面着色器，版本比较旧，示例跑不起来）； Untiy 3D ShaderLab 开发实战详解. 四、熟能生巧 大量的实战演练，攻克一个个难题想不成专家都难！ 另外，Unity Shader只是图形图像技术的很小一部分。如果想全面学习就需要更广的涉猎： OPENGL ES 3.0编程指南 计算机图形学中文版 实时计算机图形学 技巧：学习官方文档的时候参照：GPU 编程与CG 语言之阳春白雪下里巴人和官方内置的Shader学习 选择一个方向，不断前进与探索，总有一天你会得偿所愿的！(只要你走的足够远，你肯定能到某个地方！)","categories":[{"name":"U3D","slug":"U3D","permalink":"http://blog.le-more.com/categories/U3D/"}],"tags":[{"name":"u3d","slug":"u3d","permalink":"http://blog.le-more.com/tags/u3d/"},{"name":"shader","slug":"shader","permalink":"http://blog.le-more.com/tags/shader/"}]},{"title":"程序员的健康清单之四---身体拉伸","slug":"life/95-e4-b9-8b-e5-9b","date":"2016-10-19T14:06:59.000Z","updated":"2019-11-08T09:59:30.984Z","comments":true,"path":"2016/10/19/life/95-e4-b9-8b-e5-9b/","link":"","permalink":"http://blog.le-more.com/2016/10/19/life/95-e4-b9-8b-e5-9b/","excerpt":"","text":"久坐、盯屏幕注意：给健康留一点年终奖 — 一个程序员的健康清单 提高身体的柔韧性、减少肌肉酸痛：拉伸动作 1. 2. 3. 4. 5. 参考：怎样做拉伸动作","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.le-more.com/categories/Life/"}],"tags":[]},{"title":"程序员的健康清单之三---手托、脚凳","slug":"life/8d-95-e4-b9-8b-e4","date":"2016-10-18T02:00:13.000Z","updated":"2019-11-08T09:59:30.983Z","comments":true,"path":"2016/10/18/life/8d-95-e4-b9-8b-e4/","link":"","permalink":"http://blog.le-more.com/2016/10/18/life/8d-95-e4-b9-8b-e4/","excerpt":"","text":"久坐、盯屏幕注意：给健康留一点年终奖 -- 一个程序员的健康清单 保护手腕、手臂，减少劳损：手托 这个学名叫：手托架（托臂手托板）。 买的这款带记忆棉护腕垫 ：（安装的图片拍不好看就盗个图） 下面是职位病图解： 正确使用坐椅： 脚凳比较挫，直接使用一个盒子，就不描述了","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.le-more.com/categories/Life/"}],"tags":[]},{"title":"程序员的健康清单之二---人体工学坐椅","slug":"life/e7-a8-8b-e5-ba-8f","date":"2016-10-17T02:00:07.000Z","updated":"2019-11-08T09:59:30.985Z","comments":true,"path":"2016/10/17/life/e7-a8-8b-e5-ba-8f/","link":"","permalink":"http://blog.le-more.com/2016/10/17/life/e7-a8-8b-e5-ba-8f/","excerpt":"","text":"久坐、盯屏幕注意：给健康留一点年终奖 -- 一个程序员的健康清单 保护颈椎、腰椎：人体工学坐椅 1.包装挺大，挺沉的说明分量挺足 2.打开包装，包裹挺好 3.全部配件 4.两个靠枕，和头靠坐着很舒服 5.可躺，还有脚托，很适合午睡","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.le-more.com/categories/Life/"}],"tags":[]},{"title":"程序员的健康清单之一---4k显示器","slug":"life/4k-e6-98-be-e7-a4","date":"2016-10-16T10:17:45.000Z","updated":"2019-11-08T09:59:30.982Z","comments":true,"path":"2016/10/16/life/4k-e6-98-be-e7-a4/","link":"","permalink":"http://blog.le-more.com/2016/10/16/life/4k-e6-98-be-e7-a4/","excerpt":"","text":"久坐、盯屏幕注意：给健康留一点年终奖 -- 一个程序员的健康清单 保护眼睛：4K屏幕 记录一下我最近买的4K屏幕。在买之前我做了好一番比较，结果贪图便宜在网上购得AOC U2868PQU 28英寸4K高分辨率UHD游戏电竞显示器 ，当天晚上开机试了下遇到普遍存在的诸多问题： 1.触屏菜单无反应，或反应不及时； 2.每次连接需要重新设置，很麻烦； 3.不是真的4K（这个算不上，因为开始我就知道）； 4.28寸用来开发有点偏大（没有上面问题我也能接受） 遇到这些问题，随即申请了退货。接下来我开始将目标定在Dell P2415Q，这一款口碑不错，价格就贵上一两千，故从天猫购得。下面上我的开箱图： 1.包装有点旧，这款显示器有点久，产品挤压不少时间，哈哈 2.打开箱子，这样看起来是新的了，那是我的手（可能吗）？ 3.标准配件：DP数据线，电源线，USB线，说明书，光盘，显示器 4.摆好支架，准备对接（桌子够小够乱） 5.点亮屏幕 6.点开菜单，可以看到分辨率是3840x2160（伪4K）,刷新率只有30HZ是怎么回事呢？这是因为我的Mac book pro是2013年早期的。 7.再附一张，客服答应送我的HDMI数据线（别骗我，光一个空的袋子）…. 再加一张电视尺寸与观看距离匹配的参考图： 链接：买4k／5k显示器前看这里","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.le-more.com/categories/Life/"}],"tags":[]},{"title":"买4k／5k显示器前看这里（转载）","slug":"other/9c-8b-e8-bf-99-e9-87","date":"2016-10-15T06:46:27.000Z","updated":"2019-11-08T09:59:30.993Z","comments":true,"path":"2016/10/15/other/9c-8b-e8-bf-99-e9-87/","link":"","permalink":"http://blog.le-more.com/2016/10/15/other/9c-8b-e8-bf-99-e9-87/","excerpt":"","text":"原地址： http://bbs.feng.com/read-htm-tid-10237017.html (出处: 威锋论坛) 4k／5k显示器虽好，但是还是需要在购买前考虑一下。 选择分辨率：Ultra HD／4k／5k 1920*1080 2.07 MP Full HD 2560*1440 3.68 MP WQHD 3840*2160 8.29 MP Ultra HD 4096*2160 4K 5120*2880 14.7 MP 5K Ultra HD 4k（3840*2160）显示器虽然并非真正的4k（4096*2160），但其还是算拥有4k的分辨率。并且，Ultra HD 4k跟1080p／2k的显示器比起来有很大的优势。 选择显示器接线：Thunderbolt（雷电）／HDMI 4k／5k的显示器都可以用雷电／HDMI线连接到mac（部分HDMI支持高分辨） 雷电在2011年或者更新的mac上的雷电接口同时支持Mini DisplayPort。 早期的2011到mid 2013的mac使用的是1代的雷电技术，其支持Display Port 1.1a（8.64Gbps）。更简单的解释就是：几乎所有mid 2013或更老的mac不支持在60Hz的4k／5k的输出。 什么是刷新率？显示器在1秒内能渲染整个屏幕多少次，同时也影响到显示器的FPS（每秒多少帧）。有3种常见的频率：60Hz／30Hz／24Hz 如果你要购买4k／5k的分辨率，你一定要确定你的mac能支持60Hz。如果你选择在外接显示器上通过雷电／HDMI用30Hz／24Hz的频率，你会感受到鼠标和画面的延迟。 苹果在2013年开始使用2代雷电技术，其支持DisplayPort 1.2（17.28Gbps）。也就是说：late 2013或者更新的mac使用的是2代雷电接口，并且能支持1个在60Hz的4k显示器。如果有独显，那就是同时输出多个了（最主要还是看你显卡）。 拥有2代雷电接口的mac列表： MacBook Pro with Retina Late 2013或更新 Mac Pro Late 2013 iMac Retina 5K 27寸 Late 2014或更新 iMac Retina 4K 21.5寸 Late 2015或更新 iMac 27寸 Late 2013或更新 iMac 21.5寸 Late 2015 Mac mini Late 2014 MacBook Air Early 2015 MacBook Retina 12寸 Early 2015 Intel在2015年6月发布了3代的雷电技术和USB Type-C的接口（也就是目前苹果的MacBook Retina 12寸上使用的接口）［遗憾的是12寸的macbook的USB Type-C不支持雷电，但支持原生 DisplayPort 1.2 视频输出］，第三代的技术相比之前的，拥有40Gbps的提升。雷电3还是基于DisplayPort 1.2。也就是说：苹果可能会在2016发布第一款Skylake Macs，这些都能同时支持到3个60Hz的4k显示器或者1个60Hz的5k显示器。 苹果也有可能同时发布一款5k的雷电接口显示器，但也有可能在Intel的处理器支持DisplayPort1.3之后发布。拥有DisplayPort1.3的mac最早可能在2016年发布，但是并不是一定。这些mac能通过SST支持一个5k显示器，苹果也就不用去担心MST的多流输出问题。 什么是SST和MST? 早期的4k显示器使用MST来达到60Hz的4k分辨率。这不是重点，所以就不解释了。 建议：如果你要买4k的显示器，请买支持SST的。因为MST在某些情况下产生问题。比如：游戏。就不再比如了。 MST是多流输出，所以有一个特别的地方就是：用mac上1个雷电同时输出多个4k显示器。 就跟电路课上讲的串联差不多了。想要连多长？问你的显卡。如果这样做的话，显示器和输出源（mac）都需要有DisplayPort并且都支持DisplayPort 1.2。最后一台可以是1.1，因为是最后一台。 HDMI 4k和Ultra HD显示器可以通过HDMI和mac相连。 MacBook Pro Late 2013或更新 iMac 27寸 Late 2013或更新 Mac mini Late 2014 Mac Pro Late 2013 最新的mac都有HDMI 1.4，其可以支持1个30Hz的Ultra HD显示器，或者是1个24Hz的4k显示器。（2种情况都不是镜像输出的，也就是说你的macbook是要合盖的） 苹果还没有更新mac上的HDMI到2.0，其可以支持1个60Hz的4k显示。 底线：雷电比HDMI好。［概括完毕］ 雷电可以支持到60Hz的4k／5k，而HDMI在目前的mac上支持到30Hz／24Hz。 雷电支持DVI，HDMI和VGA的转接，而HDMI只支持DVI的转接。 选择显示器 一些显示器的推荐： 型号 尺寸 分辨率 DP1.2 SST／MST HDMI ASUS PQ321Q 31.5 3840*2160 1 2 Dell P2415Q 24 3840*2160 1 SST和MST 1 Dell P2715Q 27 3840*2160 1 SST和MST 1 Dell UP2715K 27 5120*2880 2 MST Sharp PN-K321 31.5 3840*2160 1 SST和MST 2 底线：Dell 24寸P2415Q和27寸的P2715Q的评论和评分都很好。两款都能支持到60Hz的刷新率，并同时支持SST和MST。 支持的mac型号 MacBook Pro 13寸Early 2015：支持1个60Hz的4k，或者2个30Hz的4k。雷电：1个60Hz的4k。HDMI：1个30Hz的4k。 15寸Mid 2014或更新：支持2个60Hz的4k（NVIDIA GeForce GT 750M）。 15寸Late 2013：支持1个60Hz的4k，或者2个30Hz的4k。雷电：1个60Hz的4k。HDMI：1个30Hz的4k。 15寸Mid 2012和Early 2013：1个30Hz的4k（NVIDIA GeForce GT 650M）。［这个还需要设置一下另外一些东西］ MacBook Air Early 2015：Broadwell处理器和Intel HD 6000可以支持1个60Hz的4k（雷电）。 12寸MacBook Early 2015：1个30Hz的4k，或者1个30Hz的4096*2160。 iMac 21.5寸Late 2015 Retina 4k：1个60Hz的4k（雷电），还能再同时多带一个25601440。 27寸Late 2015 Retina 5k：*1个60Hz的4k（雷电），再同时多带一个2560*1440。如果有AMC Radeon R9 M395X显卡，支持2个60Hz的4k（雷电）。同时使用2个雷电线，可以支持1个**5k。 Mac Pro Late 2013：带6个雷电2接口，支持3个5k（1个5k／2个雷电）。或者6个苹果雷电显示器。 Early 2009到Mid 2012：如果升级到NVIDIA GeFroce GTX 960，看图。 Mac mini Late 2014：1个30Hz的4k（HDMI／雷电），或者1个24Hz的40962160（HDMI）。不支持60Hz。［怪Intel Iris 5000咯］ *所以现在买还是再等会儿？** 有钱：随便买，任意买 或者：等。 苹果可能会在2016出Skylake Macs并带雷电3。这些mac都能支持3个60Hz的4k，或者1个60Hz的5k。 接口分别： 设备－线－屏幕之间的可行性： 由hf5677提供：https://support.apple.com/zh-cn/HT202856 HDMI 通过 Mac 上的内建 HDMI 端口连接时，可以使用具有以下分辨率和刷新率的 4K 显示器和超高清电视机： 3840 x 2160，30 Hz 4096 x 2160，24 Hz（在此分辨率下不支持镜像） 通过 USB-C Digital AV Multiport Adapter 转换器将显示器连接到 Mac 时，MacBook（Retina 显示屏，12 英寸，2015 年初）支持以上所列的显示器和刷新率。 单流传输 (SST) 显示器 与装有 OS X Mavericks v10.9.3 及更高版本的电脑配合使用时，支持以下 DisplayPort 显示器使用 30 Hz 的单流传输： Sharp PN-K321 ASUS PQ321Q Dell UP2414Q Dell UP3214Q Panasonic TC-L65WT600 与装有 OS X Yosemite v10.10.3 及更高版本的以下 Mac 电脑配合使用时，支持大多数单流传输 4K (4096 x 2160) 显示器使用 60 Hz 运行： Mac Pro（2013 年末） iMac（Retina 4K 显示屏，21.5 英寸，2015 年末） iMac（Retina 5K 显示屏，27 英寸，2014 年末及更新机型） 配备 AMD Radeon R9 M370X 的 MacBook Pro（Retina 显示屏，15 英寸，2015 年中） 与装有 OS X Yosemite v10.10.3 及更高版本的以下 Mac 电脑配合使用时，支持大多数单流传输 4K (3840 x 2160) 显示器使用 60 Hz 运行： MacBook Pro（Retina 显示屏，13 英寸，2015 年初） MacBook Pro（Retina 显示屏，15 英寸，2014 年中及更新机型） Mac Pro（2013 年末） iMac（Retina 4K 显示屏，21.5 英寸，2015 年末） iMac（Retina 5K 显示屏，27 英寸，2014 年末及更新机型） MacBook Air（2015 年初） 多流传输 (MST) 显示器 以下 Mac 电脑会自动检测并支持已启用 MST 的显示器以 60 Hz 运行： MacBook Pro（Retina 显示屏，15 英寸，2013 年末及更新机型） MacBook Pro（Retina 显示屏，13 英寸，2015 年初） Mac Pro（2013 年末） iMac（Retina 5K 显示屏，27 英寸，2014 年末及更新机型） iMac（Retina 4K 显示屏，21.5 英寸，2015 年末） 如果将 60 Hz MST 显示器与 MacBook Pro（Retina 显示屏，15 英寸，2013 年末）或 iMac（Retina 5K 显示屏，27 英寸，2014 年末）配合使用，则仅支持再连接一台 Thunderbolt 显示器","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"负数的二进制表示","slug":"math/e8-b4-9f-e6-95-b0","date":"2016-09-13T01:45:44.000Z","updated":"2019-11-08T09:59:30.991Z","comments":true,"path":"2016/09/13/math/e8-b4-9f-e6-95-b0/","link":"","permalink":"http://blog.le-more.com/2016/09/13/math/e8-b4-9f-e6-95-b0/","excerpt":"","text":"文章来源guitarhua 我们已经知道计算机中，所有数据最终都是使用二进制数表达。 我们也已经学会如何将一个10进制数如何转换为二进制数以及如何将如何将一个16进制数如何转换为二进制数，详见下图。 不过，我们仍然没有学习一个负数如何用二进制表达。 比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。 现在想知道，-5在计算机中如何表示？ 在计算机中，负数以其正值的补码形式表达。 什么叫补码呢？这得从原码，反码说起。 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1） 比如：将00000000 00000000 00000000 00000101每一位取反，得11111111 11111111 11111111 11111010。 称：11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 反码是相互的，所以也可称： 11111111 11111111 11111111 11111010 和 00000000 00000000 00000000 00000101 互为反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 比如：00000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。 那么，补码为： 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。 再举一例，我们来看整数-1在计算机中如何表示。 假设这也是一个int类型，那么： 1、先取1的原码：00000000 00000000 00000000 00000001 2、得反码： 11111111 11111111 11111111 11111110 3、得补码： 11111111 11111111 11111111 11111111 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF。 使用Windows7的用户可以使用自带的计算器来帮助学习十进制、八进制、十六进制与二进制间的相互转换，非常方便。","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"游戏开发流程与团队人员职责","slug":"other/8e-e5-9b-a2-e9-98-9f","date":"2016-09-08T14:30:40.000Z","updated":"2019-11-08T09:59:30.992Z","comments":true,"path":"2016/09/08/other/8e-e5-9b-a2-e9-98-9f/","link":"","permalink":"http://blog.le-more.com/2016/09/08/other/8e-e5-9b-a2-e9-98-9f/","excerpt":"","text":")","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"互联网工作生存指南","slug":"life/e4-ba-92-e8-81-94","date":"2016-09-06T07:46:19.000Z","updated":"2019-11-08T09:59:30.984Z","comments":true,"path":"2016/09/06/life/e4-ba-92-e8-81-94/","link":"","permalink":"http://blog.le-more.com/2016/09/06/life/e4-ba-92-e8-81-94/","excerpt":"","text":"@开发 1.不要写死 2.不要相信产品 @测试 1.不要立Flag 2.不要相信开发 @设计 1.不要相信这会是最后一次修改 2.不要相信产品 @产品 1.不要相信任何人 2.注意人身安全 @运营 1.不要相信任何人 2.躲在产品后面","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.le-more.com/categories/Life/"}],"tags":[]},{"title":"Win10 解决无法多用户远程登录问题","slug":"other/e8-bf-9c-e7-a8-8b-e7","date":"2016-09-01T10:48:59.000Z","updated":"2019-11-08T09:59:30.996Z","comments":true,"path":"2016/09/01/other/e8-bf-9c-e7-a8-8b-e7/","link":"","permalink":"http://blog.le-more.com/2016/09/01/other/e8-bf-9c-e7-a8-8b-e7/","excerpt":"","text":"具体怎么解决win10 多用户登录请查看此文章：http://www.setsea.net/wordpress/os/2015/08/11/1636.html 使用补丁的方法，如果安装360，可以使用右键360强力删除，然后替换dll。 奇怪问题：执行install.bat 报 OpenKeyReadonly error code 0 查到问题：注册表中无termservice，这个注册表项无故被删除了，导致远程始终失败。 解决问题：从其他电脑从注册表中导出termservice节点后，导入。重启后问题解决！","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"Wordpress 安装配置 win10,win2003","slug":"tools/wordpress-e5-ae-89","date":"2016-09-01T10:47:32.000Z","updated":"2019-11-08T09:59:31.004Z","comments":true,"path":"2016/09/01/tools/wordpress-e5-ae-89/","link":"","permalink":"http://blog.le-more.com/2016/09/01/tools/wordpress-e5-ae-89/","excerpt":"","text":"其中部分参考网上教程，现将过程记录一下，文中记录都是在win10下面安装的，如果在win2003需要下载对应的版本软件（Appache2.2,mysql 5.5,php5.4,phpadmin4.0） WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。 安装目录：D:\\wordpress 环境准备 mysql php appach 1. MySql 环境配置下载地址：http://dev.mysql.com/downloads/mysql/ 下载版本：Windows (x86, 32-bit), ZIP Archive 环境配置： 路径：D:\\wordpress\\MySql 添加系统环境变量Path：D:\\wordpress\\MySql\\bin 复制目录下的my-default.ini创建my.ini 修改basedir = D:\\wordpress\\MySql datadir = D:\\wordpress\\MySql\\data 以管理员身份运行cmd,进入D:\\wordpress\\MySql\\bin目录，执行：mysql install 安装mysql 执行mysqld –initialize-insecure –user=mysql 初始化，根目录会创建一个data目录 执行net start mysql 启动服务 执行mysql -u root -p 登录 修改密码：SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’); 创建数据库：CREATE DATABASE wordpress 分配权限：GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost IDENTIFIED BY ‘pass’; SET PASSWORD FOR ‘wordpress’@’localhost’ = OLD_PASSWORD(‘密码’); 5.5版本配置：http://blog.csdn.net/u013628152/article/details/51229136 2.PHP环境配置下载地址：http://windows.php.net/download/ 下载版本：下载线程安全版本（VC11 x86 Thread Safe） 环境配置： 解压目录:D:\\wordpress\\php5.6 复制php.ini-production 创建php.ini 设置环境变量D:\\wordpress\\php5.6 和D:\\wordpress\\php5.6\\ext 常用：extension_dir = “ext” 常用：extension=php_mbstring.dll 常用：extension=php_mysql.dll 常用：extension=php_mysqli.dll 3.Apache 环境配置下载地址：http://www.apachelounge.com/download/ 下载 版本：httpd-2.4.23-win32-VC11.zip 环境配置： 解压路径：D:\\wordpress\\Apache24 打开conf目录下的httpd.conf 修改ServerRoot DocumentRoot Directory ScriptAlias 目录更新为：D:\\wordpress\\Apache24 #ServerName www.example.com:80 去掉# DirectoryIndex index.html 修改为DirectoryIndex index.html index.php index.htm 添加 LoadModule php5_module “D:/wordpress/php5.6/php5apache2_4.dll” 添加 AddType application/x-httpd-php .php .html .htm 添加 PHPIniDir “D:/wordpress/php5.6” 4.Wordpress 环境配置下载地址：http://cn.wordpress.org 下载版本：wordpress-4.5.3-zh_CN 环境配置： 解压到d:\\wordpress\\Apache24\\htdocs\\wordpress localhost\\wordpress 配置数据库名，数据库用户名，密码及表名前缀（前提是创建好数据库，设置好数据库用户密码等） 成功就进入5分钟安装过程 其他： phpadmin工具 http://www.phpmyadmin.net/ 使用问题汇总： 1.在线下载，升级失败 修改php.ini extension=php_curl.dll max_execution_time = 60 post_max_size = 8M","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"《Head First 设计模式》------学习总结","slug":"game/head-first-e8-ae-be-e8-ae","date":"2016-09-01T10:45:48.000Z","updated":"2019-11-08T09:59:30.979Z","comments":true,"path":"2016/09/01/game/head-first-e8-ae-be-e8-ae/","link":"","permalink":"http://blog.le-more.com/2016/09/01/game/head-first-e8-ae-be-e8-ae/","excerpt":"","text":"使用模式最好的方式：把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。 过去是代码复用，现在是经验复用。 基本定义 模式 是在情境（context）下，针对某个问题的某种解决方案。 反模式 告诉你如何采用一个不好的解决方案解决一个问题。 OO基础 抽象 封装 多态 继承 OO原则 封装变化 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。(关键就是多态，利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型行为上。“针对超类型编程”可明确说成：变量的声明应该是超类型，通常是一个抽象类或接口) 运行时多态。 多用组合，少用继承 为了交互对象之间的松耦合设计而努力。 类应该对扩展开放，对修改关闭 要依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 别调用（打电话给）我们，我们会调用（打电话给）你。 一个类应该只有一个引起变化的原因。 OO模式 观察者模式 出版者+订阅者=观察者模式，定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 装饰者模式 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 工厂方法模式 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 优点：将创建对象的代码集中在一个对象或方法中，避免代码重复，方便维护。在实例化对象时，依赖接口，而不是具体类。 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 单件模式 确保一个类只有一个实例，并提供一个全局访问点。 命令模式 将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 适配器模式 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 模板方法模式 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 策略模式 定义一个算法家族，并让这些算法可以互换。正因为每一个算法都被封装起来了所以客户可以轻易地使用不同的算法。 迭代器 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 组合模式 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 状态模式 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 代理模式 为另一个对象提供一个替身或占位符以控制对这个对象的访问。 复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。（mvc） OO模式（其他） 桥接 使用桥接模式（Bridge Pattern）不只改变你的实现，也改变你的抽象。 生成器 使用生成器模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。 责任链 当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式（Chain of Responsibility Pattern） 蝇量 如想让某个类的一个实例能用来提供许多“虚拟实例”，就使用蝇量模式（Flyweight Pattern） 解释器 使用解释器模式（Interpreter Pattern）为语言创建解释器 中介者 使用中介者模式（Mediator Pattern）来集中相关对象之间复杂的沟通和控制方式 备忘录 当你需要让对象返回之前的状态时（例如，你的用户请求“撤销”），就使用备忘录模式（Memento Pattern） 原型 当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式（Prototype Pattern） 访问者 当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式（Visitor Pattern）","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.le-more.com/categories/Other/"}],"tags":[]},{"title":"Redmine 安装 win10系统","slug":"tools/redmine-e5-ae-89-e8","date":"2016-09-01T10:45:16.000Z","updated":"2019-11-08T09:59:31.003Z","comments":true,"path":"2016/09/01/tools/redmine-e5-ae-89-e8/","link":"","permalink":"http://blog.le-more.com/2016/09/01/tools/redmine-e5-ae-89-e8/","excerpt":"","text":"官网安装指南：http://www.redmine.org/projects/redmine/wiki/RedmineInstall 安装环境：win10 64位 MySQL:http://dev.mysql.com/downloads/windows/installer/ （安装时版本：5.7.13） railsinstaller:http://railsinstaller.org/en （安装时版本：3.2.0） 下载安装MySQL 安装railsinstaller （注意：不能有空格） Step 1 - Redmine application¶ Get the Redmine source code by either downloading a packaged release or checking out the code repository. Step 2 - Create an empty database and accompanying user Redmine database user will be named redmine hereafter but it can be changed to anything else. MySQL CREATE DATABASE redmine CHARACTER SET utf8;CREATE USER ‘redmine’@’localhost’ IDENTIFIED BY ‘my_password’;GRANT ALL PRIVILEGES ON redmine.* TO ‘redmine’@’localhost’; Step 3 - Database connection configurationCopy config/database.yml.example to config/database.yml and edit this file in order to configure your database settings for “production” environment. Example for a MySQL database using ruby 1.8 or jruby: production: adapter: mysql2 database: redmine host: localhost username: redmine password: my_password Step 4 - Dependencies installation Redmine uses Bundler to manage gems dependencies. You need to install Bundler first: gem install bundler Then you can install all the gems required by Redmine using the following command: bundle install –without development test rmagick gem install mysql2 – ‘–with-mysql-dir=”C:\\Program Files\\MySQL\\MySQL Server 5.6\\mysql-connector-c-6.1.1-win32”‘ Step 5 - Session store secret generation This step generates a random key used by Rails to encode cookies storing session data thus preventing their tampering. Generating a new secret token invalidates all existing sessions after restart. with Redmine 2.x: bundle exec rake generate_secret_token Step 6 - Database schema objects creation Create the database structure, by running the following command under the application root directory: Windows syntax: set RAILS_ENV=productionbundle exec rake db:migrate Step 7 - Database default data setWindows: set RAILS_ENV=productionset REDMINE_LANG=zhbundle exec rake redmine:load_default_data Step 9 - Test the installation¶Test the installation by running WEBrick web server: with Redmine 3.x: bundle exec rails server webrick -e production Once WEBrick has started, point your browser to http://localhost:3000/. You should now see the application welcome page. 其他IP也可访问 bundle exec rails server webrick -e production -b 0.0.0.0 Step 10 - Logging into the applicationUse default administrator account to log in: login: admin password: admin You can go to Administration menu and choose Settings to modify most of the application settings. 其他参考官方文档 参考链接：http://www.51testing.com/html/29/595529-853889.html","categories":[{"name":"Tools","slug":"Tools","permalink":"http://blog.le-more.com/categories/Tools/"}],"tags":[]},{"title":"Unreal 开发之 --- 问题汇总","slug":"ue4/unreal-e5-bc-80-e5-8g","date":"2016-09-01T10:43:51.000Z","updated":"2019-11-08T09:59:31.039Z","comments":true,"path":"2016/09/01/ue4/unreal-e5-bc-80-e5-8g/","link":"","permalink":"http://blog.le-more.com/2016/09/01/ue4/unreal-e5-bc-80-e5-8g/","excerpt":"","text":"总结在开发和学习中遇到的常见错误及解决方法 1. Epic Launcher 登录不成功 首先排除在任务管理器中重复进程，有时候启动两个进程导致始终登录不了 其实为添加Epic Game Launcher 目标位置添加 -http=wininet 这个方法不一定有效….但可以一试 2.’class’ type redefinition 类重复定义 确认只定义一次类名，却老是报定义重复，问题在于 头文件中的宏 #pragma once 因unreal 工程示例中没有#ifndef /#define/#endif 宏，故为了省事也为了保持一致，才出现这样的头文件重复引用的错误。 3.debug 游戏项目却打开了引擎 需选择指定目标，默认是DebugGame Editer 4.GlobalShaderCache-PCD3D_SM5.bin is missing 需要在Unreal 编辑文件菜单中，刷新并构建项目 5.UE 4.11源码编译报错 ‘bAttributeLessDraw’: undeclared identifierUE4 解决办法：第2793行末尾有一个”（中文右双引号），替换为英文双引号并保存即可 6.VS2015 Build工程失败 错误描述（类似）： ‘/IC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE’: command line argument number 279 does not match precompiled header 解决办法1（直到VS update 2为止, build 4.12.5之前的版本都没有问题. 安装VS update 3以后, 只能build 4.12.5以及之后的版本.）： Completely uninstall visual studio Use the Extra visual studio uninstall cleaner. Found here: https://github.com/Microsoft/VisualStudioUninstaller/releases Delete the remaining Visual Studio installation folder. Do a restart and this machine should be ready for a clean installation Download the Visual Studio 2015 installer without any updates: https://www.microsoft.com/en-us/download/details.aspx?id=48146 Now make sure you do a custom installation and deselect update 3!!! Once the installation is finished you need to generate visual studio project files for your unreal projects.解决办法2： UE4 to 4.12.5 版本修复了这个问题 7.UE4编辑器 虚拟现实预览 是灰色的 VR Preview grey 问题：使用UE4开发 HTC VIVE时，使用UE4 4.12版本可以使用VR Preview，但4.13及以后的版本不可以选择 解决办法：启动Steam-&gt;库&gt;SteamVR-&gt;右键属性-&gt;打开本地文件的选项卡-&gt;点开验证工具缓存的完整性 (如果还无效，删除SteamVR重新安装) Stereo Panoramic Movie Capture export black png： 错误信息：LogD3D11RHI: Timed out while waiting for GPU to catch up. (0.5 s) 解决办法：换好的显卡就OK 参考： Stereo Panoramic plugin in Standalone causes dark shadows 从虚幻 4 中采集 360 度立体电影 4.11 preview 7 Stereo Panoramic export works! SeamVR 全屏 UE4 VR 模式下全屏解决办法 制作天空盒示例 Skybox from DDS cubemap","categories":[{"name":"UE4","slug":"UE4","permalink":"http://blog.le-more.com/categories/UE4/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.le-more.com/tags/总结/"},{"name":"ue4","slug":"ue4","permalink":"http://blog.le-more.com/tags/ue4/"}]},{"title":"Unreal 开发之---基本概念","slug":"ue4/unreal-e5-bc-80-e5-8f","date":"2016-09-01T10:43:22.000Z","updated":"2019-11-08T09:59:31.039Z","comments":true,"path":"2016/09/01/ue4/unreal-e5-bc-80-e5-8f/","link":"","permalink":"http://blog.le-more.com/2016/09/01/ue4/unreal-e5-bc-80-e5-8f/","excerpt":"","text":"常见名词的或缩写概念记录 Pawn - Actor 的一种类型，用于表现一个可供控制的游戏物体，比如是玩家的角色。Pawn 通常都是被玩家或者 AI 通过 Controller 控制并移动。 Character - 一种特殊类型的 Pawn，用于双足类型的角色，并具备一些复杂的功能。 Controller - 依附并控制一个 Pawn。通过将 Pawn 和 Controller 的分离，我们可以编写 AI Controller，用于控制 Pawn，并且和玩家控制 Pawn 采用相同的接口。 Player Controller - 一个更为特殊的 Controller，用于从玩家的手柄中获得输入信息，或者鼠标键盘中获得殊瑞星纳西，并将这些信息驱动它所控制的 Pawn 或者 Character 的行为。 静态网格体（Static Mesh）是由一组多边形构成的一块几何体，这些多边形可以缓存到显存中并由显卡进行渲染。这使得可以高效地渲染这些多边形，也就意味着它们可以比其他诸如 BSP 画刷这样的几何体类型更加复杂。由于它们在显存中进行缓存，所以可对静态网格物体进行平移、旋转和缩放操作，但是使用任何方法都无法对它们的顶点进行动画处理。静态网格体是虚幻引擎中创建的关卡时创建世界几何体所使用的基础单元。它们是在外部建模软件中创建的3D模型（例如 3dsMax，Maya，Softimage 等），通过内容浏览器将它们导入虚幻编辑器中，保存到包内，然后通过多种方式应用它们来创建可渲染的元素。在游戏中，使用虚幻引擎制作的绝大多数地图都包含静态网格体，通常形式为 Static Mesh Actors（静态网格体 Actor）。静态网格体的其他用途为创建门或电梯等的可移动物体、刚体物理对象、植被与地形装饰、程序化创建的建筑物、游戏目标以及许多其他视觉元素。 BSP是Binary Space Partition的缩写，即二元空间分割，这种计算机图形技术会把复杂的多边形分割为很多更小、更简单的多边形，使得其可以更快速地渲染。 CSG它代表Constructive Solid Geometry，即构造实体几何体。这只不过是世界几何体(World Geometry)的另一种说法，在虚幻引擎中，它是指由BSP画刷制作的几何体。制作关卡的主要流程为：首先创建BSP画刷来确定关卡的区域和体积，然后在UnrealEd中使用这些画刷来制作关卡的CSG或世界几何体 SSAO（屏幕空间环境遮挡） 由于遮挡而造成的近似于光衰减的效果。 这个效果的最佳应用是进行细微调整，除了可用于标准的全局光照外，还可用于角落、缝隙或其他地方来使其变暗，从而创建更为自然、真实的外观。 LightmassImportanceVolume Lightmass 可以创建光照贴图，该光照贴图具有像区域阴影和间接漫反射这样的复杂光照交互。能够预计算一部分静态和固定的光照的效果。 虽然许多地图中的网格物体都位于编辑器网格边缘的外面，但实际上需要高质量光照的活动区域（playable area）是非常小的。 Lightmass 基于关卡的大小来发射光量子，所以这些不易引起人注意的网格物体将会大大地增加需要发射的粒子的数量，并且会增加光照的构建时间。 LightmassImportanceVolume 控制 Lightmass 发射光量子的范围，允许您将粒子集中在需要详细间接光照的区域。 在重要体积之外的区域仅获得低级质量的间接反射光照。 如果放置了多个 Lightmass Importance Volume，大部分的光照构建都将在一个包含了所有的 Volume 的边界框内处理。不过体积光照样本仍然会仅放置在那些较小的体积内。 待续… 参考：官方文档","categories":[{"name":"UE4","slug":"UE4","permalink":"http://blog.le-more.com/categories/UE4/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"http://blog.le-more.com/tags/ue4/"}]},{"title":"Android 开发环境一键式管理工具AndroidWorks","slug":"cocos/e5-85-b7androidworks","date":"2016-09-01T10:42:36.000Z","updated":"2019-11-08T09:59:30.971Z","comments":true,"path":"2016/09/01/cocos/e5-85-b7androidworks/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/e5-85-b7androidworks/","excerpt":"","text":"注意：现在无法下载 2018.6.12 2018.8.4 版本CodeWorks-1R7-osx_b104 可以打开下载 最近在学习unreal引擎过程，发现一个一键部署android开发环境的工具AndroidWorks。 过去在配置android开发环境时往往遇到很多问题，sdk,ndk官网访问不了，有了AndroidWorks免去了很多麻烦，节省大量的时间。 下面一段摘自网络，可以大概了解这个工具： 近日，Nvidia宣布，为主机平台打造更多内容 - Android游戏，该公司推出基于GameWorks工具包基础上的全新工具 - AndroidWorks已发布。而有趣的是，该工具适用于非Nvidia的Tegra处理器的Android设备。 AndroidWorks则降低了入学门槛，以更加轻松易懂的方式帮助初学者获得进步。Google提供了独立的Android Studio SDK包来替代各种独立工具，而现在Nvidia则是再向前迈进一步，通过自家定制的游戏开发工具将Android SDK和NDK整合在一起，有点类似于整合Visual Studio、Graphics Debugger,System Profiler的Nsight。Nvidia表示用户能够在工具包中获得制作Android游戏的所有工具，只需安装一个包就能轻松获得。 AndroidWorks 的使用很简单下载安装好后启动，选择要下载的工具，静静等待就好，官网链接 QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"quick-lua 获取Cocos Studios动画播放回调","slug":"cocos/quick-lua-cocos-studios","date":"2016-09-01T10:34:12.000Z","updated":"2019-11-08T09:59:30.977Z","comments":true,"path":"2016/09/01/cocos/quick-lua-cocos-studios/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/quick-lua-cocos-studios/","excerpt":"","text":"quick-lua 版本是3.5 cocos studios是2.0以上，目前是最新版本 在cocos studios中回调使用帧事件也是可以的，就是在关键帧上设置回调事件： 设置的时候，要选中开始记录动画，然后选中关键帧，再设置事件名称。在动画执行到这一帧时会触发该事件，在lua中使用方式为： local eventFrameCall = function(frame) local eventName = frame:getEvent() if eventName == &quot;wait&quot; then end end end timeline:clearFrameEventCallFunc() timeline:setFrameEventCallFunc(eventFrameCall) timeline:play(&quot;wait&quot;, false)但这种方式很繁琐，在修改动画的时候很容易忘记有这个事件而出错 在使用cocosbuilder的时候，可以设置动画回调函数。在cocos studios也有这个的回调，但在quick-lua 3.5中还没有支持。所以下面记录另外一种回调方式。 简单说就是获取动画执行时间，手动设置回调方法： timeline:play(&quot;wait&quot;, false) local duration = UIHelper.getAnimationDuration(timeline local block = cc.CallFunc:create( function(sender) callBack() end ) self:runAction(cc.Sequence:create(cc.DelayTime:create(duration), block)) 通过UIHelper.getAnimationDuration方法获取动画执行的时间： function UIHelper.getAnimationDuration(timeline) local speed = timeline:getTimeSpeed()-- local duration = timeline:getDuration() local startFrame = timeline:getStartFrame() local endFrame = timeline:getEndFrame() local frameNum = endFrame - startFrame return 1.0 /(speed * 60.0) * frameNumend 这样的方法虽然增加一些代码，但减少因编辑器经常更新而造成的问题 完整的UIHelper.lua如下： UIHelper = {} -- tolua.cast(ccsLayout:getChildByName(“server_list”) ,”ListView”) . function UIHelper.getControl(root,parentNames) local newRoot = root for i = 1,#parentNames do local name = parentNames[i] local child = newRoot:getChildByName(name) if not child then newRoot = nil break else newRoot = child end end return newRootend function UIHelper.createNode(parent,file,pos) local layout = cc.CSLoader:createNode(file) if pos then layout:setPosition(pos) end parent:addChild(layout) local timeline = cc.CSLoader:createTimeline(file) layout:runAction(timeline) return layout,timelineend function UIHelper.getAnimationDuration(timeline) local speed = timeline:getTimeSpeed()-- local duration = timeline:getDuration() local startFrame = timeline:getStartFrame() local endFrame = timeline:getEndFrame() local frameNum = endFrame - startFrame return 1.0 /(speed * 60.0) * frameNumend function UIHelper.runTimeline(layout,timeline, animationName,loop) if not loop then loop = false end if animationName ~= nil and timeline:IsAnimationInfoExists(animationName) then timeline:play(animationName, loop) else timeline:gotoFrameAndPlay(0, loop) endend –function UIHelper.runTimelineAndClear(layout,timeline, animationName) UIHelper.runAction(layout,timeline, animationName) local duration = UIHelper.getAnimationDuration(timeline) local block = cc.CallFunc:create( function(sender) layout:removeSelf() end ) layout:runAction(cc.Sequence:create(cc.DelayTime:create(duration), block))end function UIHelper.runTimelineAndCall(layout,timeline, animationName,callBack) local duration = UIHelper.getAnimationDuration(timeline) local block = cc.CallFunc:create( function(sender) return callBack end ) layout:runAction(cc.Sequence:create(cc.DelayTime:create(duration), block))end QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"quick-3.5 绑定自定义C++类到Lua并使用cocos code ide 调式","slug":"cocos/cocos-code-ide-e8-b0-83","date":"2016-09-01T10:27:41.000Z","updated":"2019-11-09T02:56:57.937Z","comments":true,"path":"2016/09/01/cocos/cocos-code-ide-e8-b0-83/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/cocos-code-ide-e8-b0-83/","excerpt":"","text":"在这里主要记录怎么绑定自定义C++类到Lua 参考文章在这里【绑定自定义类至Lua】，在我操作过程中略有不同，现在把步骤记录下来。 1.打开引擎目录下\\tools\\tolua\\README.mdown，安装相应软件 2.项目目录\\frameworks\\cocos2d-x\\tools\\tolua,复制cocos2dx_cocosbuilder-&gt;custom.ini,genbindings-&gt;custom-genbindings.py 3.修改复制后的文件 custion.ini \\[custom_socket\\] \\# the prefix to be added to the generated functions. You might or might not use this in your own \\# templates prefix = custom_socket \\# create a target namespace (in javascript, this would create some code like the equiv. to \\`ns = ns || {}\\`) \\# all classes will be embedded in that namespace target_namespace = android_headers = -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android\\_flags = -D\\_SIZE\\_T\\_DEFINED_ clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include clang\\_flags = -nostdinc -x c++ -std=c++11 -U \\_\\_SSE__ cocos_headers = -I%(cocosdir)s -I%(cocosdir)s/cocos -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s/cocos/platform/android cocos_flags = -DANDROID cxxgenerator_headers = \\# extra arguments for clang extra\\_arguments = %(android\\_headers)s %(clang\\_headers)s %(cxxgenerator\\_headers)s %(cocos\\_headers)s %(android\\_flags)s %(clang\\_flags)s %(cocos\\_flags)s %(extra_flags)s \\# what headers to parse headers = %(cocosdir)s/../runtime-src/Classes/net/SocketModule.h \\# what classes to produce code for. You can use regular expressions here. When testing the regular \\# expression, it will be enclosed in &quot;^$&quot;, like this: &quot;^Menu*$&quot;. classes = ClientSocket.* CMD_Command.* ConnectHandler.* RecvHandler.* \\# what should we skip? in the format ClassName::\\[function function\\] \\# ClassName is a regular expression, but will be used like this: &quot;^ClassName$&quot; functions are also \\# regular expressions, they will not be surrounded by &quot;^$&quot;. If you want to skip a whole class, just \\# add a single &quot;*&quot; as functions. See bellow for several examples. A special class name is &quot;*&quot;, which \\# will apply to all class names. This is a convenience wildcard to be able to skip similar named \\# functions from all classes. skip = rename_functions = rename_classes = \\# for all class names, should we remove something when registering in the target VM? remove_prefix = \\# classes for which there will be no &quot;parent&quot; lookup classes\\_have\\_no_parents = \\# base classes which will be skipped when their sub-classes found them. base\\_classes\\_to_skip = \\# classes that create no constructor \\# Set is special and we will use a hand-written constructor abstract_classes = \\# Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are &apos;yes&apos; or &apos;no&apos;. script\\_control\\_cpp = no主要修改： 第1行：[custom_socket] 第4行：prefix = custom_socket 第8行：target_namespace = 第26行：headers = %(cocosdir)s/../runtime-src/Classes/net/SocketModule.h 第30行：classes = ClientSocket.* CMD_Command.* ConnectHandler.* RecvHandler.* 其余根据具体来设置，主要说一下第26行是创建一个头文件，包含导出类的相关头文件，30行是导出的类定义 custom-genbindings.py #!/usr/bin/python \\# This script is used to generate luabinding glue codes. \\# Android ndk version must be ndk-r9b. import sys import os, os.path import shutil import ConfigParser import subprocess import re from contextlib import contextmanager def \\_check\\_ndk\\_root\\_env(): &apos;&apos;&apos; Checking the environment NDK_ROOT, which will be used for building &apos;&apos;&apos; try: NDK\\_ROOT = os.environ\\[&apos;NDK\\_ROOT&apos;\\] except Exception: print &quot;NDK\\_ROOT not defined. Please define NDK\\_ROOT in your environment.&quot; sys.exit(1) return NDK_ROOT def \\_check\\_python\\_bin\\_env(): &apos;&apos;&apos; Checking the environment PYTHON_BIN, which will be used for building &apos;&apos;&apos; try: PYTHON\\_BIN = os.environ\\[&apos;PYTHON\\_BIN&apos;\\] except Exception: print &quot;PYTHON_BIN not defined, use current python.&quot; PYTHON_BIN = sys.executable return PYTHON_BIN class CmdError(Exception): pass @contextmanager def _pushd(newDir): previousDir = os.getcwd() os.chdir(newDir) yield os.chdir(previousDir) def \\_run\\_cmd(command): ret = subprocess.call(command, shell=True) if ret != 0: message = &quot;Error running command&quot; raise CmdError(message) def main(): cur_platform= &apos;??&apos; llvm_path = &apos;??&apos; ndk\\_root = \\_check\\_ndk\\_root_env() # del the &quot; in the path ndk\\_root = re.sub(r&quot;\\\\&quot;&quot;, &quot;&quot;, ndk\\_root) python\\_bin = \\_check\\_python\\_bin_env() platform = sys.platform if platform == &apos;win32&apos;: cur_platform = &apos;windows&apos; elif platform == &apos;darwin&apos;: cur_platform = platform elif &apos;linux&apos; in platform: cur_platform = &apos;linux&apos; else: print &apos;Your platform is not supported!&apos; sys.exit(1) if platform == &apos;win32&apos;: x86\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.3/prebuilt&apos;, &apos;%s&apos; % cur\\_platform)) if not os.path.exists(x86\\_llvm\\_path): x86\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.4/prebuilt&apos;, &apos;%s&apos; % cur\\_platform)) else: x86\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.3/prebuilt&apos;, &apos;%s-%s&apos; % (cur\\_platform, &apos;x86&apos;))) if not os.path.exists(x86\\_llvm\\_path): x86\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.4/prebuilt&apos;, &apos;%s-%s&apos; % (cur\\_platform, &apos;x86&apos;))) x64\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.3/prebuilt&apos;, &apos;%s-%s&apos; % (cur\\_platform, &apos;x86_64&apos;))) if not os.path.exists(x64\\_llvm\\_path): x64\\_llvm\\_path = os.path.abspath(os.path.join(ndk\\_root, &apos;toolchains/llvm-3.4/prebuilt&apos;, &apos;%s-%s&apos; % (cur\\_platform, &apos;x86_64&apos;))) if os.path.isdir(x86\\_llvm\\_path): llvm\\_path = x86\\_llvm_path elif os.path.isdir(x64\\_llvm\\_path): llvm\\_path = x64\\_llvm_path else: print &apos;llvm toolchain not found!&apos; print &apos;path: %s or path: %s are not valid! &apos; % (x86\\_llvm\\_path, x64\\_llvm\\_path) sys.exit(1) project\\_root = os.path.abspath(os.path.join(os.path.dirname(\\_\\_file__), &apos;..&apos;, &apos;..&apos;)) cocos\\_root = os.path.abspath(os.path.join(project\\_root, &apos;&apos;)) cxx\\_generator\\_root = os.path.abspath(os.path.join(project_root, &apos;tools/bindings-generator&apos;)) # save config to file config = ConfigParser.ConfigParser() config.set(&apos;DEFAULT&apos;, &apos;androidndkdir&apos;, ndk_root) config.set(&apos;DEFAULT&apos;, &apos;clangllvmdir&apos;, llvm_path) config.set(&apos;DEFAULT&apos;, &apos;cocosdir&apos;, cocos_root) config.set(&apos;DEFAULT&apos;, &apos;cxxgeneratordir&apos;, cxx\\_generator\\_root) config.set(&apos;DEFAULT&apos;, &apos;extra_flags&apos;, &apos;&apos;) # To fix parse error on windows, we must difine \\_\\_WCHAR\\_MAX__ and undefine \\_\\_MINGW32\\_\\_ . if platform == &apos;win32&apos;: config.set(&apos;DEFAULT&apos;, &apos;extra\\_flags&apos;, &apos;-D\\_\\_WCHAR\\_MAX\\_\\_=0x7fffffff -U\\_\\_MINGW32\\_\\_&apos;) conf\\_ini\\_file = os.path.abspath(os.path.join(os.path.dirname(\\_\\_file\\_\\_), &apos;userconf.ini&apos;)) print &apos;generating userconf.ini...&apos; with open(conf\\_ini\\_file, &apos;w&apos;) as configfile: config.write(configfile) # set proper environment variables if &apos;linux&apos; in platform or platform == &apos;darwin&apos;: os.putenv(&apos;LD\\_LIBRARY\\_PATH&apos;, &apos;%s/libclang&apos; % cxx\\_generator\\_root) if platform == &apos;win32&apos;: path_env = os.environ\\[&apos;PATH&apos;\\] os.putenv(&apos;PATH&apos;, r&apos;%s;%s\\\\libclang;%s\\\\tools\\\\win32;&apos; % (path\\_env, cxx\\_generator\\_root, cxx\\_generator_root)) try: tolua\\_root = &apos;%s/tools/tolua&apos; % project\\_root output\\_dir = &apos;%s/../runtime-src/Classes/lua-bindings/auto&apos; % project\\_root cmd\\_args = {&apos;custom.ini&apos; : (&apos;custom\\_socket&apos;, &apos;lua\\_custom\\_socket_auto&apos;),\\ } target = &apos;lua&apos; generator\\_py = &apos;%s/generator.py&apos; % cxx\\_generator_root for key in cmd_args.keys(): args = cmd_args\\[key\\] cfg = &apos;%s/%s&apos; % (tolua_root, key) print &apos;Generating bindings for %s...&apos; % (key\\[:-4\\]) command = &apos;%s %s %s -s %s -t %s -o %s -n %s&apos; % (python\\_bin, generator\\_py, cfg, args\\[0\\], target, output_dir, args\\[1\\]) \\_run\\_cmd(command) print &apos;---------------------------------&apos; print &apos;Generating lua bindings succeeds.&apos; print &apos;---------------------------------&apos; except Exception as e: if e.\\_\\_class\\_\\_.\\_\\_name\\_\\_ == &apos;CmdError&apos;: print &apos;---------------------------------&apos; print &apos;Generating lua bindings fails.&apos; print &apos;---------------------------------&apos; sys.exit(1) else: raise \\# -------------- main -------------- if \\_\\_name\\_\\_ == &apos;\\_\\_main\\_\\_&apos;: main() 主要修改： 第134行： output\\_dir = &apos;%s/../runtime-src/Classes/lua-bindings/auto&apos; % project\\_root 第136行： cmd\\_args = {&apos;custom.ini&apos; : (&apos;custom\\_socket&apos;, &apos;lua\\_custom\\_socket_auto&apos;),\\ } 修改好后，在命令行执行：custom-genbindings.py 如果没有错误的话会生成lua\\_custom\\_socket\\_auto.hpp和lua\\_custom\\_socket\\_auto.cpp 接下来注册自定义模块： 1.添加到工程 ![](http://img.blog.csdn.net/20150914172814416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 2.引入到AppDelegate ![](http://img.blog.csdn.net/20150914172852765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 3.注册模块 ![](http://img.blog.csdn.net/20150914172932866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 使用cocos code IDE 1.2.0断点调试，由于使用调试的模拟器是另外一个程序quick-3.5/tools/simulator，所以需要将脚本生成的文件在simulator工程再添加一遍： ![](http://img.blog.csdn.net/20150914173525975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 生成新的模拟器，然后在lua中测试，就可以调用自定义的C++类了 --test self.socket_ = ClientSocket:new() self.socket_:retain() print(&quot;create success&quot;)QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"quick-lua 3.5 工程 cocos code ide 1.2.0 断点调试","slug":"cocos/quick-lua-3-cocos-code-ide","date":"2016-09-01T10:26:22.000Z","updated":"2019-11-08T09:59:30.975Z","comments":true,"path":"2016/09/01/cocos/quick-lua-3-cocos-code-ide/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/quick-lua-3-cocos-code-ide/","excerpt":"","text":"安装环境，配置等请参考其他资料 1.复制PrebuiltRuntimeLua.apk 在quick-3.5/templates/ 下创建lua-template-runtime/runtime/android 从quck-3.3/quick/templates/lua-template-quick/runtime/android 下复制PrebuiltRuntimeLua.apk到quick-3.5刚创建的目录 2.配置cocos code ide 3.create 创建项目 WIN: cocos new MyGame -p com.maxx.mygame -l lua -d D:\\Developer\\Workspace MAC: cocos new MyGame -p com.maxx.mygame -l lua -d /Developer 4.导入工程 cocos code ide 右键导入cocos 工程 5.选中项目-选择调试配置-设置模拟器 这样就可以断点调试了 QQ群：239759131 cocos 技术交流 欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"quick-3.5 打包加密的个人总结","slug":"cocos/quick-3-5-e6-89-93-e5","date":"2016-09-01T10:25:28.000Z","updated":"2019-11-08T09:59:30.975Z","comments":true,"path":"2016/09/01/cocos/quick-3-5-e6-89-93-e5/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/quick-3-5-e6-89-93-e5/","excerpt":"","text":"对于quick-lua打包问题，在网上有很多文章介绍。可到了quick-lua 3.5 框架有很大的变化，以前的都不适用了。 最近从网上找了一些资料，总结记录下来 ，仅供个人参考 ###加密### quick-lua 3.5 1. quick2.2.6和quick 3.3使用lua 5.1.5 2. 2dx的方案是，64位iOS使用lua 5.1.5，其他的平台都使用luajit，所以如果编译lua代码，需要两套 3. quick 3.5可以看做是2dx 3.5之上的一个插件，所以在这方面和2dx的方案是一样的 因为luajit不支持64位，iOS 64位上使用了lua。考虑到性能问题，其他所有的平台（包含iOS 32位），使用了luajit。这意味着如果想让一套lua脚本同时运行在iOS32位和64位设备上，那就不能使用lua字节码，lua和luajit生成的字节码是不兼容的。 首先，为什么要用luajit呢？我能想到的原因有两个，一是效率，二是加密。用luajit之后执行效率会有很大的提升，特别是在android下，另外呢luajit之后得到的文件是二进制的bytecode，基本无法反编译，因此对于商业产品来说，提高了被反解的成本。 那么luajit与lua到底有什么区别呢？从使用上来说没有区别，因为头文件都是一致的，所以将lua换成luajit来说，有两个步骤，一个是将头文件换成luajit的，另外一个是将动态链接库或者静态链接库也换成luajit的 加密命令 1.windows,android ios 确保不编译代码，只加密不编译，安全性未知 cocos luacompile -s src/ -d out/src/ -e -k key123 -b sign123 –disable-compile 2.未验证通过（无法实现） WIN: compile_scripts.bat -i D:\\MyGame\\src -o D:\\MyGame\\res\\game.zip -e xxtea_zip -es key123 -ek sign123 MAC: ./compile_scripts.sh -i /Developer/MyGame/src -o /Developer/MyGame/res/game.zip -e xxtea_zip -es key123 -ek sign123 AppDelegate.cpp 修改 stack-&gt;loadChunksFromZIP(“res/game.zip”); stack-&gt;executeString(“require ‘main’”); 解决办法：待解决 1.修改quick-3.5框架，只使用lua不使用luajit,然后使用quick-3.3的加密工具加密 （牺牲性能，较可行） 2.更新quick-3.5 luajit库 使用2.1版本支持ios 64位（目前只是alph版本） 3.升级到3.7支持ios 64 bytecode （这个行不通，已经验证） QQ群：239759131 技术交流群欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"quick-lua AssetsManager 热更新","slug":"cocos/quick-lua-assetsmanager-e","date":"2016-09-01T10:21:11.000Z","updated":"2019-11-08T09:59:30.976Z","comments":true,"path":"2016/09/01/cocos/quick-lua-assetsmanager-e/","link":"","permalink":"http://blog.le-more.com/2016/09/01/cocos/quick-lua-assetsmanager-e/","excerpt":"","text":"网上关于热更新文章很多，我在官方例子及js的代码基础上做了移植 quick-lua版本 3.5 UpdateScene类 local UpdateScene = class(“UpdateScene”, cc.Scene) function UpdateScene:ctor() end function UpdateScene:onExit() if self.am_ then self.am_:release() self.am_ = nil endend function UpdateScene:run() self.layer_ = cc.Layer:create() self:addChild(self.layer_) local winSize = cc.Director:getInstance():getWinSize() local lblProgress = cc.Label:createWithTTF(&quot;0%&quot;,&quot;fonts/fzy4.ttf&quot;,40) lblProgress:setPosition(cc.p(winSize.width/2, winSize.height/2 + 50)) self.layer_:addChild(lblProgress) self.storagePath_ = cc.FileUtils:getInstance():getWritablePath() .. &quot;/&quot;..&quot;game_assets&quot; self.am_ = cc.AssetsManagerEx:create(&quot;res/project.manifest&quot;, self.storagePath_) self.am_:retain() if self.am_:getLocalManifest():isLoaded() then local localManifest = self.am_:getLocalManifest() print(localManifest:getVersion()) end local failCount = 0 if not self.am_:getLocalManifest():isLoaded() then print(&quot;Fail to update assets, step skipped.&quot;) self:startGame() else local function onUpdateEvent(event) local eventCode = event:getEventCode() if eventCode == cc.EventAssetsManagerEx.EventCode.ERROR\\_NO\\_LOCAL_MANIFEST then print(&quot;No local manifest file found, skip assets update.&quot;) self:startGame() elseif eventCode == cc.EventAssetsManagerEx.EventCode.NEW\\_VERSION\\_FOUND then elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_PROGRESSION then local assetId = event:getAssetId() local percent = event:getPercent() local percentByFile = event:getPercentByFile() local strInfo = &quot;&quot; if assetId == cc.AssetsManagerExStatic.VERSION_ID then strInfo = string.format(&quot;Version file: %d%%&quot;, percent) elseif assetId == cc.AssetsManagerExStatic.MANIFEST_ID then strInfo = string.format(&quot;Manifest file: %d%%&quot;, percent) else strInfo = string.format(&quot;%d%%&quot;, percent) end lblProgress:setString(strInfo) elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR\\_DOWNLOAD\\_MANIFEST or eventCode == cc.EventAssetsManagerEx.EventCode.ERROR\\_PARSE\\_MANIFEST then print(&quot;Fail to download manifest file, update skipped.&quot;) self:startGame() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ALREADY\\_UP\\_TO_DATE or eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FINISHED then print(&quot;Update finished.&quot;) self:startGame() elseif eventCode == cc.EventAssetsManagerEx.EventCode.UPDATE_FAILED then print(&quot;Update failed. &quot;, event:getMessage()) failCount = failCount + 1 if (failCount &lt; 5) then that.am_:downloadFailedAssets() else print(&quot;Reach maximum fail count, exit update process&quot;) failCount = 0 self:startGame() end elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_UPDATING then print(&quot;Asset &quot;, event:getAssetId(), &quot;, &quot;, event:getMessage()) self:startGame() elseif eventCode == cc.EventAssetsManagerEx.EventCode.ERROR_DECOMPRESS then print(event:getMessage()) self:startGame() end end local listener = cc.EventListenerAssetsManagerEx:create(self.am_, onUpdateEvent) cc.Director:getInstance():getEventDispatcher():addEventListenerWithFixedPriority(listener, 1) self.am_:update() end if cc.Director:getInstance():getRunningScene() then cc.Director:getInstance():replaceScene(self) else cc.Director:getInstance():runWithScene(self) endend function UpdateScene:startGame() local searchPaths = cc.FileUtils:getInstance():getSearchPaths() table.insert(searchPaths, 1, self.storagePath_..”/res”) table.insert(searchPaths, 1, self.storagePath_..”/src”) cc.FileUtils:getInstance():setSearchPaths(searchPaths) require(&quot;app.MyApp&quot;).new():run()end return UpdateScene 启动方法： local UpdateScene = require “app.scenes.UpdateScene”local scene = UpdateScene.new()scene:run() QQ群：239759131 技术交流群欢迎您","categories":[{"name":"Cocos","slug":"Cocos","permalink":"http://blog.le-more.com/categories/Cocos/"}],"tags":[]},{"title":"ubuntu 使用汇总","slug":"server/ubuntu-e4-bd-bf-e7-94-a8","date":"2016-09-01T10:09:27.000Z","updated":"2019-11-08T09:59:31.000Z","comments":true,"path":"2016/09/01/server/ubuntu-e4-bd-bf-e7-94-a8/","link":"","permalink":"http://blog.le-more.com/2016/09/01/server/ubuntu-e4-bd-bf-e7-94-a8/","excerpt":"","text":"一、系统安装： http://cn.ubuntu.com/ 下载 usb 安装系统工具 http://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/ 移动硬盘安装，选择靠前的分区 创建 主分区 20480M ext3日志文件 挂载点/ 创建 逻辑分区 2048M 交换分区 开始安装 三.VWare Ubuntu指定IP地址 编辑-&gt;虚拟网络编辑器 虚拟机-&gt;设置-&gt;网络适配器 Ubuntu中的设置 二、其他 创建目录：sudo mkdir dirname 默认用户下是没有文件操作权限的，使用：sudo nautilus 命令打开一个具有文件访问权限的窗口 CodeBlocks 安装：http://www.d2school.com/codeblocks/doc/codeblocks_setup.html 挂载U盘：1.fdisk -l 查看所有的已经挂载的磁盘 mount -t vfat -o iocharset=cp936 /dev/sdb1 /mnt/usb 挂载 umount /dev/sdb1 卸载 除了用使用U盘外，在虚拟机下也可以使用共享文件夹，在虚拟机设置Shared Forlders 查看网络地址：ifconfig -a vim常用命令： :w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑 删除 文件 rm -f /etc/shadowsocks/.config.json.swp 删除文件夹 rm -rf /etc/shadowsocks","categories":[{"name":"Server","slug":"Server","permalink":"http://blog.le-more.com/categories/Server/"}],"tags":[]},{"title":"使用UE4进行VR制作的一些经验分析","slug":"ue4/e4-b8-80-e4-ba-9b-e7","date":"2016-08-16T04:42:10.000Z","updated":"2019-11-08T09:59:31.037Z","comments":true,"path":"2016/08/16/ue4/e4-b8-80-e4-ba-9b-e7/","link":"","permalink":"http://blog.le-more.com/2016/08/16/ue4/e4-b8-80-e4-ba-9b-e7/","excerpt":"","text":"UE4的演示资源还是很不错，个个精良，我这边把UE4的有代表性的演示都跑了一遍，同时也通过Rift确认效果，和里面的资源制作方式。 首先，UE4是基于物理渲染的引擎，大部分都是偏向图像真实的。使用的材质和贴图细节也更多一些。在PC上的品质要比unity好，性能应该也要比Unity费一些，所以很适合作VR产品的质量和效率标。 这里先列出自己的总结，然后再结合每个演示做一些具体分析。这些只是针对PC的高品质制作： 1）渲染风格方面，VR也可以作出基于物理渲染的效果，只要你能贴图和光照要遵守物理法则，也可以偏卡通一些的。 2）VR也可以使用PBR的金属度/镜面颜色，法线贴图，粗糙值等，但在Unity5上，你需要在金属度/镜面颜色的工作流中选择一种。UE4为了效率考虑，最好也能选择其中一种，而不是两个同时使用 3）粒子如果是要和视觉交互的，就不能用基于BillboARd生成，而是要做成基于Mesh的粒子 4）Normal Map在VR中还是可以看出凹凸感的，并不像文档中介绍的那样没有作用，但是PC上使用POM（视差映射贴图）和Tessellation（表面细分）技术可以作出比Normal Map更高的细节。 5）PBR的Specular Aliasing的问题，会被VR更加放大，需要使用可以支持Specular Anti-Aliasing的技术才可以（比如Temporal AA）。 6）VR的分辨率比较小，为了减少锯齿感，尽量避免一些使用alpha test制作的效果。 7）UI和互动的制作也很重要，这部分Unity和UE4上缺少这方面的实例。 8）调试方面，UE4自带的命令行工具对性能分析很有帮助，这个Unity自己没有那么全面的分析工具，需要自己实现和改造。 9）性能问题的优化问题，最好能保证75FPS 接下来对这些问题逐一阐述。 1）渲染风格 基于物理（PBR）或者卡通风格PBR我翻译和分享的资料里应该有很多了，这里只做一个简单介绍，PBR大概可以分为材质着色（Material Shading），光照（Lighting），后处理特效（Camera Effect）3部分，UE4和U3D都有PBR材质着色支持，但光照和后处理部分性能和效果对VR实现压力还是过大了。现阶段的PBR，主要还是靠基于微平面的BRDF，以及IBL，通过粗糙度来增加效果。动态光源和物理镜头因为VR性能的缘故尽量少用。 Order 1886的图释，只有材质是PBR的 ![](http://www.52vr.com/data/attachment/portal/201609/18/191458wk31gqoov7469666.jpg) 最近展示的VR项目里，真正采用PBR的并不多，大多是卡通，或者是着色模型简单的，如果在品质要出彩的话，确实是一个突破点。 PBR风格 ![](http://www.52vr.com/data/attachment/portal/201609/18/191458hwewpz684tylbbnb.jpg) 卡通风格的场景 ![](http://www.52vr.com/data/attachment/portal/201609/18/191458q73l0v37x67xr9rb.jpg) ![](http://www.52vr.com/data/attachment/portal/201609/18/191458um3ouzjcdbjjuvb2.jpg)2）VR的美术制作管线美术管线方面，VR和普通并没有太多特别的，卡通的沿用卡通的就可以，PBR的，美术制作时有一定的PBR管线意识，除了需要绘制粗糙度的贴图外，还需要对金属和非金属的颜色有一定的了解，而从节省资源和效率考虑，在Metalic或Specular的制作流程中选择一个就可以了 如下图所示，Metal的美术管线和Specular相比，贴图占用更小，对美术师制作起来也更直观和简单，颜色都绘制在base color上，然后只需要用Metallic的贴图标识出那些是金属和非金属，着色模型就会自动的来确定Diffuse和Specular的颜色。 而Specular的流水线，需要美术师需要有意识的把金属的颜色绘制到Specular上。通过Diffuse和Specular的颜色，来区分金属和非金属。 ![](http://www.52vr.com/data/attachment/portal/201609/18/191458a3vynrn176eq57ic.jpg)3）凹凸细节的制作UE4的官网提到，因为要左右眼分别渲染的缘故，对视觉依赖的贴图效果，如Normal Map在VR上会被“平坦化”，但实际从UE4的一些演示上看，Normal Map的效果还是有的，只是没有普通PC那么明显，同时，Directx11的POM（Parallax Occlusion Mapping）和 Tessellation，可以起到比Normal Map更好的效果。这些在Crytek的一些游戏和演示中都很常见。 下图是UE4的VR演示，ShowDown中的机器人Boss，从下面的材质看，也使用到了Normal ![](http://www.52vr.com/data/attachment/portal/201609/18/191458n4h4z5jw75705433.png)下面是Crytek的POM和TS的效果对比，在几何体细节的增加上很明显。 POM一般可以用来做墙面和地板等平面的凹凸，而Tessellation是则是可以利用Directx11的TS制作各种模型的表面细分。POM制作起来相对简单，类似Bitmap2Material的工具也能作出不错的凹凸效果。 4）粒子特效传统的Billboard粒子都是一个或大量的板型多边形朝向玩家视点的方向来模拟出效果，而VR的话，一个是双眼导致Billboard出现偏差，另外就是当玩家处在粒子附近晃动头盔浏览时，Billboard就会被看出破绽 Showdown中的导弹火焰的轨迹和爆破碎片，因为轨迹和破片是穿插在玩家视点的前进路线上，玩家可以在正面或者低头和回头观看，所以都是用网格来制作的。 5）Specular Aliasing的问题Specualar Aliasing是PBR的Specular的高频部分在较远处因为采样问题导致，表现就是物体边缘的高光会跟根据视角移动“晃动”现象。 左图是关闭了Specular AA的效果，右边是打开的，Specular Aliasing在左图运动时会更加明显。所以需要SMAA或Temproal AA这类对支持（ subpixel reconstruction AA）的后处理。不过这样就增加了对GPU的消耗。 ) 6）Alpha Test AABlackSmtih这Demo里抖动相当厉害。其中原因，一个是Unity默认的FXAA只有对几何体的锯齿有效果，对应像素的走样问题并不能很好的对应。下图中远处的场景抖动就非常厉害。 一般渲染植物都是使用贴图，然后用alpha test来作出植物的边缘，由于分辨率比较小，这种锯齿感在VR里也会被放大。 7）UI和互动的制作UI方面，U3D和UE4自带的3DUI在表现力上和Scaleform比还是有很大差距的。如果要制作出科技感强的界面，还是要手动定制一些功能。 8）调试和性能分析unity的分析主要是靠Profile，调试时需要拿下头戴设备，在Editor调整后，再用设备来确认。 UE4除了有分析工具外，还可以直接在游戏中使用命令行工具显示各种性能参数，以及各种显示特性的参数设置，更方便判断瓶颈。Unity还是需要自己在编辑器里设置，或者修改和扩展自己的设置插件。 8）性能问题为了不产生眩晕感和流畅，UE4建议在Rift DK2可以维持在75FPS，那么最低硬件配置也是GTX960。在我的GTX660上，UE4的VR专用演示大概是45FPS左右，其他的大概30FPS左右。这个一个和UE4本身的优化不足有关，另外也是UE4演示里还是使用了高品质材质和特效的缘故。UE4的性能和制作规格对Unity开发还是可以起到参考作用。 附录：最后是UE4自带的两个VR专用的演示，Showdown和CouchKnights的一些特性 场景的平均Draw Call为600 静态物体对象的多边形数50w70w，骨骼动画的多边形数全屏为30w50w左右 如果是VR的话，UE4的Draw Call都要翻倍，绘制的多边形数量自然也翻倍了。实现方式上，这点和Unity是不一样的。 静态场景大部分的静态场景，近处的房屋和地面等等都是标准PBR材质，有Roughness和Normal Map，远景的房屋没有使用Normal Map，地面使用了bump offset来模拟POM的效果。 配合Local Cubemap（UE4里叫ReflectionCapture）做出来地面上水洼的反射效果。 动态物体除了玩家外，场景里只有士兵和敌方Boss两种角色。面数为6w和10w面。一个角色都有7，8种材质。 光影场景没有使用任何动态光源，都是预先烘培的光照贴图（Lightmap）和Light Probe（UE4里叫Lightmass） 角色动态阴影只是一个脚底下的贴片来Fake的。 粒子特效车的爆炸特效，是在一个做了高细分（ tesselated ）的球体上加入了世界空间的噪声来实现 导弹的轨迹也细分几何体。沿着一个样条曲线来运动 转自：使用UE4进行VR制作的一些经验分析","categories":[{"name":"UE4","slug":"UE4","permalink":"http://blog.le-more.com/categories/UE4/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://blog.le-more.com/tags/总结/"},{"name":"vr","slug":"vr","permalink":"http://blog.le-more.com/tags/vr/"},{"name":"ue4","slug":"ue4","permalink":"http://blog.le-more.com/tags/ue4/"}]},{"title":"UE4开发VR项目，帧率优化实践","slug":"ue4/ue4-e5-bc-80-e5-8f-91","date":"2016-08-15T04:38:19.000Z","updated":"2019-11-08T09:59:31.038Z","comments":true,"path":"2016/08/15/ue4/ue4-e5-bc-80-e5-8f-91/","link":"","permalink":"http://blog.le-more.com/2016/08/15/ue4/ue4-e5-bc-80-e5-8f-91/","excerpt":"","text":"早就听闻VR游戏对流畅度和帧率要求比较苛刻，UE4的优化坑很深，加之我们项目偏重度体验，资源和功能量较多。所以优化就成了我工作中既头疼又占比很大的一块。 做过地编的小伙伴比较熟悉帧率优化，也知道这个过程多么乏味。一头是模型师辛苦做出来的精美模型，以及特效师那狂拽酷炫吊炸天的粒子，另一头是延迟上天。程序大爷甩脸子说看下你的GPU消耗，严重阻碍了功能流畅的装逼，制作人一脸便秘说优化下吧，不能愉快的玩了。这时你得压缩贴图降低模型面数，删减材质效果，减少灯光，减少粒子发射数量，关闭各种后期效果等等。。。得罪了一圈人好不容易不卡顿了，又有人来说，感觉效果不好，这时你可能会疯。 由于我们项目规划初期对VR体验设计，引擎功能，目标硬件环境都缺乏足够认知，贸然选择了一个探索题材的项目，这就意味着环境代入感要强，交互内容要足够丰富，玩家行为更不可控。先直观感受下氛围： 为了匹配硬件，我们的场景设计成了双人面对面的模式。左右下角的两列功能也说明了游戏中有丰富的互动和对应的资源表现，所以优化之前GTX980显卡VR模式下游戏帧率只有20多帧，卡顿非常严重。经过跟程序商讨，查阅了一些优化相关资料后，进行了以下一些操作来提高帧率。 一：准备好测试环境 1： 地图Build； 2：确保引擎中帧速最大值没有被限制，在工程设置—通用设置—帧率下； 3:配置好各项参数质量 4：打开VR模式后在编辑器中按~键调出控制台，输入r.ScreenPercentage，这个相当于画面分辨率，默认是100，你可以输入更高或更低的值，确定一个你觉得清晰度合适的数值，比如说120. 二：快速查找帧率瓶颈 准备好测试环境后，调出控制台，输入stat unit查看当前画面中的各项运算耗时数据； 三：查找具体是哪些因素导致的GPU消耗高 转到视野范围内按Ctral+shift+,调出GPU查看器 通过这里你可以查看具体是哪几块在占用渲染时间（红框内是渲染总时长），条越长的说明耗时越久。这个图上可以看出最消耗的是basepass，灯光和后期三大块（当然这里面不止这三块，每种颜色代表一块）。 1：basepass消耗高的话，就需要了解下哪些模型，贴图，材质开销太大。 面数过高的模型就减面；半透明用的多的物件就斟酌下是否必要；材质是GPU消耗过高的一大元凶，比较耗的材质可以检查下节点，关闭一些非必要的效果。材质复杂程度在这里可以查看，越红的越消耗，原则上减少使用点动画和曲面细分等一些效果。 另外，场景里摆放的模型如果不需要参与碰撞计算的话，最好关闭碰撞，减少运算消耗。 传统游戏的LOD做法在VR游戏里并不是必须的，因为很多VR游戏的活动范围很有限（设计上避免眩晕不要让玩家大范围位移），不需要由远及近的切换模型状态，并且设置不合理的话，在VR游戏里看到一个模型来回切换状态是非常明显的，比较影响体验。由于UE4对面数计算优化不错，所以建议活动区域较小的话模型做精，场景大的话中远景直接用低模。 游戏运行时在控制台里使用showflag（隐藏）命令可以帮我们快速定位具体是模型？特效？光照？等等哪个消耗高，消耗高的就优化，列举几个常用的showflag命令： showflag.Translucency showflag.ambientocclusion showflag.particles showflag.staticmeshes showflag.dynamicshadows showflag.decal 2：灯光消耗高的话，需要检查动态光照数量（固定光也可以投射动态光照），是否有过多重叠的照射区域，照射范围参数是否开的太大。由于静态光照Build后已将灯光信息存储进了Lightmap，游戏中不再计算，所以灯光的主要消耗来自动态光源。先在世界大纲里查看所有灯光类型，确定有几盏动态光和固定光，前面有红点的是动态，黄点的是固定。 再进一步查看固定光的照射范围的重叠部分是否太多，重叠的越多，交集处越亮越红。用灯的原则是能不用动态光就不用（消耗主要来自被投照射的Mesh），灯光照射范围尽量不重叠，且同一个地图里固定光不能超过4盏。 关闭灯光的投射动态阴影也可以降低一些消耗，甚至一些灯光可以直接关闭投射阴影功能。 3：后期处理是另一个GPU消耗过高的元凶，需要慎用，原则是尽可能的把一些不必要的参数关掉，尤其是SSR,后期AO，Bloom等。一些参数默认会自带一些数值，没必要的全部清零，抗锯齿模式切换成FXAA。 以上列举的三块只是常见的消耗较大的领域，当然还有其他一些需要优化的因素，例如雾效，反射球等，这里就不一一列举了。 优化完这几大块，帧率基本上会提高不少,看游戏实际情况优化工作可以告一段落。 当然，随着游戏内容的增加，优化工作需要持续进行。至此，相信你已经深深的感受到了VR游戏优化的苛刻，和UE4深似海的套路。 转自： [ue4]用UE4开发VR项目，帧率优化实践(上) [ue4]用UE4开发VR项目，帧率优化实践(下)","categories":[{"name":"UE4","slug":"UE4","permalink":"http://blog.le-more.com/categories/UE4/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://blog.le-more.com/tags/优化/"},{"name":"vr","slug":"vr","permalink":"http://blog.le-more.com/tags/vr/"},{"name":"ue4","slug":"ue4","permalink":"http://blog.le-more.com/tags/ue4/"}]},{"title":"数学入门书籍","slug":"math/e6-95-b0-e5-ad-a6","date":"2016-02-22T02:09:39.000Z","updated":"2019-11-08T09:59:30.987Z","comments":true,"path":"2016/02/22/math/e6-95-b0-e5-ad-a6/","link":"","permalink":"http://blog.le-more.com/2016/02/22/math/e6-95-b0-e5-ad-a6/","excerpt":"","text":"事件的本质很多都是数学的问题，特别在程序开发中。生活中也随处可见。因此学好数学，对工作和生活是大有裨益的。 转自：外行朋友值得一读的5本经典数学书 有很多人让我给外行朋友推荐一些优秀的数学书，他们之中有些是没在大学学过高等课程的，只对学习数学感兴趣的朋友，还有些对历史人物比对数学成果更感兴趣。具有讽刺意味的是，当你是滑铁卢大学数学专业的学生之后，你到第四年才有机会上一门讲述数学历史的课程，会向你解释一些隐藏在数学之后的心态和哲学，而非只是定理和证明。 这5本书是我推荐给那些想了解数学思想和原理的朋友。 1.《A History of Mathematics | 数学史》作者：Carl B. Boyer 这是大概十年以前我上过的数学史课程的教材，而这本书仍是最好，最为深入讨论过去几千年中数学发展的书之一。其由埃及和前古典数学开始，解释一个简单的任务是如何因为缺少数学工具而变得复杂，然后随着时间推移各种工具的开发使我们能够理解量子理论。这本书很厚，超过700页的内容（编注：中文精装版1108页），但是非技术型读者也完全可以毫无障碍的阅读。 这本书非常值得任何图书馆收藏，它也可以每章分开来读，每章覆盖了数学史的一个不同方面。 2.《Journeys Through Genius | 天才引导的历程：数学中的伟大定理》作者：William Dunham 很多年前我在一个二手店选了这本书，仅仅是因为它吸引了我的注意力，并且价格不错。我觉得它读起来会比较有意思，但是我从没想过因为其内容而惊讶和兴奋，直到我开始认真阅读。这本书拿了一些数学上最为重要和变化后的定理，并用简洁且易于接受的方法解释它们。 借助一种有趣且令人愉快的方式，把定理发展过程中的历史文物展示出来，在上下文中保持了发现在当时的重要性。此外，更加重要的是，在定理的解释之外，这些为众人所知的工作背后的人物和生活以及他们的各种工作一起带入到了文中。如果你想对数学上最伟大的定理了解更多，这本书很好读并值得你拥有。 3. 《The Mathematical Experience | 数学经验》作者 Philip J.Davis、Reuben Hersh 我的数学史课程教授把他的这本书的复印本借给我，而这本书或许是我读过的最开眼界的读物。我花费了整个周末来读这本书，从头至尾，然后又读了一遍，狼吞虎咽并吸收其中所有的思想和观点。 从讨论成为一个数学家意味着什么，和从由全世界数学家所分享的经验的视角，毫无疑问这是我书库中最好的书。从哲学到数学家的社会情感经验，这本书涵盖了数学的全部领域。这本书写的很好，简洁并且触动了我的心弦。在这本书中，我真的感觉到我正在读一个已经知道什么叫爱数学，并且因数学感到兴奋的人，而不用深入钻研那些原本的推导过程。如果在这整个列表中有那么一本我建议去立即买的书，那一定是这本。快去买吧！ 4. 《Proofs from the Book | 数学天书中的证明》作者：Martin Aigner、Günter M. Ziegler Paul Erdös是20世纪多产的数学家，他通常涉及到及其优美的证明，就如同从“从上帝自己的书中”中得到一样。 这本书是一些很多数学家认为必要和重要的证明的集合，同时也是优雅和漂亮的。 如果你想要一本读起来比较容易，但可以用原始的严密的方法探索其中的定理的书，那这本书一定适合你。它覆盖了十分宽泛的领域中，一些最好的证明。 5. 《Proofs and Refutations | 证明与反驳－数学发现的逻辑》作者：Imre Lakatos 这本书可能是本文介绍的最高端的书。它竟然出色地采用了教授和学生之间的讨论的形式来写。Lakatos将数学过程交织在一起，包括了数学如何真正完成和定理如何应用于各种各样的易于理解的技术。 如果你或者你所认识的任何人，真的考虑转入数学这一行，我会推荐他读这本书。这尤其包括教师，因为他解释了如何通过技术和哲学思想，帮助你全面理解和创造性地运用新学到的工具，使你前进。这真的是一本十分精彩，并且能很快读完的书。 转自：数学方面的入门书 个人推荐 从一到无穷大 绝对经典 1. 什么是数学 作者 : [美] R·柯朗 H·罗宾 著/I·斯图尔特修订 复旦大学出版社 评语 : 数学专业众人推荐 2. 古今数学思想 作者: [美] 莫里斯?克莱因 译者: 张理京 / 张锦炎 / 江泽涵 上海科学技术出版社 评语：Chievo（数学专业）：是一本讲数学史的书；个人认为它是给数学专业的人的人看的 十九世纪以前的部分比较简单，但是这一部分的数学太过古老，学了实在没有什么用处（对数学专业的想了解数学的发展倒是很有用的）；十九世纪以后的部分难度就比较大了，还是不太适合。 3. 数学——它的内容、方法和意义 作者: А.Д.亚历山大洛夫 译者: 孙小礼 / 赵孟养 / 裘光明 / 严士健 科学出版社 评语：Chievo（数学专业）推荐：第一章确实有一部分是这样内容，往后看会越来越少的，起那些东西总共也没即几段话，跳过就行了。至于难度，我觉得高中毕业的理科生应该没什么问题。 4. 从一到无穷大 作者 : [美] G. 伽莫夫 出版社 : 科学出版社 评语 : 数学入门推荐 5. 统计学的世界（第五版） 作者 : David S. Moore/William I. Notz 中信出版社 评语 : lang推荐：统计学入门 6. 女士品茶：20世纪统计怎样变革了科学 作者 : 萨尔斯伯格 (SalsburgDavid) 中国统计出版社 评语 : 统计学史的入门，凌凌期推荐：没有过多专业的知识，更多的是科普介绍，统计学的哲学思想。很好的一本书，我上《概率论》时，老师推荐的。 7. 如何求解问题：现代启发式方法 作者 : Zbigniew Michalewicz/David B.Fogel 中国水利水电出版社 评语 : Ren（演化计算）推荐：很适合入门 8. 初等数论 作者：潘承洞,潘承彪 北京大学出版社 评语：凌凌期推荐：如果你喜欢数论，就学学这本书吧，比较系统。当然可以只接触趣味数论的书，那也有很多。 9. 离散数学及其应用 作者 : （美）罗森 著，袁崇义 等译 机械工业出版社 评语 : obtuseSword推荐：深入浅出，仅需要高中知识，我就是高中开始学的，数学从不及格升到了班级第一，主要是这本书能让人学会数学思维，以及引起对数学的兴趣。 10. 博弈论基础 作者 : 高峰 罗伯特·吉本斯 中国社会科学出版社 评语 : einheriar推荐：推荐一本博弈论的吧：罗伯特.吉本斯的《博弈论基础》。一个小绿皮册子，比较好读，对数学要求不高^^如果看完不过瘾的话，推荐Tirole的那本《博弈论》，不过这个应该超标了吧…… 11. 具体数学 作者: [美] Ronald L. Graham / Donald E. Knuth / Oren Patashnik 机械工业出版社 评语：RomanGol（计算机数学）推荐：不讲太多的计算机知识但是里面的思想都是不朽的。 12. 哥德尔、艾舍尔、巴赫–集异璧之大成 作者: [美] 侯世达；译者: 郭维德 等 出版社: 商务印书馆 评语：RomanGol（计算机数学）推荐：不讲太多的计算机知识但是里面的思想都是不朽的。 13. 微积分 作者: [美]D.休斯.哈雷特,A.M.克莱逊 译者: 胡乃冏 邵勇 徐可 马志鹏 徐刚 高等教育出版社 eeswah（微积分）推荐：太经典了，门槛真的很低，但是看完后数学思维和能力提高真的很大，神书啊。 14. 数学分析 作者: [美]Tom M. Apostol 译者: 邢富冲 / 邢辰 / 李松洁 / 贾婉丽 机械工业出版社 评语：推华东师范大学编的那本，蓝皮，高教出版社出版。 15. 历届CMO中国数学奥林匹克试题集1986-2009 作者 : 刘北兴 哈尔滨工业大学出版社 评语 : 王世强（材料成型及控制工程）推荐","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]},{"title":"不为应试,这12本经典好书只为激发孩子的数学学习兴趣","slug":"math/e4-b8-8d-e4-b8-ba","date":"2016-01-06T04:14:42.000Z","updated":"2019-11-08T09:59:30.986Z","comments":true,"path":"2016/01/06/math/e4-b8-8d-e4-b8-ba/","link":"","permalink":"http://blog.le-more.com/2016/01/06/math/e4-b8-8d-e4-b8-ba/","excerpt":"","text":"数学其实是非常生动有趣、生活中随处可见的学科，而不只是我们印象中的加减乘除。《原来数学才是最文艺的学科，太美了》曾感染了万千家长和教育工作者。但是在中国传统的考试的压力下，一些原本有着数学天赋或兴趣的孩子，对数学爱恨交加。今天，少年商学院教研部精选了一共12本数学主题经典好书与您分享。清一色由各国数学大家出品，除个别标注外适合亲子共读外，均适合10岁以上学生阅读。 12本书共分为游戏、漫画等5个大类，虽然有几本是关于数学技巧，但更多是一种数学思维和数学素养的培育。让孩子重燃对数学的兴趣与好奇心，以及积极探索、用数学思维发现问题和解决问题能力的提升。 9月开始的新学年新学期，少年商学院线上线下结合的《小小数学家》系列课程，包含《数字的魔力》、《图形的奥秘》和《数学改变生活》三门课，由全美排名第一教育学院的数学教育学博士任教。全国任何城市9-12岁少年均可报名。点击此处了解详情；购买系列课程将获得从以下书目当中精选的美式素质教育数学好书一套。 一、数学游戏 ▋1、《让你爱上数学的50个游戏》：掷骰子、打篮球…… 少年商学院教研总监、毕业于加州大学伯克利分校统计系的Evan老师曾在少商国际教育公开课上，提到他的数学启蒙，其实是从父亲的彩票和扑克牌那里开始的（点击阅读《如何才能真正学好数学？全球最TOP统计系毕业生的秘诀》）。 本书作者罗纳德·古尔德是纽约国立大学计算机科学硕士、西密歇根大学数学博士，同样在书里汇集了多种多样的游戏、体育项目，如大转盘、掷骰子、21点，和橄榄球、棒球、篮球等，引导小读者们从中一步一步认识概率和与之相关的数学理论。 ▋2、《孩子天生会数学》：家长要为孩子的数学负一半的责 温馨提示：孩子2岁半后即可读，建议亲子共读 “很多孩子不擅长数学的最重要原因，不是他们天生不擅长，而是父母或老师没有创造一个良好的数学环境。”华盛顿大学教育心理学博士格雷格·纳尔逊教授，过去一直在研究学前教育和小学教育，还担任过西雅图蒙台梭利幼儿园的教师，他把自己的研究心得注入到这本书里，归纳了86个好玩的数学游戏，希望和家长联手，打造快乐学数学的家庭氛围。 放眼全球，孩子接触数学的年龄基本是从2岁半开始，但大多数家长走入了一个误区，就是直接把孩子拉进了一个学术的、正规但就是板着一张脸的数学教育中，从游戏中激发孩子的数学思维，就是想打破数学在孩子心中可能已经形成了的刻板印象。通过参与和动手，给孩子一个数学头脑。 二、数学漫画 ▋3、《神奇的数字世界》：漫画呈现“数字心理学” 漫画+文字——本书对看久文字就头疼但又想探索数学的同学来讲，绝对是福音。它的作者是日本著名插画艺术家寄藤文平，之前曾凭《大便书》称霸畅销书榜单，本书延续了一贯风趣的文字、蠢萌的“小黄人”和各类日本流行元素，还创新地提出了“数字心理学”的概念——原来我们日常生活中处处都被数字左右着。 书里有个经典的案例是讲人一生心跳约30亿次，如果要数心跳次数，数着数着，你的速度就会跟不上心跳频率。换句话说，即使你一生都在数数，也数不到30亿次。估计有不少读者看到之后都默默学着数了好半天吧，反正学院君是真的傻傻地跟着做了…… ▋4、《数学女孩》：披着日系漫画小说的外衣 温馨提示：适合对数学感兴趣的初高中生阅读。 让数学科普读物变成日系动漫小说，结城浩——一个日本资深码农真的做到了，还靠这本书赢得了日本数学会的出版奖！小说表面上是描述一群校园少年探寻数学之美的故事，实际上是一本由浅入深的数学科普书。 故事情节虽然褒贬不一，但能把大学甚至研究生级别的知识深入浅出地讲给中小学生，已经非常不容易，特别是梳理各种精妙的花式证明简直能让人惊呆！ 三、跨界神作 ▋5、《爱与数学》：不想当导演的数学家不是好诗人 知道这本书，还是因为一次无意间看了一部数学主题短片——《爱与数学的仪式》，讲了一个美艳女子和数学家寻找“一个可以算出永恒爱情定律的公式”的故事（虽然浪漫但尺度较大，不太建议小同学们看），而片子的导演爱德华?弗伦克尔竟然是加州大学伯克利分校的一名数学系教授！拍电影来和数学“谈恋爱”，有意思。 爱德华教授的数学造诣非常高，他的“朗兰兹纲领研究”世界巡回演视频在youtube网站上的点击率超过百万次，个人传记——《爱与数学》也成了不少数学爱好者的必读书。这本书秉持了他一贯的“数学是生活的诗”这一理念，书中有个故事是，他和妈妈一起做罗宋汤，把所有的配方成分列出来，用数学建模确立食材的对应关系，可以让不同食材的量保持平衡，或者产生某种奇妙的口味，这真是梦想厨房啊。 全书他都在用通俗易懂的语言告诉我们，数学的神秘世界并非遥不可及，“很多人不知道2/3与3/5相比哪个数字比较大，但是如果你问一个爱喝酒的人，3个人喝2瓶伏特加和5个人喝3瓶伏特加相比，他选哪种？那么，你得到的答案肯定是3个人喝2瓶伏特加。”类似的例子很多，对于中小学阶段的孩子习得数学思维方式，更好地了解这个世界，很有帮助。 ▋6、《生活中的魔法数学》：好莱坞魔术师的数字诀窍 全球销量突破500万册，美国青少年人手一册，美国教育部与数学协会指定青少年必读优秀图书之一……这本书的作者亚瑟·本杰明的履历也超有意思，他不仅是2000年就被美国数学协会授予“海默奖”的数学大神，还是一位经常在好莱坞著名魔术俱乐部“魔法城”表演的专业魔术大师。 亚瑟在书里和小读者们分享了闪电般快速心算的秘密和令人惊异的数字诀窍，能让数字记忆能力大幅提高。他想提醒我们，看似非常复杂的运算，其实普通人经过训练也能轻松做到。更适合对数字记忆有兴趣的同学，数学思维的培养，本书涉及比较少。 四、数学生活 ▋7、《X的奇幻之旅》：连文科生都爱读的大家之作 真正的大家都极擅长深入浅出。康奈尔大学应用数学系名誉教授史蒂夫·斯托加茨，作为世界上观点被引用最多的数学家之一，所写的数学书，却连文科生都爱不释手：辛普森到底有没有谋杀他的前妻？多长时间、以何种方式翻转你的床垫才会让它的磨损率最小？在步入婚姻殿堂之前，你应该和多少位异性约会？……这本书里大部分都在回答这类问题。 斑马身上的黑白条纹中的正弦波；美国《独立宣言》中欧几里得几何定理的身影；流星雨划过夜空时留下的美丽抛物线；罗密欧和朱丽叶爱情悲剧背后的微积分方程式；拆穿小布什减税计划谎言的长尾分布……这本书里所关注的，无不围绕着“数学可以带我们重新发现生活之美”这个核心，可以说，即使是“数学零基础”的读者读起这本书来也丝毫不会觉得费劲。 ▋8、《数学与生活》：为改革数学教育而生 “我们的数学应试教育模式正给学生带来空前的恐惧感，”为了推动日本数学教育改革，日本数学教育协会创立者、日本当代著名数学教育家远山启，写了这本书，直言要还原被考试扭曲了的数学。 出版背景听起来挺吓人的，这本书却是一本挺人性化的数学入门书籍的——毕竟说了要打破学生的数学恐惧，而且书里不少例子都是横跨了各种学科。读过一点就能看出作者的数学造诣非常深厚，才能做到这么深入浅出。 五、还原数学 ▋9、《度量丨一首献给数学的情歌》：不当高校教授，只当小学老师的真大师之作 有朋友说，要是他在高中时就能遇到这本书和这位作者，大学时他就会选数学专业，乍一听蛮夸张，但阅读后真的就是这种心情。 这是一个很好的几何学和微积分的替代教程，作者保罗·洛克哈特曾写《一个数学家的叹息》，在2002年一篇曾引发热议的文章中，猛烈抨击美国中小学数学教育只要求学生记住公式，并在练习题中反复套用的方式，在数学界引发巨大反响，后来，他就写了这本书，重申： 数学是一门艺术，而老师教授数学的方法应该是，向学生诚实地传递自己对于这门学科的热爱，激发和激励他们与生俱来的好奇心，并帮助和引导他们实际投身到这段迷人的旅途中去。 保罗的个人经历也非常有意思，14岁时就对数学产生兴趣——不过他后来反复强调，这种兴趣绝对不是来自学校的数学课程，而仰赖于他在数学相关领域的大量阅读。他也没有完成大学学位，才去了一个学期，就退学专心研究数学去了。 不过这位真学霸后来还是和一位数学家合作发表了N多论文，成了加州大学洛杉矶分校的研究生，后来又去布朗大学等高校任职了一些年份，又待不住，跑去纽约一家小学任教至今。 ▋10、《数学的故事》：从文化的角度看它的成长 从文化的角度解读数学，会产生怎样奇妙的化学反应？毕业于牛津大学的理查德·曼凯维奇教授对此一直极感兴趣，按他的话说，“我们需要让孩子们知道，数学家有多伟大。” 因此，在这本书里，作者从历史、传记及大众科学的角度，讲述了一个精彩的数学发展故事。数学是怎样发展起来的，又是出自何种原因发展的？在人类社会的发展和变革中，数学产生了哪些影响？我们对宇宙的认识又是如何依靠数学实现的？书里的图片都很精美，用纸也不错，拿在手里，真能感觉到一种沉甸甸的历史感。 ▋11、《玩不够的数学丨算术与几何的乐趣》：还原数学的本来面貌 数学也可以既没有复杂公式也没有严密推理——这是法国数学家、计算机科学家让·保罗·德拉耶教授想在这本书里重申的。正如书名所写，书中围绕一系列算式和几何的玩法展开，带领孩子们了解广义上的数学世界，“还原数学的本来样貌”。 ▋12、《让头脑变聪明的印度数学》：比一般方法快15倍 全球销量突破5百万册；美国、英国、日本、韩国等国家教育部门指定的青少年必读图书之一……作者是享誉全球的印度学者巴拉蒂·克里希纳·第勒塔季，在他的研究中，数学是依据16个经文构成的，上世纪60年代，他把这套数学计算体系介绍到英国，被称为“吠陀数学”。 吠陀数学比一般的计算方法快10-15倍，理解了吠陀数学法则后，还能创造出自己的解题方法，运用在现代数学——代数、几何、三角函数、微积分等科目中。适合数学基本功扎实，数学思维比较活跃的孩子，如果孩子本身在计算方面不太好，建议还是先多做一些口算题，不然可能会弄混。 最后，学院君要引用数学家华罗庚的一句话，与喜欢数学和同学，或是善于激发孩子数学思维的家长和老师们共勉。点击这里或左下“阅读原文”查看2016秋季少年商学院美式素质教育《小小数学家》系列课程，在线直播+线下实践。 这不失为家长送给孩子的一份关于理科思维启蒙的特殊礼物，适合9到12岁小学生。 宇宙之大，粒子之微，地球之变，生物之谜，日用之繁，无处不用数学。 ——华罗庚 转自：不为应试,这12本经典好书只为激发孩子的数学学习兴趣","categories":[{"name":"Math","slug":"Math","permalink":"http://blog.le-more.com/categories/Math/"}],"tags":[]}]}