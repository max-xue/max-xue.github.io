<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Le-More</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.le-more.com/"/>
  <updated>2019-11-09T02:38:23.520Z</updated>
  <id>http://blog.le-more.com/</id>
  
  <author>
    <name>max-xue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.Net 4.x Equivalent语法糖</title>
    <link href="http://blog.le-more.com/2019/11/09/u3d/csharp_4x_candy/"/>
    <id>http://blog.le-more.com/2019/11/09/u3d/csharp_4x_candy/</id>
    <published>2019-11-09T02:18:11.000Z</published>
    <updated>2019-11-09T02:38:23.520Z</updated>
    
    <content type="html"><![CDATA[<p>Unity2017的Scripting Runtime Version支持.net 4.6。<br>运行时的提升随之带来了新的语法糖。下边介绍主要常见的几种。</p><p>1 Null条件运算符</p><pre><code>// 原写法var str = &quot;string&quot;;if (config != null){    str = config.Value;}// 新写法var str = config?.Value;if (str == null){    str = &quot;string&quot;;}// 结合??写法var str = config?.Value ?? &quot;string&quot;;</code></pre><p>2 索引初始化</p><pre><code>// 原写法var dic = new Dictionary&lt;string, int&gt;(){    {&quot;a&quot;, 1},    {&quot;b&quot;, 1},    {&quot;c&quot;, 1},};// 新写法var dic = new Dictionary&lt;string, int&gt;(){    [&quot;a&quot;] = 1,    [&quot;b&quot;] = 2,};// 还可用于List。虽然大部分情况下都没有意义var list = new List&lt;int&gt;(){    10,    20,    30,    40};var list = new List&lt;int&gt;(){    [0] = 10,    [1] = 10,    [2] = 10,    [3] = 10,};</code></pre><p>3 nameof表达式</p><pre><code>public class ClassName {     public string StringValue;}var className = nameof(ClassName); // 返回ClassNamevar fieldName = nameof(ClassName.StringValue); // 返回StringValue</code></pre><p>4 字符串格式化</p><pre><code>// 原写法var str = string.Format(&quot;{0} : {1}&quot;, value1, value2);// 新写法var str = $&quot;{value1} : {value2}&quot;;</code></pre><p> <a href="https://blog.csdn.net/oyji1992/article/details/74188660" target="_blank" rel="noopener">转载自:Unity2017新语法糖</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Unity2017的Scripting Runtime Version支持.net 4.6。&lt;br&gt;运行时的提升随之带来了新的语法糖。下边介绍主要常见的几种。&lt;/p&gt;
&lt;p&gt;1 Null条件运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原写法
var str = &amp;quot;
      
    
    </summary>
    
      <category term="U3D" scheme="http://blog.le-more.com/categories/U3D/"/>
    
    
  </entry>
  
  <entry>
    <title>Cocos Creator 开发问题汇总</title>
    <link href="http://blog.le-more.com/2019/10/25/cocos/cocos_dev_summary/"/>
    <id>http://blog.le-more.com/2019/10/25/cocos/cocos_dev_summary/</id>
    <published>2019-10-25T08:31:13.000Z</published>
    <updated>2019-11-08T09:59:30.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结开发中遇到的问题"><a href="#总结开发中遇到的问题" class="headerlink" title="总结开发中遇到的问题"></a>总结开发中遇到的问题</h2><p>1.Manifest merger failed with multiple errors, see logs<br>在Android Studios 命令中执行（追踪错误详情）:</p><pre><code>./gradlew processDebugManifest --stacktrace</code></pre><p>2.Android Apk ICON尺寸  </p><table><thead><tr><th>密度</th><th>尺寸</th></tr></thead><tbody><tr><td>mipmap-mdpi</td><td>48 * 48</td></tr><tr><td>mipmap-hdpi</td><td>72 * 72</td></tr><tr><td>mipmap-mdpi</td><td>48 * 48</td></tr><tr><td>mipmap-xhdpi</td><td>96 * 96</td></tr><tr><td>mipmap-xxhdpi</td><td>144 * 144</td></tr><tr><td>mipmap-xxxhdpi</td><td>192 * 192</td></tr></tbody></table><p>3.Cocos Creator插件，查看运行场景中节点<br>  <a href="https://github.com/tidys/CocosCreatorPlugins" target="_blank" rel="noopener">ccInspector_v1.1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结开发中遇到的问题&quot;&gt;&lt;a href=&quot;#总结开发中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;总结开发中遇到的问题&quot;&gt;&lt;/a&gt;总结开发中遇到的问题&lt;/h2&gt;&lt;p&gt;1.Manifest merger failed with multiple
      
    
    </summary>
    
      <category term="Cocos" scheme="http://blog.le-more.com/categories/Cocos/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 破解APK包</title>
    <link href="http://blog.le-more.com/2019/10/24/cocos/apk_unpacking/"/>
    <id>http://blog.le-more.com/2019/10/24/cocos/apk_unpacking/</id>
    <published>2019-10-24T12:10:00.000Z</published>
    <updated>2019-11-08T09:59:30.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APK-解包"><a href="#APK-解包" class="headerlink" title="APK 解包"></a>APK 解包</h2><p>1.准备工具软件</p><ul><li>apktool 解压APK</li><li>dex2jar class 转为Jar</li><li>jd-gui: 查看Jar代码</li></ul><p>2.解压指定APK   </p><pre><code>apktool d target.apk </code></pre><p>3.将classes.dex打包成jar包</p><pre><code>d2j-dex2jar.bat classes.dex </code></pre><p>4.使用jd-gui查看Jar  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;APK-解包&quot;&gt;&lt;a href=&quot;#APK-解包&quot; class=&quot;headerlink&quot; title=&quot;APK 解包&quot;&gt;&lt;/a&gt;APK 解包&lt;/h2&gt;&lt;p&gt;1.准备工具软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apktool 解压APK&lt;/li&gt;
&lt;li&gt;dex2jar c
      
    
    </summary>
    
      <category term="Cocos" scheme="http://blog.le-more.com/categories/Cocos/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建网站个人总结</title>
    <link href="http://blog.le-more.com/2019/10/11/top/0001_hexo_guide/"/>
    <id>http://blog.le-more.com/2019/10/11/top/0001_hexo_guide/</id>
    <published>2019-10-11T03:58:48.000Z</published>
    <updated>2019-11-08T13:45:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Hexo搭建网站个人总结"><a href="#使用Hexo搭建网站个人总结" class="headerlink" title="使用Hexo搭建网站个人总结"></a>使用Hexo搭建网站个人总结</h2><p>1.安装环境 </p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Git</a>  </li><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a><br>(因平时开发环境用这两个环境，安装过程省略)</li></ul><p>2.<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">安装Hexo</a></p><pre><code>$:npm install -g hexo-cli</code></pre><p>3.创建Web项目<br>创建一个空的文件夹MyWeb，右键打开Git Bash Here(成功安装Git后，右键菜单有这个选项)</p><pre><code>$ hexo init MyWeb$ cd MyWeb$ npm install</code></pre><p>执行后目录如下：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>安装其他依赖(根据需要) </p><pre><code>$ npm install hexo-wordcount --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-category --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-index --save$ npm install hexo-generator-json-content --save$ npm install hexo-generator-search --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-tag --save$ npm install hexo-generator-topindex --save$ npm install hexo-renderer-ejs --save$ npm install hexo-renderer-marked --save$ npm install hexo-renderer-stylus --save$ npm install hexo-server --save$ npm install hexo-wordcount --save</code></pre><p>4.<a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank" rel="noopener">复制主题</a></p><p>以我使用的3-Hexo为例</p><pre><code>git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre><p>5.配置主题</p><p>修改MyWeb根目录下文件_config.yml，如下</p><pre><code>theme: 3-hexo</code></pre><p><a href="https://yelog.org/2017/03/23/3-hexo-instruction/" target="_blank" rel="noopener">3-hexo主题详细配置参考</a></p><p>6.创建页面</p><pre><code>hexo new page --path other/0001_hexo_guide</code></pre><p><a href="https://www.runoob.com/markdown/md-link.html" target="_blank" rel="noopener">编写内容参考Markdown语法</a></p><p>7.生成预览</p><pre><code>$hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>打开<a href="http://localhost:4000可预览效果" target="_blank" rel="noopener">http://localhost:4000可预览效果</a></p><p> 8.发布到Git<br> <a href="https://pages.github.com/" target="_blank" rel="noopener">使用Github创建项目</a>,因很久以前就创建过，过程略,<a href="https://github.com/max-xue/max-xue.github.io" target="_blank" rel="noopener">我的地址</a></p><p> 修改MyWeb根目录下文件_config.yml，如下</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/max-xue/max-xue.github.io  branch: master  message: &quot;Site updateed: {{ now('YYYY-MM-DD HH:mm:ss') }}&quot;</code></pre><p>执行</p><pre><code>$hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Hexo搭建网站个人总结&quot;&gt;&lt;a href=&quot;#使用Hexo搭建网站个人总结&quot; class=&quot;headerlink&quot; title=&quot;使用Hexo搭建网站个人总结&quot;&gt;&lt;/a&gt;使用Hexo搭建网站个人总结&lt;/h2&gt;&lt;p&gt;1.安装环境 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.le-more.com/tags/hexo/"/>
    
      <category term="guide" scheme="http://blog.le-more.com/tags/guide/"/>
    
  </entry>
  
  <entry>
    <title>新的家园</title>
    <link href="http://blog.le-more.com/2019/10/11/top/0002_new_home/"/>
    <id>http://blog.le-more.com/2019/10/11/top/0002_new_home/</id>
    <published>2019-10-11T03:54:03.000Z</published>
    <updated>2019-11-09T03:13:40.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="又是一个新的开始"><a href="#又是一个新的开始" class="headerlink" title="又是一个新的开始"></a>又是一个新的开始</h2><p>总想在网上给自己找一个家，能随意留下自己的印迹，</p><p>于是经历CSDN（各种受限制和讨厌的广告）</p><p>愤而租服务器，备域名，搭Wordpress（但又有各种成本）</p><p>转而发现 Github Pages就能给自己一个安静而又自由的空间（关键是免费）</p><p>从此以后这里就是我的新家了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;又是一个新的开始&quot;&gt;&lt;a href=&quot;#又是一个新的开始&quot; class=&quot;headerlink&quot; title=&quot;又是一个新的开始&quot;&gt;&lt;/a&gt;又是一个新的开始&lt;/h2&gt;&lt;p&gt;总想在网上给自己找一个家，能随意留下自己的印迹，&lt;/p&gt;
&lt;p&gt;于是经历CSDN（各种受限制
      
    
    </summary>
    
    
      <category term="mylife" scheme="http://blog.le-more.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>Cocos Creator 打包OBB</title>
    <link href="http://blog.le-more.com/2019/09/23/cocos/cocos-creator-e6-89-85obb/"/>
    <id>http://blog.le-more.com/2019/09/23/cocos/cocos-creator-e6-89-85obb/</id>
    <published>2019-09-23T13:29:52.000Z</published>
    <updated>2019-11-09T03:00:59.217Z</updated>
    
    <content type="html"><![CDATA[<p>1.app/build.gradle,打包APK排除资源，注释复制资源</p><pre><code>variant.mergeAssets.doLast {//        copy {//           from &quot;${buildDir}/../../../../../res&quot;//           into &quot;${buildDir}/intermediates/assets/${variant.dirName}/res&quot;////            exclude &quot;**/resources/gb/res/audio_down&quot;//        }</code></pre><p>2.build 生成apk</p><p>3.生成OBB</p><pre><code>jsb-link   \- res   \- src   \- main   \- project</code></pre><p>script目录:C:\CocosCreator\resources\cocos2d-x\cocos\scripting\js-bindings\script </p><p>4.压缩成zip,改成obb</p><p>5.安装测试：</p><pre><code>C:\\Users\\xuegang-pc\\AppData\\Local\\Android\\Sdk\\platform-tools&gt;adb shell cd storage/emulated/0/Android/obb mkdir com.maxx.test adb push d:\\main.1.com.maxx.test.obb /storage/emulated/0/Android/obb/com.maxx.test</code></pre><ul><li>先安装APK </li><li>在手机U盘中创建Android/obb/com.maxx.test 目录,复制main.1.com.maxx.test.obb文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.app/build.gradle,打包APK排除资源，注释复制资源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variant.mergeAssets.doLast {
//        copy {
//           from &amp;quot;${buildDir}/../.
      
    
    </summary>
    
      <category term="Cocos" scheme="http://blog.le-more.com/categories/Cocos/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity优化汇总</title>
    <link href="http://blog.le-more.com/2019/07/20/u3d/unity-e4-bc-98-e5-8c-96-e6/"/>
    <id>http://blog.le-more.com/2019/07/20/u3d/unity-e4-bc-98-e5-8c-96-e6/</id>
    <published>2019-07-20T13:51:54.000Z</published>
    <updated>2019-11-08T09:59:31.017Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最简单的优化建议：</strong></p><p>1.PC平台的话保持场景中显示的顶点数少于200K~3M，移动设备的话少于10W，一切取决于你的目标GPU与CPU。</p><p>2.如果你用U3D自带的SHADER，在表现不差的情况下选择Mobile或Unlit目录下的。它们更高效。</p><p>3.尽可能共用材质。</p><p>4.将不需要移动的物体设为Static，让引擎可以进行其批处理。</p><p>5.尽可能不用灯光。</p><p>6.动态灯光更加不要了。</p><p>7.尝试用压缩贴图格式，或用16位代替32位。</p><p>8.如果不需要别用雾效(fog)</p><p>9.尝试用OcclusionCulling,在房间过道多遮挡物体多的场景非常有用。若不当反而会增加负担。</p><p>10.用天空盒去“褪去”远处的物体。</p><p>11.shader中用贴图混合的方式去代替多重通道计算。</p><p>12.shader中注意float/half/fixed的使用。</p><p>13.shader中不要用复杂的计算pow,sin,cos,tan,log等。</p><p>14.shader中越少Fragment越好。</p><p>15.注意是否有多余的动画脚本，模型自动导入到U3D会有动画脚本，大量的话会严重影响消耗CPU计算。</p><p>16.注意碰撞体的碰撞层，不必要的碰撞检测请舍去。</p><p><strong>1.为什么需要针对CPU（中央处理器）与GPU（图形处理器）优化？</strong></p><p>CPU和GPU都有各自的计算和传输瓶颈，不同的CPU或GPU他们的性能都不一样，所以你的游戏需要为你目标用户的CPU与GPU能力进行针对开发。</p><p><strong>2.CPU与GPU的限制</strong></p><p>GPU一般具有填充率(Fillrate)和内存带宽(Memory Bandwidth)的限制，如果你的游戏在低质量表现的情况下会快很多，那么，你很可能需要限制你在GPU的填充率。</p><p>CPU一般被所需要渲染物体的个数限制，CPU给GPU发送渲染物体命令叫做DrawCalls。一般来说DrawCalls数量是需要控制的，在能表现效果的前提下越少越好。通常来说，电脑平台上DrawCalls几千个之内，移动平台上DrawCalls几百个之内。这样就差不多了。当然以上并不是绝对的，仅作一个参考。</p><p>往往渲染(Rendering)并不是一个问题，无论是在GPU和CPU上。很可能是你的脚本代码效率的问题，用Profiler查看下。</p><p>关于Profiler介绍：<a href="http://docs.unity3d.com/Documentation/Manual/Profiler.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/Profiler.html</a></p><p>需要注意的是:</p><p>在GPU中显示的RenderTexture.SetActive()占用率很高，是因为你同时打开了编辑窗口的原因，而不是U3D的BUG。</p><p><strong>3.关于顶点数量和顶点计算</strong></p><p>CPU和GPU对顶点的计算处理都很多。GPU中渲染的顶点数取决于GPU性能和SHADER的复杂程度，一般来说，每帧之内，在PC上几百万顶点内，在移动平台上不超过10万顶点。</p><p>CPU中的计算主要是在蒙皮骨骼计算，布料模拟，顶点动画，粒子模拟等。GPU则在各种顶点变换、光照、贴图混合等。</p><p>【个人认为，具体还是看各位的项目需求，假设你项目的是3D游戏。你游戏需要兼容低配置的硬件、流畅运行、控制硬件发热的话，还要达到一定效果（LIGHTMAP+雾效），那么顶点数必定不能高。此时同屏2W顶点我认为是个比较合适的数目，DRAWCALL最好低于70。另，控制发热请控制最高上限的帧率，流畅的话，帧率其实不需要太高的。】</p><p><strong>4.针对CPU的优化——减少DRAW CALL 的数量</strong></p><p>为了渲染物体到显示器上，CPU需要做一些工作,如区分哪个东西需要渲染、区分开物体是否受光照影响、使用哪个SHADER并且为SHADER传参、发送绘图命令告诉显示驱动，然后发送命令告诉显卡删除等这些。</p><p>假设你有一个上千三角面的模型却用上千个三角型模型来代替，在GPU上花费是差不多的，但是在CPU上则是极其不一样，消耗会大很多很多。为了让CPU更少的工作，需要减少可见物的数目：</p><p>a.合并相近的模型，手动在模型编辑器中合并或者使用UNITY的Draw call批处理达到相同效果(Draw call batching)。具体方法和注意事项查看以下链接：</p><p>Draw call batching : <a href="http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html</a></p><p>b.在项目中使用更少的材质(material)，将几个分开的贴图合成一个较大的图集等方式处理。</p><p>如果你需要通过脚本来控制单个材质属性，需要注意改变Renderer.material将会造成一份材质的拷贝。因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。</p><p>有一个合并模型材质不错的插件叫Mesh Baker，大家可以考虑试下。</p><p>c.尽量少用一些渲染步骤，例如reflections,shadows,per-pixel light 等。</p><p>d.Draw call batching的合并物体，会使每个物体（合并后的物体）至少有几百个三角面。</p><p>假设合并的两个物体（手动合并）但不共享材质，不会有性能表现上的提升。多材质的物体相当于两个物体不用一个贴图。所以，为了提升CPU的性能，你应该确保这些物体使用同样的贴图。</p><p>另外，用灯光将会取消(break)引擎的DRAW CALL BATCH，至于为什么，查看以下：</p><p>Forward Rendering Path Details:</p><p><a href="http://docs.unity3d.com/Documentation/Components/RenderTech-ForwardRendering.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Components/RenderTech-ForwardRendering.html</a></p><p>e.使用相关剔除数量直接减少Draw Call数量，下文有相关提及。</p><p><strong>5.优化几何模型</strong></p><p>最基本的两个优化准则：</p><p>a.不要有不必要的三角面。</p><p>b.UV贴图中的接缝和硬边越少越好。</p><p>需要注意的是，图形硬件需要处理顶点数并跟硬件报告说的并不一样。不是硬件说能渲染几个点就是几个点。模型处理应用通展示的是几何顶点数量。例如，一个由一些不同顶点构成的模型。在显卡中，一些集合顶点将会被分离(split)成两个或者更多逻辑顶点用作渲染。如果有法线、UV坐标、顶点色的话，这个顶点必须会被分离。所以在游戏中处理的实际数量显然要多很多。</p><p><strong>6.关于光照</strong></p><p>若不用光肯定是最快的。移动端优化可以采用用光照贴图(Lightmapping)去烘培一个静态的贴图，以代替每次的光照计算，在U3D中只需要非常短的时间则能生成。这个方法能大大提高效率，而且有着更好的表现效果（平滑过渡处理，还有附加阴影等）。</p><p>在移动设备上和低端电脑上尽量不要在场景中用真光，用光照贴图。这个方法大大节省了CPU和GPU的计算，CPU得到了更少的DRAWCALL，GPU则需要更少顶点处理和像素栅格化。</p><p>Lightmapping : <a href="http://docs.unity3d.com/Documentation/Manual/Lightmapping.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/Lightmapping.html</a></p><p><strong>7.对GPU的优化——图片压缩和多重纹理格式</strong></p><p>Compressed Textures（图片压缩):</p><p><a href="http://docs.unity3d.com/Documentation/Components/class-Texture2D.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Components/class-Texture2D.html</a></p><p>图片压缩将降低你的图片大小（更快地加载更小的内存跨度(footprint)），而且大大提高渲染表现。压缩贴图比起未压缩的32位RGBA贴图占用内存带宽少得多。</p><p>之前U3D会议还听说过一个优化，贴图尽量都用一个大小的格式（512 * 512 ， 1024 * 1024），这样在内存之中能得到更好的排序，而不会有内存之间空隙。这个是否真假没得到过测试。</p><p>MIPMAPS（多重纹理格式）：</p><p><a href="http://docs.unity3d.com/Documentation/Components/class-Texture2D.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Components/class-Texture2D.html</a></p><p>跟网页上的略缩图原理一样，在3D游戏中我们为游戏的贴图生成多重纹理贴图，远处显示较小的物体用小的贴图，显示比较大的物体用精细的贴图。这样能更加有效的减少传输给GPU中的数据。</p><p><strong>8.LOD 、 Per-Layer Cull Distances 、 Occlusion Culling</strong></p><p>LOD (Level Of Detail) 是很常用的3D游戏技术了，其功能理解起来则是相当于多重纹理贴图。在以在屏幕中显示模型大小的比例来判断使用高或低层次的模型来减少对GPU的传输数据，和减少GPU所需要的顶点计算。</p><p>摄像机分层距离剔除(Per-Layer Cull Distances)：为小物体标识层次，然后根据其距离主摄像机的距离判断是否需要显示。</p><p>遮挡剔除（Occlusion Culling）其实就是当某个物体在摄像机前被另外一个物体完全挡住的情况，挡住就不发送给GPU渲染，从而直接降低DRAW CALL。不过有些时候在CPU中计算其是否被挡住则会很耗计算，反而得不偿失。</p><p>以下是这几个优化技术的相关使用和介绍：</p><p>Level Of Detail :</p><p><a href="http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html</a></p><p>Per-Layer Cull Distances :</p><p><a href="http://docs.unity3d.com/Documentation/ScriptReference/Camera-layerCullDistances.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/ScriptReference/Camera-layerCullDistances.html</a></p><p>Occlusion Culling ：</p><p><a href="http://docs.unity3d.com/Documentation/Manual/OcclusionCulling.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/OcclusionCulling.html</a></p><p><strong>9.关于Realtime Shadows（实时阴影）</strong></p><p>实时阴影技术非常棒，但消耗大量计算。为GPU和CPU都带来了昂贵的负担，细节的话参考下面：</p><p><a href="http://docs.unity3d.com/Documentation/Manual/Shadows.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/Shadows.html</a></p><p><strong>10.对GPU优化：采用高效的shader</strong></p><p>a.需要注意的是有些(built-in)Shader是有mobile版本的，这些大大提高了顶点处理的性能。当然也会有一些限制。</p><p>b.自己写的shader请注意复杂操作符计算，类似pow,exp,log,cos,sin,tan等都是很耗时的计算，最多只用一次在每个像素点的计算。不推荐你自己写normalize,dot,inversesqart操作符，内置的肯定比你写的好。</p><p>c.需要警醒的是alpha test，这个非常耗时。</p><p>d.浮点类型运算:精度越低的浮点计算越快。</p><p>在CG/HLSL中–</p><p>float ：32位浮点格式，适合顶点变换运算，但比较慢。</p><p>half：16位浮点格式，适合贴图和UV坐标计算，是highp类型计算的两倍。</p><p>fixed: 10位浮点格式，适合颜色，光照，和其他。是highp格式计算的四倍。</p><p>写Shader优化的小提示:</p><p><a href="http://docs.unity3d.com/Documentation/Components/SL-ShaderPerformance.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Components/SL-ShaderPerformance.html</a></p><p><strong>11.另外的相关优化：</strong></p><p>a.对Draw Call Batching的优化</p><p><a href="http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html</a></p><p>b.对Rendering Statistics Window的说明和提示：</p><p><a href="http://docs.unity3d.com/Documentation/Manual/RenderingStatistics.html" target="_blank" rel="noopener">http://docs.unity3d.com/Documentation/Manual/RenderingStatistics.html</a></p><p>c.角色模型的优化建议</p><p>用单个蒙皮渲染、尽量少用材质、少用骨骼节点、移动设备上角色多边形保持在300<del>1500内(当然还要看具体的需求)、PC平台上1500</del>4000内(当然还要看具体的需求)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;最简单的优化建议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.PC平台的话保持场景中显示的顶点数少于200K~3M，移动设备的话少于10W，一切取决于你的目标GPU与CPU。&lt;/p&gt;
&lt;p&gt;2.如果你用U3D自带的SHADER，在表现不差的情况下选择Mobile或
      
    
    </summary>
    
      <category term="U3D" scheme="http://blog.le-more.com/categories/U3D/"/>
    
    
      <category term="u3d" scheme="http://blog.le-more.com/tags/u3d/"/>
    
  </entry>
  
  <entry>
    <title>Android 重新签名打包</title>
    <link href="http://blog.le-more.com/2018/11/12/cocos/android-e9-87-8d-e6-96/"/>
    <id>http://blog.le-more.com/2018/11/12/cocos/android-e9-87-8d-e6-96/</id>
    <published>2018-11-12T14:23:09.000Z</published>
    <updated>2019-11-09T02:44:58.693Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装JDK 2.cd 到\Java\jdk1.8.0_191\bin 目录 </p><ol start="3"><li><p>生成签名文件</p><p> keytool -genkey -alias androidauto.keystore -keyalg RSA -validity 20000 -keystore demo.keystore</p></li></ol><p>4.解压apk,修改后重新zip压缩，注意是zip,然而改名为demo.apk 5.重新签名 123456签名文件的密码</p><pre><code>jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore demo.keystore -storepass 123456 demo.apk demo.keystore</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装JDK 2.cd 到\Java\jdk1.8.0_191\bin 目录 &lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;生成签名文件&lt;/p&gt;
&lt;p&gt; keytool -genkey -alias androidauto.keystore -keyalg RSA
      
    
    </summary>
    
      <category term="Cocos" scheme="http://blog.le-more.com/categories/Cocos/"/>
    
    
  </entry>
  
  <entry>
    <title>算法研究之---冒泡排序</title>
    <link href="http://blog.le-more.com/2018/09/16/math/e7-ae-97-e6-b3-95/"/>
    <id>http://blog.le-more.com/2018/09/16/math/e7-ae-97-e6-b3-95/</id>
    <published>2018-09-16T02:31:59.000Z</published>
    <updated>2019-11-08T09:59:30.989Z</updated>
    
    <content type="html"><![CDATA[<p>原理：n个元素的数组：第一轮从头开始两两比较，如果前一个大于（或小于）后一个，则交换，然后比较下一个，直到最大的数（或最小的数）移到末尾。第二轮重复第一轮操作，比较的数目为比上轮少1（因为已经定位到1个最大值）；继续比较直到比较的数据为0； 冒泡排序实现：</p><p>void bubble_sort(int array[], int length) {</p><pre><code>for (int i = 1; i&lt;length; ++i) {    for (int j = 0; j &lt; length -i; ++j) {        if (array\[j\] &gt; array\[j + 1\]) {            int const temp = array\[j\];            array\[j\] = array\[j + 1\];            array\[j + 1\] = temp;        }    }}cout &lt;&lt; &quot;冒泡排序：&quot; &lt;&lt; endl;for (int i = 0; i&lt;length; i++) {    cout &lt;&lt; array\[i\] &lt;&lt; endl;}</code></pre><p>}</p><p>优化：因为在经过m（0&lt;m&lt;n）轮比较后，如果在新的一轮比较中无任何交换，说明数组已经是排好序的了，即可终止循环。</p><p>void bubble_sort_2(int array[], int length) {</p><pre><code>//标记是否交换int isSwap; for (int i = 1; i&lt;length; ++i) {    isSwap = 0;    for (int j = 0; j &lt; length -i; ++j) {        if (array\[j\] &gt; array\[j + 1\]) {            int const temp = array\[j\];            array\[j\] = array\[j + 1\];            array\[j + 1\] = temp;            isSwap = 1;        }    }    if (isSwap == 0) break;}cout &lt;&lt; &quot;冒泡排序2：&quot; &lt;&lt; endl;for (int i = 0; i&lt;length; i++) {    cout &lt;&lt; array\[i\] &lt;&lt; endl;}</code></pre><p>}</p><p>冒泡排序的时间复杂度为 o(n^2)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原理：n个元素的数组：第一轮从头开始两两比较，如果前一个大于（或小于）后一个，则交换，然后比较下一个，直到最大的数（或最小的数）移到末尾。第二轮重复第一轮操作，比较的数目为比上轮少1（因为已经定位到1个最大值）；继续比较直到比较的数据为0； 冒泡排序实现：&lt;/p&gt;
&lt;p&gt;v
      
    
    </summary>
    
      <category term="Math" scheme="http://blog.le-more.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>算法研究之—希尔排序</title>
    <link href="http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-96/"/>
    <id>http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-96/</id>
    <published>2018-09-15T12:45:37.000Z</published>
    <updated>2019-11-08T09:59:30.989Z</updated>
    
    <content type="html"><![CDATA[<p>原理：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插” 算法实现：</p><p>void shell_sort(int array[], int length)<br>{<br>    //增量gap，并逐步缩小增量<br>    for (int gap = length / 2; gap &gt; 0; gap /= 2) {<br>        //从第gap个元素，逐个对其所在组进行直接插入排序操作<br>        for (int i = gap; i &lt; length; i++) {<br>            int j = i;<br>            while (j - gap &gt;= 0 &amp;&amp; array[j] &lt; array[j - gap]) {<br>                //插入排序采用交换法<br>                //swap(arr, j, j - gap);<br>                const int temp = array[j];<br>                array[j] = array[j - gap];<br>                array[j - gap] = temp;<br>                j -= gap;<br>            }<br>        }<br>    }</p><pre><code>cout &lt;&lt; &quot;希尔排序：&quot; &lt;&lt; endl;for (int i = 0; i &lt; length; i++) {    cout &lt;&lt; array\[i\] &lt;&lt; endl;}</code></pre><p>}</p><p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原理：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称
      
    
    </summary>
    
      <category term="Math" scheme="http://blog.le-more.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>算法研究之---插入排序</title>
    <link href="http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-98/"/>
    <id>http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-98/</id>
    <published>2018-09-15T06:22:22.000Z</published>
    <updated>2019-11-08T09:59:30.991Z</updated>
    
    <content type="html"><![CDATA[<p>插入排序原理：_插入排序的工作方式像许多人排序一手扑克牌.开始时,我们的左手为空并且桌子上的牌面向下.然后,我们每次从桌子上拿走一张牌并将它插入左手中正确的位置.为了找到一张牌的正确位置,我们从右向左将它与已在手中的每张牌进行比较,拿在左手中的牌总是排序好的. _ INSERTION-SORT 伪代码：</p><pre><code>for j = 1 to A.length    key = A\[j\]    //Insert A\[j\] into the sorted sequence A\[1...j-1\]    i = j - 1    while i &gt; 0 and A\[i\] &gt; key        A\[i+1\] = A\[i\]        i = i-1    A\[i+1\] = key</code></pre><p>代码实现：</p><p>void insertion_sort(int array[],int length, bool asc);</p><p>int main()<br>{<br>    int array[10] = { 2,3,1,5,6,8,10,9,4 };<br>    int length = sizeof(array) / sizeof(array[0]);</p><pre><code>insertion_sort(array, length,true);insertion_sort(array, length, false);system(&quot;pause&quot;);//return 0;</code></pre><p>}</p><p>void insertion_sort(int array[],int length,bool asc)<br>{<br>    for (int j = 1; j&lt;length; j++) {<br>        int key = array[j];<br>        int i = j - 1;<br>        if(asc)<br>        {<br>            while (i &gt;= 0 &amp;&amp; array[i] &gt; key) {<br>                array[i + 1] = array[i];<br>                i = i - 1;<br>            }<br>        }<br>        else<br>        {<br>            while (i &gt;= 0 &amp;&amp; array[i] &lt; key) {<br>                array[i + 1] = array[i];<br>                i = i - 1;<br>            }<br>        }</p><pre><code>    array\[i + 1\] = key;}for (int i = 0; i&lt;length; i++) {    cout &lt;&lt; array\[i\] &lt;&lt; endl;}</code></pre><p>}</p><p>插入排序的时间复杂度为 o(n^2)。 参考：算法导论（原书第3版）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插入排序原理：_插入排序的工作方式像许多人排序一手扑克牌.开始时,我们的左手为空并且桌子上的牌面向下.然后,我们每次从桌子上拿走一张牌并将它插入左手中正确的位置.为了找到一张牌的正确位置,我们从右向左将它与已在手中的每张牌进行比较,拿在左手中的牌总是排序好的. _ INSE
      
    
    </summary>
    
      <category term="Math" scheme="http://blog.le-more.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>算法研究之---开篇</title>
    <link href="http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-97/"/>
    <id>http://blog.le-more.com/2018/09/15/math/e7-ae-97-e6-b3-97/</id>
    <published>2018-09-15T05:39:35.000Z</published>
    <updated>2019-11-08T09:59:30.990Z</updated>
    
    <content type="html"><![CDATA[<p>现在开始写一有关算法的日志 <a href="http://www.le-more.com/?p=404" target="_blank" rel="noopener">每个程序员都应该收藏的算法复杂度速查表</a> <img src="http://www.le-more.com/wp-content/uploads/2018/09/sort_time.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在开始写一有关算法的日志 &lt;a href=&quot;http://www.le-more.com/?p=404&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每个程序员都应该收藏的算法复杂度速查表&lt;/a&gt; &lt;img src=&quot;http://www.le-more
      
    
    </summary>
    
      <category term="Math" scheme="http://blog.le-more.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>每个程序员都应该收藏的算法复杂度速查表</title>
    <link href="http://blog.le-more.com/2018/09/10/math/e6-af-8f-e4-b8-aa/"/>
    <id>http://blog.le-more.com/2018/09/10/math/e6-af-8f-e4-b8-aa/</id>
    <published>2018-09-10T02:08:42.000Z</published>
    <updated>2019-11-08T09:59:30.988Z</updated>
    
    <content type="html"><![CDATA[<p>编译自：<a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com/</a>作者： Eric 原创：<a href="http://lctt.github.io/" target="_blank" rel="noopener">LCTT</a> <a href="https://linux.cn/article-7480-1.html" target="_blank" rel="noopener">https://linux.cn/article-7480-1.html</a> 译者： wxy 本文地址：<a href="https://linux.cn/article-7480-1.html" target="_blank" rel="noopener">https://linux.cn/article-7480-1.html</a></p><h3 id="算法复杂度这件事"><a href="#算法复杂度这件事" class="headerlink" title="算法复杂度这件事"></a>算法复杂度这件事</h3><p>这篇文章覆盖了计算机科学里面常见算法的时间和空间的大 OBig-O 复杂度。我之前在参加面试前，经常需要花费很多时间从互联网上查找各种搜索和排序算法的优劣，以便我在面试时不会被问住。最近这几年，我面试了几家硅谷的初创企业和一些更大一些的公司，如 Yahoo、eBay、LinkedIn 和 Google，每次我都需要准备这个，我就在问自己，“为什么没有人创建一个漂亮的大 O 速查表呢？”所以，为了节省大家的时间，我就创建了这个，希望你喜欢！ — <a href="https://twitter.com/ericdrowell" target="_blank" rel="noopener">Eric</a></p><h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p><img src="http://www.le-more.com/wp-content/uploads/2016/11/remark.png" alt="remark"></p><h3 id="数据结构操作"><a href="#数据结构操作" class="headerlink" title="数据结构操作"></a>数据结构操作</h3><p><img src="http://www.le-more.com/wp-content/uploads/2016/11/data-struct.png" alt="data-struct"></p><h3 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h3><p><img src="http://www.le-more.com/wp-content/uploads/2016/11/sort.png" alt="sort"></p><h3 id="图操作"><a href="#图操作" class="headerlink" title="图操作"></a>图操作</h3><p><img src="http://www.le-more.com/wp-content/uploads/2016/11/graph.png" alt="graph"></p><h3 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作 "></a>堆操作 <img src="http://www.le-more.com/wp-content/uploads/2016/11/stack.png" alt="stack"></h3><h3 id="大-O-复杂度图表"><a href="#大-O-复杂度图表" class="headerlink" title="大 O 复杂度图表"></a>大 O 复杂度图表</h3><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201606/20/123634szm02anm9jm6qqbs.png" alt="Big O Complexity Graph" title="Big O Complexity Graph"></p><p><em>Big O Complexity Graph</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译自：&lt;a href=&quot;http://bigocheatsheet.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bigocheatsheet.com/&lt;/a&gt;作者： Eric 原创：&lt;a href=&quot;http://lctt.gi
      
    
    </summary>
    
      <category term="Math" scheme="http://blog.le-more.com/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ vector list deque map 的优缺点以及区别</title>
    <link href="http://blog.le-more.com/2018/08/30/c++/c-vector-list-deque-map/"/>
    <id>http://blog.le-more.com/2018/08/30/c++/c-vector-list-deque-map/</id>
    <published>2018-08-30T10:37:40.000Z</published>
    <updated>2019-11-09T02:40:51.571Z</updated>
    
    <content type="html"><![CDATA[<p>STL容器，大致分为以下三大类：<br>序列容器：<br>vector、list、deque、string </p><p>关联容器：<br>set、multiset、map、mulmap、hash_set、hash_map、hash_multiset、hash_mulmap </p><p>常用的大概只有vector list map set string<br>下边是几个常用的容器的一些特性的记录，以备所需之时查看。 </p><p>*<em>vector *</em> </p><p>向量 相当于一个数组。在内存中分配一块连续的内存空间进行存储，支持补丁大小的存储。当超过已分配的空间是，会整体重新分配一块内存进行存储。<br>优点<br>1、不指定一块连续内存进行存储，可以像数组一样操作。<br>2、随机访问方便，支持下标访问和vector.at()操作。<br>3、节省空间。 缺点 1、在内部进行插入删除，效率较低。<br>2、只能在末端进行pop和push。<br>3、当动态长度超过默认分配大小后，要整体重新分配、拷贝和施放。 </p><p><strong>list</strong> 双向链表。每个结点都包含一个信息块Info、一个前驱指针Pre和一个后驱指针Post。可不比分配必须的大小，方便的进行插入删除操作。使用的是非连续的 内存空间进行存储。 <strong>优点</strong> 1、不适用连续内存完成动态操作。 2、在内部方便进行插入删除操作。 3、可在两端进行push和pop操作。 <strong>缺点</strong> 1、不支持随机访问，即下标操作和.at()。 2、相对于vector占用内存多。 <strong>deque</strong> 双向队列，在功能上合并了vector和list。 <strong>优点</strong> 1、支持随机访问。 2、可以再两端进行push和pop操作。 3、在内部方便进行插入和删除操作。 <strong>缺点</strong> 占用内存较多。 <strong>map</strong> 映照容器 元素数据是一个键值和一个映照数据组成。键值和数据之间有一一映照的关系。 map采用红黑树实现，插入的键值不能重复，比较函数只对元素的键值进行比较。元素的各项数据可通过键值索引出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;STL容器，大致分为以下三大类：&lt;br&gt;序列容器：&lt;br&gt;vector、list、deque、string &lt;/p&gt;
&lt;p&gt;关联容器：&lt;br&gt;set、multiset、map、mulmap、hash_set、hash_map、hash_multiset、hash_mulma
      
    
    </summary>
    
      <category term="C" scheme="http://blog.le-more.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://blog.le-more.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++开发之---内存对齐</title>
    <link href="http://blog.le-more.com/2018/08/29/c++/c-e5-86-85-e5-ad-98-e5/"/>
    <id>http://blog.le-more.com/2018/08/29/c++/c-e5-86-85-e5-ad-98-e5/</id>
    <published>2018-08-29T10:37:40.000Z</published>
    <updated>2019-11-08T09:59:30.958Z</updated>
    
    <content type="html"><![CDATA[<p>网络数据协议的定义：</p><p>struct tagInfo<br>{<br>    WORD wDataSize;            //数据大小<br>        BYTE cbCheckCode;               //检验码<br>};</p><p>WORD为两个字节，BYTE是一个字节，但是sizeof(tagInfo)大小却是4</p><p>#pragma once<br>#pragma pack(1) //设置1字节对齐</p><p>struct tagInfo<br>{<br>    WORD wDataSize;            //数据大小<br>    BYTE cbCheckCode;                //检验码<br>};</p><p>#pragma pack() //取消设置</p><p>在头文件的开头和结尾处分别设置，然后sizeof(tagInfo)的大小就为3了。 <strong>下面摘自网络：</strong> <strong>内存对齐的原则以及作用？</strong></p><ul><li>结构体内的成员按自身长度自对齐（32位机器上，如char=1，short=2，int=4，double=8），所谓自对齐是指该成员的起始地址必须是它自身长度的整数倍。如int只能以0,4,8这类地址开始。</li><li>结构体的总大小为结构体的有效对齐值的整数倍（默认以结构体中最长的成员长度为有效值的整数倍，当用#pragrma pack（n）指定时，以n和结构体中最长的成员的长度中较小者为其值）。即sizeof的值，必须是其内部最大成员的整数倍，不足的要补齐。</li></ul><p>例如：</p><p>class A<br>{<br>    char c;<br>    int a;<br>    char d;<br>};</p><p>cout &lt;&lt; sizeof(A) &lt;&lt; endl;</p><p>class B<br>{<br>    char c;<br>    char d;<br>    int a;<br>};</p><p>cout &lt;&lt; sizeof(B) &lt;&lt; endl;</p><p>sizeof（A）=12，sizeof（B）=8； 因为左边是1+（3）+4+1+（3）=12，而右边是1+1+（2）+4=8。括号中为补齐的字节。 <strong>内存对齐的作用：</strong> 1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 2、性能原因：经过内存对齐后，CPU的内存访问速度大大提升。 QQ群：239759131 cocos 技术交流 欢迎您</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络数据协议的定义：&lt;/p&gt;
&lt;p&gt;struct tagInfo&lt;br&gt;{&lt;br&gt;    WORD wDataSize;            //数据大小&lt;br&gt;        BYTE cbCheckCode;               //检验码&lt;br&gt;};&lt;/p&gt;
      
    
    </summary>
    
      <category term="C" scheme="http://blog.le-more.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://blog.le-more.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++开发之---单例类的实现</title>
    <link href="http://blog.le-more.com/2018/08/28/c++/c-e5-8d-95-e4-be-8b-e7/"/>
    <id>http://blog.le-more.com/2018/08/28/c++/c-e5-8d-95-e4-be-8b-e7/</id>
    <published>2018-08-28T10:39:00.000Z</published>
    <updated>2019-11-08T09:59:30.959Z</updated>
    
    <content type="html"><![CDATA[<p>单倒模式是一种常见的设计模式，在cocos2d很多地方都使用到。下面贴出来我的一种方式。 Utils.h</p><p>#ifndef __UTILS_H_<br>#define __UTILS_H_</p><p>#define UTILS                       Utils::Instance()</p><p>class Utils<br>{<br>private:<br>    //将构造与析构声明 为私有，防止外部创建对象，因为这个对象是单根类<br>    Utils();<br>    ~Utils();<br>public:<br>    static Utils*    Instance();</p><p>};</p><p>#endif</p><p>Utils.cpp</p><p>#include “Utils.h”</p><p>Utils::Utils()<br>{<br>}</p><p>Utils::~Utils()<br>{<br>}</p><p>Utils* Utils::Instance()<br>{<br>    static Utils instance;</p><pre><code>return &amp;instance;</code></pre><p>}</p><p>原理都是类似的，使用类的静态变量或全局的静态变量保存唯一实例。最重要一点：将构造与析构声明 为私有，防止外部创建对象，保持此类只有唯一一个实例  QQ群：239759131 cocos 技术交流 欢迎您</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单倒模式是一种常见的设计模式，在cocos2d很多地方都使用到。下面贴出来我的一种方式。 Utils.h&lt;/p&gt;
&lt;p&gt;#ifndef __UTILS_H_&lt;br&gt;#define __UTILS_H_&lt;/p&gt;
&lt;p&gt;#define UTILS                
      
    
    </summary>
    
      <category term="C" scheme="http://blog.le-more.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://blog.le-more.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++研究之---C++11 新特性</title>
    <link href="http://blog.le-more.com/2018/08/22/c++/c11-e6-96-b0-e7-89-b9/"/>
    <id>http://blog.le-more.com/2018/08/22/c++/c11-e6-96-b0-e7-89-b9/</id>
    <published>2018-08-22T05:57:02.000Z</published>
    <updated>2019-11-08T09:59:30.962Z</updated>
    
    <content type="html"><![CDATA[<p>总结C++11新特性的功能用法和注意事项</p><ul><li><p><strong>auto</strong> 功能：类型说明符，用于自动获取表达式所属的类型</p><p>//1.auto定义的变量必须有初始值<br>auto item = val1 + val2;//item的初始化为val1和val2相加的结果</p><p>//2.声明多个变量，每个变量类型要相同<br>auto sz = 0,pi = 3.14;//错误：sz和pi类型不一致</p><p>//3.使用引用是使用引用的对象<br>int i = 0, &amp;r = i;<br>auto a = r; // a是一个整数</p><p>//4.auto 忽略顶层const，保留底层const<br>const int ci = i,&amp;cr = ci;<br>auto b = ci; //b是一个整数(ci的顶层const特性被忽略掉了)<br>auto d = &i; //d是一个整形指针(整数的地址就是指向整数的指针)<br>auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</p><p>//一条语句定义多个变量,符号&amp;和<em>只从属于某个声明符，而非基本数据类型，初始值必须是同一类型<br>auto k = ci,&amp;l = i;//k是整数，l是整数引用<br>auto &amp;n = i,</em>p2 = &ci;//错误，i的类型是int 而&amp;ci的类型是const int</p></li><li><p>long long 类型 C++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大</p></li><li><p>列表初始化 用花括号来初始化变量</p><p>//各种初始化<br>int units_sold = 0;<br>int units_sold = {0};<br>int units_sold{0};<br>int units_sold(0);</p><p>//列表初始化如果存在丢失信息的风险，则报错：<br>long double ld = 3.1415926;<br>int a{ld},b = {ld};//错误：转换示执行，因为存在丢失信息的危险<br>int c(ld),d = ld; //正确：转换执行，丢失部分数值</p></li><li><p>空指针 nullptr 特殊类型的字面值，可以转换为任意指针类型； C++程序最好使用nullptr，尽量避免使用NULL;</p><p>//下面等价<br>int *p1 = nullptr;<br>int *p2 = 0;<br>//需要#include cstdlib<br>int *p3 = NULL</p></li><li><p>constexpr 变量 constexpr声明的变量由编译器来验证变量值是否是一个常量表达式； constexpr声明的变量一定是一个常量，而且必须用常量表达式初始化； constexpr声明的类型为字面值类型（算术，引用 和指针），自定义、IO库，string类型不属于。 constexpr指针初始值必须是nullptr或0，或是固定地址的对象(函数体之外的对象)</p><p>constexpr int mf = 20;//20是常量表达式<br>constexpr int limit = mf + 1; //mf +1 是常量表达式<br>constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句</p><p>//仅对指针有效，与指对象无关<br>const int *p = nullptr; //p是一个指向整形常量指针<br>constexpr int *q = nullptr;//q 是一个指向整数的常量指针</p><p>//constexpr指针既可以指向常量也可以指向一个非常量<br>constexpr int *np = nullptr;//np是一个指向号数的常量指针<br>int j = 0;<br>constexpr int i = 42;<br>//i和j 都必须定义在函数体之外<br>constexpr const int *p = &i;//p是常量指针，指向整型常量i<br>constexpr int *p1 = &j;、、//p1是常量指针，指向整数j</p></li><li><p>类型别名using</p><p>//传统方法 typedef<br>typedef double wages;//wages是double的同义词</p><p>//using<br>using SI = Sales_item; //SI是Sales_item的同义词</p><p>//指针、常量和类型别名<br>typedef char *pstring;//pstring 是指向char 的指针<br>const pstring cstr = 0;//cstr是指向char的常量指针<br>const pstring *ps;//ps是一个指针，它的对象是指向char的常量指针<br>//如果理解成:const char *cstr = 0;//是对const pstring cstrr 的错误理解</p></li><li><p>decltype 类型指示符 选择并返回操作数的数据类型</p><p>decltype(f()) sum = x; //sum的类型就是函数f的返回类型</p><p>//decltype处理顶层const和引用的方式与auto不同<br>const int ci = 0,&amp;cj = ci;<br>decltype(ci) x = 0; //x是const int<br>decltype(cj ) y = x; //y是const int&amp;,y绑定到变量x<br>decltype(cj) z; //错误 z是一个引用，必须初始化</p><p>//如果decltype使用的表达式不是一个变量，则以返回的表达式结果对应类型<br>int i = 42,<em>p = &amp;i,&amp;r = i;<br>decltype(r + 0) b; //正确:加法的结果是int,因此b是一个int<br>decltype(</em>p) c; //错误：c是int&amp; 必须初始化</p><p>//decltype 的表达式如果是加上了括号的变量，结果将是引用<br>decltype((i)) d;//错误：d是int&amp;,必须初始化<br>decltype(i) e;//正确：e是一个(未初始化的)int</p><p>//使用decltype简化函数返回类型<br>int odd[] = {1,3,5};<br>int even[] = {0,2,4};<br>//返回一个指针，指向含有3个整数的数组<br>decltype(odd) *arrPtr(int i ){</p><pre><code>return (i%2)?&amp;odd:&amp;even;</code></pre><p>}</p></li><li><p>类内初始化 初始化和赋值不同，一个是没值，一个是有值</p></li><li><p>范围for 遍历给定序列中的每个元素并对序列中的每个值执行某种操作</p><p>//语法<br>for(declaration : expression)</p><pre><code>statement</code></pre><p>//示例<br>string str(“some string”);<br>for(auto c : str) cout &lt;&lt; c &lt;&lt;endl;<br>for(auto &amp;c : s) c = toupper(c);//转为大写</p></li><li><p>vector对象的vector</p><p>vector&lt;vector<int>&gt;</int></p></li><li><p>vector对象列表初始化</p><p>vector<string> articles = {“a”,”an”,”the”};<br>vector<string> v1(“a”,”an”,”the”);//错误</string></string></p></li><li><p>容器的cbegin和cend函数 类似于begin和end，只是返回的是const_iterator</p><p>auto it2 = v.cbegin();//it3的类型是vector<int>::const_iterator</int></p></li><li><p>函数begin和end 和容器功能类似，以数组为参数</p><p>int ia[] = {0,1,2,3,4,5,6,7};<br>int *beg = begin(ia);//指向首元素的指针<br>int *last = end(ia);//指向尾元素的下一个位置的指针</p><p>//示例<br>//pbeg指向arr的首元素，pend指向arr的尾元素的下一位置<br>int *pbeg = begin(arr),*pend = end(arr);<br>//寻找第一个负值元素<br>wile(pbeg != pend &amp;&amp; *pbeg &gt;=0) ++pbeg;</p></li><li><p>除法舍入规则 商一律向0取整(直接切除小数部分)</p></li><li><p>sizeof用于类成员 使用作用域运算符来获取类成员的大小，sizeof运算符无须提供一个具体的对象。</p></li><li><p>initializer_list类 标准库类型，用于表示某种特定类型的值的数组</p><p>//是一种模板类型,注意元素是常量值<br>initializer_list<string> ls;//initializer_list的元素类型是string<br>initializer_list<int> li;</int></string></p><p>//示例<br>void error_msg(initializer_list<string> il)<br>{</string></p><pre><code>for(auto beg = il.begin();beg!= il.end();++beg) cout &lt;&lt; *beg &lt;&lt; &quot;&quot;;cout &lt;&lt;endl;</code></pre><p>}<br>//调用 expected 和actual是string对象<br>if(expected != actual) error_msg({“functionX”,expected,actual});<br>else error_msg({“fuctionX”,”okay”});</p></li><li><p>列表初始化返回值 函数可以返回花括号包围的值的列表</p><p>vector<string> process()<br>{</string></p><pre><code>return {};//return {&quot;fuctionX&quot;,&quot;okay&quot;};</code></pre><p>}</p></li><li><p>尾置返回类型 较适用于返回类型比较复杂的函数（数组的指针或数组的引用）</p><p>//func接受一个int类型的实参,返回一个指针，该指针指向含有10个整数的数组<br>auto func(int i)-&gt;int (*)[10];//注意加括号和不加括号的区别</p></li><li><p>constexpr函数 能用于常量表达式的函数：函数返回类型及所有形参的类型都得是字面值类型；函数体必须有且只有一条return语句</p><p>constexpr int new_sz() {return 42;}<br>constexpr int foo = new_sz();//正确：foo是一个常量表达式</p><p>//函数体内也可以包含其他语句，只有这些语句在运行时不执行任何操作（空语句，类型别名，using声明）<br>//如果arg是常量表达式,scale(arg）也是常量表达式<br>constexpr size_t scale(size_t cnt){return new_sz() * cnt}</p><p>//当scale的实参是常量表达式时，它的返回值也是常量表达式<br>int arr[scale(2)]; //正确<br>int i = 2;<br>int a2[scale(i)]; //错误，scale(i)不是常量表达式</p></li><li><p>=default 生成默认构造函数 通过在参数列表后面写上=default，要求编译器生成构造函数。可以和声明一起出来在类的内部（内联），也可以作为定义出现在类的外部。</p><p>Sales_data() = default;</p></li><li><p>类对象成员类内初始化</p><p>class Window_mgr{<br>private:</p><pre><code>//这个Window_mgr追踪的Screen//默认情况下，一个Window_mgr包含一个标准尺寸的空白Screenstd::vector&lt;Screen&gt; screens{Screen(24,80,&apos;&apos;)};</code></pre><p>}</p></li><li><p>委托构造函数 使用它所属类的其他构造函数执行它自己的初始化过程（把它职责委托给了其他构造函数）</p><p>class Sales_data{<br>public:</p><pre><code>//非委托构造函数使用对应的实参初始化成员Sales\_data(std::string s,unsigned cnt,double price):bookNo(s),units\_sold(cnt),revenue(cnt *price){}//委托构造Sales\_data():Sales\_data(&quot;&quot;,0,0){}</code></pre></li><li><p>constexpr构造函数 符合构造函数要求（没有返回语句），符合constexpr函数要求（拥有唯一可执行语句就是返回语句），一般函数是空的。可声明=default或=delete</p><p>//constexpr构造函数必须初始化所有数据成员，初始值使用constexpr构造函数或一条常量表达式<br>class Debug{<br>public:</p><pre><code>constexpr Debug(bool b = true):hw(b),io(b),other(b){}constexpr bool any(){return hw||io||other;}</code></pre><p>}</p><p>//constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型<br>constexpr Debug io_sub(false,true,false);<br>if(io_sub.any()) cerr&lt;&lt;”print appropriate error message”&lt;&lt;endl;</p></li><li><p>用string对象处理文件名 IO参数可以使用库类型string的对象</p></li><li><p>array和forward_list容器 与内置数组相比,array是一种更安全、更容易使用的数组类型；array对象的大小是固定的，不支持添加和删除元素以及改变容器的大小操作。 forward_list目标是达到与最好手写的单向链表数据结构相当的性能，没有size操作</p></li><li><p>容器的cbegin和cend函数 无论容器元素是否是常量，返回值都是const_iterator</p><p>auto it3 = v.cbegin(); //it3的类型是vector<int>::const_iterator</int></p></li><li><p>容器的列表初始化</p><p>list<string> authors = {“M”,”S”,”A”};<br>vector&lt;const char*&gt; art = {“a”,”an”,”the”};</string></p></li><li><p>容器的非成员函数swap swap操作交换两个相同类型容器的内容。调用后，元素交换(本身未交换，只是交换了两个容器的数据结构)</p><p>vector<string> svec1(10); //10个元素<br>vector<string> svec2(24);<br>swap(svec1,svec2);</string></string></p></li><li><p>容器insert成员的返回类型 insert返回指向第一个新加入元素的迭代器，如果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p><p>list<string> lst;<br>auto iter = lst.begin();<br>while(cin &gt;&gt; word)</string></p><pre><code>iter = lst.insert(iter,word);//等价于调用push_front</code></pre></li><li><p>容器的emplace成员的返回类型 emplace_front,empace和emplace_back 操作构造元素（相对于push或insert拷贝），对应push_front,insert和push_back,将元素旋转在容器的头部、一个指定位置之前或窗口尾部</p></li><li><p>shrink_to_fit 适用于vector,string和deque，capacity和reserve只适用于vector和string</p><p>c.shrink_to_fit();//将capacity()减少为与size()相同的大小</p></li><li><p>string的数值转换函数</p><p>int i = 42;<br>string s = to_string(i);//将整数i转换为字符表示形式<br>double d = stod(s);//将字符串s转换为浮点数</p><p>//转换s中以数字开始的第一个子串，结果d = 3.14<br>string s2 = “pi = 3.14”;<br>d = stod(s2.substr(s2.find_first_of(“+-.0123456789”)));</p></li><li><p>lambda匿名函数 可调用对象(callable object)(函数，函数指针，重载运算符的类，lambda表达式) lambda:未命名的内联函数，可定义在函数内部</p><p>//capture list(捕获列表)，通常为空；<br>[capture list](parameter list) -&gt; return type{function body}</p><p>//可忽略参数列表和返回类型，但必包含捕获列表和函数体<br>//空参数列表，推断返回类型<br>auto f = [] {return 42;};<br>cout &lt;&lt; f() &lt;&lt;endl;//调用</p><p>//传参<br>[](const string &amp;a,const string &amp;b){return a.size()&lt; b.size()}<br>//调用示例<br>stable_sort(words.begin(),words.end(),[](const string &amp;a,const string &amp;b){return a.size&lt;b.size();});</p><p>//捕获列表<br>[sz](const string &amp;a){ return a.size &gt;=sz;};</p><p>//调用find_if<br>auto wc = find_if(words.begin(),words.end(),</p><pre><code>\[sz\](const string &amp;a){ return a.size &gt;=sz;})</code></pre><p>//for_each<br>for_each(wc,words.end(),</p><pre><code>\[\](const string &amp;s){cout &lt;&lt; s &lt;&lt; &quot; &quot;;});</code></pre><p>cout &lt;&lt; endl;</p><p>//值捕获<br>void fcn1()<br>{</p><pre><code>size_t v1 = 42;auto f = \[v1\]{return v1;};v1 = 0;auto j = f();//j为42;</code></pre><p>}</p><p>//引用捕获<br>void fcn2(){</p><pre><code>size_t v1 = 42;auto f2 = \[&amp;v1\]{return v1;};v1 = 0;auto j = f2();//j为0，</code></pre><p>}</p><p>//隐式捕获<br>//sz为隐式捕获，值捕获方式<br>wc = find_if(words.begin(),words.end(),</p><pre><code>\[=\](const string &amp;s){return s.size()&gt;=sz;})</code></pre><p>//可变lambda<br>void fcn3(){</p><pre><code>size_t v1 = 42;//f可以改变它所捕获的变量的值auto f = \[v1\]() mutable{return ++v1;};v1 = 0;auto j = f(); //是为43;</code></pre><p>}</p><p>//尾置返回类型<br>transform(vi.begin(),vi.end(),vi.begin(),</p><pre><code>\[\](int i) -&gt; int{if(i&lt;0) return -i; else return i;});</code></pre></li><li><p>标准bind 在functional文件中定义，通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表</p><p>auto new Callable = bind(callable,arg_list);</p><p>//check6是一个可调用对象，接受一个string类型的参数<br>//并用此string和值6来调用check_size<br>auto check6 = bind(check_size,_1,6);//_1参数占位符</p><p>string s = “hello”;<br>bool b1 = check6(s);//check6(s)会调用check_size(s,6);</p><p>//lambada的find_if<br>auto wc = find_if(words.begin(),words.end(),[sz](const string &amp;a))<br>//替换为<br>auto wc = find_if(words.begin(),words.end(),bind(check_size,_1,siz));</p><p>//_n为placeholders命名空间所定义,functional头文件中<br>using std::placeholders::_1;<br>//使用所有的定义<br>using std::placeholders</p><p>//bind的参数<br>//g是一个有两个参数的可调用对象<br>auto g = bind(f,a,b,_2,c,_1);<br>//示例<br>//g(_1,_2) 映射为<br>//f(a,b,_2,c_1)</p><p>//用bind重排参数顺序<br>//按单词长度由短到长排序<br>sort(words.begin(),words.end(),isShorter);<br>//按单词长度由长到短排序<br>sort(words.begin(),words.end(),bind(isShorter,_2,-1));</p><p>//绑定引用参数,ref和cref(const引用类) 定义与functional<br>//为了替换一个引用方式捕获ostream的lambda:<br>//os是一个局部变量，引用一个输出流<br>//c是一个局部变量，类型为char<br>for_each(words.begin(),words.end(),[&amp;os,c](const string &amp;s){os &lt;&lt; s &lt;&lt; c;});<br>//相同的函数<br>ostream &amp;print(ostream &amp;os,const string &amp;s,char c){</p><pre><code>return os&lt;&lt;s &lt;&lt;c;</code></pre><p>}<br>//用bind代替os的捕获是错误的,os不能拷贝<br>for_each(words.begin(),words.end(),bind(print,os,_1, ‘’));<br>//可以使用标准的ref函数<br>for_each(words.begin(),words.end(),bind(print,ref(os),_1,’’));</p></li></ul><p>待续… 汇总自：C++Primer 第五版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结C++11新特性的功能用法和注意事项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;auto&lt;/strong&gt; 功能：类型说明符，用于自动获取表达式所属的类型&lt;/p&gt;
&lt;p&gt;//1.auto定义的变量必须有初始值&lt;br&gt;auto item = val1 + val2;
      
    
    </summary>
    
      <category term="C" scheme="http://blog.le-more.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://blog.le-more.com/tags/c/"/>
    
      <category term="c++11" scheme="http://blog.le-more.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>C++研究之---virtual 解析</title>
    <link href="http://blog.le-more.com/2018/08/22/c++/c-virtual-e8-a7-a3-e6-9e-90/"/>
    <id>http://blog.le-more.com/2018/08/22/c++/c-virtual-e8-a7-a3-e6-9e-90/</id>
    <published>2018-08-22T02:50:22.000Z</published>
    <updated>2019-11-08T09:59:30.961Z</updated>
    
    <content type="html"><![CDATA[<p>OO编程有三大特性：封装，继承，多态 在C++中，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。静态多态即函数重载，在同一类内相同的函数名，不同的参数列表。相对简单，现在重点分析动态多态。 <strong>虚函数</strong> C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 通过以上这段话，我们知道动态多态主要是通过虚函数实现，而虚函数(Virtual Function)则是通过一张虚函数表(Virtual Table)来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。我们通过一些代码来了解这个概念：</p><p>typedef void(*pFun)(void);//函数指针</p><p>class Base {<br>public:</p><pre><code>virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; }virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; }virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; }</code></pre><p>};</p><p>void FunTest()<br>{<br>    Base b;</p><pre><code>cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;pFun* fun = (pFun*)*(int*)&amp;b;while (*fun) {    (*fun)();    fun++;}</code></pre><p>}</p><p>int main()<br>{<br>    FunTest();<br>    getchar();</p><pre><code>return 0;</code></pre><p>}</p><p>在VS2013编译器win32的测试结果为：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309987.png" alt="这里写图片描述"></p><p>我们来看看虚函数表的地址0x00DF820里面存了什么?</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309989.png" alt="这里写图片描述"></p><p>通过上图我们知道，通过Base类实例化的对象b里面(有3个虚函数)有一个指向虚函数表的指针，也就是我们上面的0x00DF820，而在这个虚函数表中，分别存了3个虚函数的地址，我们通过函数指针fun可以访问到这些函数，因此就得到我们的输出结果了。通过sizeof(Base)=4也说明此时b对象仅仅存有一个指针，指向虚函数表。 所以就得到了我们的对象模型：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309990.png" alt="这里写图片描述"></p><p>注意：在上面这个图中，虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\0”一样，其标志了虚函数表的结束，也就是我们这里虚函数表的最后地址存的全是0。注意这个结束标志的值在不同的编译器下是不同的。 <strong>一般继承(无虚函数覆盖)</strong></p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092310991.png" alt="这里写图片描述"></p><p>注意到： 1. 虚函数按照其声明顺序放于表中。 2. 父类的虚函数在子类的虚函数前面。 <strong>一般继承(有虚函数覆盖)</strong></p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092310992.png" alt="这里写图片描述"></p><p>注意到： 1. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 2. 没有被覆盖的函数依旧。 因此对于程序：</p><p>Base *b = new Derive();</p><p>b-&gt;f();</p><p>  由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 <strong>多重继承(无虚函数覆盖)</strong></p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092310993.png" alt="这里写图片描述"></p><p>注意到： 1. 对于实例Derived d的对象，每个父类都有存有一个指针，指向对应的虚函数表。 2. 子类的成员函数被放到了第一个父类的表中。(第一个父类是按照声明顺序来判断的) <strong>多重继承(有虚函数覆盖)</strong></p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092310994.png" alt="这里写图片描述"></p><p>我们可以写一段代码对上图进行测试：</p><p>typedef void(*pFun)(void);</p><p>class Base1 {</p><p>public:</p><pre><code>virtual void f() { cout &lt;&lt; &quot;Base1::f&quot; &lt;&lt; endl; }virtual void g() { cout &lt;&lt; &quot;Base1::g&quot; &lt;&lt; endl; }virtual void h() { cout &lt;&lt; &quot;Base1::h&quot; &lt;&lt; endl; }</code></pre><p>};</p><p>class Base2 {</p><p>public:</p><pre><code>virtual void f() { cout &lt;&lt; &quot;Base2::f&quot; &lt;&lt; endl; }virtual void g() { cout &lt;&lt; &quot;Base2::g&quot; &lt;&lt; endl; }virtual void h() { cout &lt;&lt; &quot;Base2::h&quot; &lt;&lt; endl; }</code></pre><p>};</p><p>class Base3 {</p><p>public:</p><pre><code>virtual void f() { cout &lt;&lt; &quot;Base3::f&quot; &lt;&lt; endl; }virtual void g() { cout &lt;&lt; &quot;Base3::g&quot; &lt;&lt; endl; }virtual void h() { cout &lt;&lt; &quot;Base3::h&quot; &lt;&lt; endl; }</code></pre><p>};</p><p>class Derived : public Base1, public Base2, public Base3 {</p><p>public:</p><pre><code>virtual void f() { cout &lt;&lt; &quot;Derived::f&quot; &lt;&lt; endl; }virtual void g1() { cout &lt;&lt; &quot;Derived::g1&quot; &lt;&lt; endl; }</code></pre><p>};</p><p>void FunTest()<br>{<br>    Derived d;</p><pre><code>cout &lt;&lt; sizeof(Derived) &lt;&lt; endl;//访问Base1虚函数表pFun* fun = (pFun*)*((int*)&amp;d + 0);while (*fun) {    (*fun)();    fun++;}cout &lt;&lt; endl;//访问Base2虚函数表fun = (pFun*)*((int*)&amp;d + 1);while (*fun) {    (*fun)();    fun++;}cout &lt;&lt; endl;//访问Base3虚函数表fun = (pFun*)*((int*)&amp;d + 2);while (*fun) {    (*fun)();    fun++;}</code></pre><p>}</p><p>int main()<br>{</p><pre><code>FunTest();return 0;</code></pre><p>}</p><p>最后显示结果为：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092310995.png" alt="这里写图片描述"></p><p>虚函数表总结 Base虚表：Base类如果有虚函数的话，就按照虚函数出现的先后次序来填写续表 Derived虚表：对于继承Base类的对象，首先按照Base类的虚表格式复制，如果有重写(覆盖)基类的虚函数，则在对应的位置修改，不改变次序。如果派生类中新增虚函数，则将这虚函数填写到第一个父类虚函数后面即可。 <strong>虚继承</strong></p><p>class B<br>{<br>public:<br>    int _b;<br>};</p><p>class C1 : public B<br>{<br>public:<br>    int _c1;<br>};</p><p>class C2 : public B<br>{<br>public:<br>    int _c2;<br>};</p><p>class D :public C1, public C2<br>{<br>public:<br>    int _d;<br>};</p><p>int main()<br>{<br>    D d;<br>    //d._b = 10;错误，访问不明确<br>    d.C1::_b = 10;//正确<br>    d.C2::_b = 10;//正确</p><pre><code>return 0; </code></pre><p>}</p><p>为什么会出现这样的问题? 我们知道它们的继承层次如下图所示：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309980.png" alt="这里写图片描述"></p><p>这种看似菱形的多继承会带来二义性：也就是说D中_b到底是从C1这条路继承而来的还是从C2这条路继承而来的?C++中为了避免这种访问不明确，从而引入了虚拟继承的机制。 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如上述类D继承自类C1、C2，而类C1、C2都继承自类B，因此在类D中两次出现类B中的变量。为了节省内存空间，可以将C1、C2对B的继承定义为虚拟继承，而B就成了虚拟基类。实现代码如下：</p><p>class B<br>{<br>public:<br>    int _b;<br>};</p><p>class C1 :virtual public B<br>{<br>public:<br>    int _c1;<br>};</p><p>class C2 :virtual public B<br>{<br>public:<br>    int _c2;<br>};</p><p>class D :public C1, public C2<br>{<br>public:<br>    int _d;<br>};</p><p>int main()<br>{<br>    D d;<br>    d._d = 4;</p><pre><code>return 0;</code></pre><p>}</p><p>这样就可以达到我们的要求了，直接使用d._d访问到_d。然而虚继承到底是一种怎么样的实现机制?我们不妨在加不加virtual这两中情况下看下在内存中D d这个对象模型是怎么样的? 对于普通继承，我们通过VS2013的内存窗口可以看到：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309981.png" alt="这里写图片描述"></p><p>先是C1类中的成员，再是C2类中的成员，最后是D类自己的成员，此时sizeof(D) = 20。而一旦加了虚继承了，变化就比较明显了，如下图：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309982.png" alt="这里写图片描述"></p><p><strong>题目</strong></p><ul><li>1.以下代码输出什么：</li></ul><p>class C {<br>public:<br>    virtual string toString()<br>    {<br>        return “class C”;<br>    }<br>};</p><p>class B : public C {<br>public:<br>    /*virtual*/ string toString()<br>    {<br>        return “class B”;<br>    }<br>};</p><p>class A : public B {<br>public:<br>    /*virtual*/ string toString()<br>    {<br>        return “class A”;<br>    }<br>};</p><p>int main()<br>{</p><p> C *pC = new A();<br> cout &lt;&lt; pC-&gt;toString().c_str() &lt;&lt; endl;<br> delete pC;</p><p> pC = new B();<br> cout &lt;&lt; pC-&gt;toString().c_str() &lt;&lt; endl;</p><p> cout &lt;&lt; endl;<br> system(“pause”);</p><p> return 0;<br>}</p><p>结果：输出class A;class B 分析：如果基类定义了虚同名函数，那么派生类中的同名函数自动变成了虚函数</p><ul><li>2</li></ul><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309984.png" alt="这里写图片描述"></p><p>对这四种情况分别求sizeof(a), sizeof(b)。结果是什么样的呢?我在VS2013的win32平台测试结果为： 第一种：4，12 第二种：4，4 第三种：8，16 第四种：8，8 解释：首先我们看a类，我们知道每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表，再加上如果有数据，根据内存对齐机制，四种情况的类a所占的字节数应该是没有什么问题的。我们再看sizeof(B)，我们先看普通继承，对于普通继承仅仅是在原来的基础对虚表指针指向的虚函数表进行改写，类B依旧只有一个虚表指针，再加上如果有数据，根据内存对齐机制，所以第二种和第四种情况下，sizeof(B)分别为4和8。然而对于虚拟继承，会增加了一个偏移指针，而且由于类B中新增了虚函数，所以它的一般对象模型为这样(具体为什么是这样本文菱形虚拟继承会讲)：</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20161101/20161101092309986.png" alt="这里写图片描述"></p><p>根据图示，在第一种的情况下，由于没有对应的数据成员，所以大小为12个字节。在第三种情况下，子类有自己的数据成员，而基类没有，所以删去最后一项，大小就是16个字节了</p><ul><li>3.下面代码输出什么</li></ul><p>class A<br>{<br>public:<br>    void show(int val) { cout &lt;&lt; “A–” &lt;&lt; val &lt;&lt; “–A”; }<br>};</p><p>class B : public A<br>{<br>public:<br>    void show(int val) { cout &lt;&lt; “B–” &lt;&lt; val &lt;&lt; “–B”; }<br>};</p><p>int main()<br>{<br>    A* p = new B;<br>    p-&gt;show(5);</p><pre><code>cin.get();</code></pre><p>}</p><p>结果：A–5–A 分析：这就是隐藏 隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下： （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，且参数也相同，但基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 （3）但是，《Effective C++》条款36说：绝不重新定义继承而来的non-virtual函数，所以就不要这么做了。 转自：(部分重新整理) <a href="http://www.2cto.com/kf/201701/561029.html" target="_blank" rel="noopener">解析虚函数表和虚继承</a> <a href="http://www.cnblogs.com/jiayith/p/3939683.html" target="_blank" rel="noopener">C++类成员函数的 重载、覆盖和隐藏区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OO编程有三大特性：封装，继承，多态 在C++中，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。静态多态即函数重载，在同一类内相同的函数名，不同的参数列表。相对简单，现在重点分析动态多态。 &lt;strong&gt;虚函数&lt;/strong&gt; C++中的虚函
      
    
    </summary>
    
      <category term="C" scheme="http://blog.le-more.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://blog.le-more.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>服务器开发之---Redis</title>
    <link href="http://blog.le-more.com/2018/08/04/server/e6-9c-8d-e5-8a-a1-e5-redis/"/>
    <id>http://blog.le-more.com/2018/08/04/server/e6-9c-8d-e5-8a-a1-e5-redis/</id>
    <published>2018-08-04T04:27:01.000Z</published>
    <updated>2019-11-08T09:59:30.997Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis 教程</a></p><h5 id="1-安装（Mac"><a href="#1-安装（Mac" class="headerlink" title="1.安装（Mac)"></a>1.安装（Mac)</h5><p> 1. 官网<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a> 下载最新的稳定版本,这里是3.2.0</p><p> 2. sudo mv 到 /usr/local/</p><ol start="3"><li><p>sudo tar -zxf redis-3.2.0.tar 解压文件</p><p>4. 进入解压后的目录 cd redis-3.2.0</p><p>5. sudo make test 测试编译</p><p>6. sudo make install</p></li></ol><p>win:<a href="https://github.com/ServiceStack/redis-windows" target="_blank" rel="noopener">https://github.com/ServiceStack/redis-windows</a></p><h5 id="2-启动连接"><a href="#2-启动连接" class="headerlink" title="2.启动连接"></a>2.启动连接</h5><p>1.启动服务：redis-server<br>  启动服务：redis-server ./redis.conf     #加载配置</p><p>2.连接： <strong>redis-cli -h 127.0.0.1 -p 6379</strong><br>3.设置键值对： <strong>set myKey abc</strong><br>4.取出键值对： <strong>get myKey</strong></p><p>3.关闭服务</p><p>redis-cli shutdown</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.runoob.com/redis/redis-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis 教程&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;1-安装（Mac&quot;&gt;&lt;a href=&quot;#1-安
      
    
    </summary>
    
      <category term="Server" scheme="http://blog.le-more.com/categories/Server/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器开发之---Java问题汇总</title>
    <link href="http://blog.le-more.com/2018/08/01/server/java-e5-bc-80-e5-8f-91-e4/"/>
    <id>http://blog.le-more.com/2018/08/01/server/java-e5-bc-80-e5-8f-91-e4/</id>
    <published>2018-08-01T13:11:05.000Z</published>
    <updated>2019-11-08T09:59:30.997Z</updated>
    
    <content type="html"><![CDATA[<p>工作十余载，常憾浅尝辄止于各种技术，亦曾屡试专攻于一技，怎奈现实总不能遂人意，为了生活，只能不断前进再前进….</p><ul><li><p>游戏服务器开发掌握的技能： 1）语言：Java(Lua,Python Linux Shell etc.) 教程：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">Java 教程</a>; 《Java程序员修炼之道》 2)  网络：Netty(Mina etc.) ;SpringMVC(HTTP) Protobuf,Json;教程：<a href="https://www.yiibai.com/spring_mvc/" target="_blank" rel="noopener">Spring MVC教程</a> ;    <a href="https://www.yiibai.com/netty/" target="_blank" rel="noopener">Netty教程</a>; <a href="https://blog.csdn.net/u013252773?t=1" target="_blank" rel="noopener">Netty4.0学习笔记系列</a>;《Netty实战》 3)  数据库：Mysql(Redis etc.);MyBatis框架 教程：<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程（Redis）</a>;  <a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>(MySql) 4)  其他：Java NIO;Java多线程；Java并发；书：《Java 7并发编程实战手册》</p></li><li><p>术语： 1）JDK 开发环境 2)  JRE  运行环境 3)  SE    Standard Edition 标准版 用于桌面或简单的服务器应用平台 4)  ME 移动端 5)  J2(Java 2) 过时的术语 用于面述1998<del>2006的Java版本 6)  SDK 过时的术语 用于面述1998</del>2006的JDK版本 7)  u(Update) Oracle的术语 8)  NetBeans Oracle的集成开发环境</p></li><li><p>POJO(Plain Ordinary Java Object):简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。有时可以作为<a href="https://baike.baidu.com/item/VO" target="_blank" rel="noopener">VO</a>(value -object)或<a href="https://baike.baidu.com/item/dto/16016821" target="_blank" rel="noopener">dto</a>(Data Transform Object)来使用</p></li><li><p>PO(Persistent Object)：持久对象,其属性是跟数据库表的字段一一对应的</p></li><li><p>VO(Value Object)：值对象,其属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。</p></li><li><p>BO(business object)：主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。</p></li><li><p>DTO(Data Transfer Object)：主要用于远程调用等需要大量传输对象的地方</p></li><li><p>transient：类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。</p></li><li><p>volatile：变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。</p></li><li><p>NIO:非阻塞输入输出 Java 4 NIO.1     Java 7 NIO.2</p></li><li><p>ORM:Object Relational Mapping 对象关系映射模型（Hibernate)</p></li><li><p>IoC:控制反转，可以把其看做运行时环境，Java中为依赖注入提供的窗口有Guice,Spring和PicoContainer</p></li><li><p>DI:依赖注入，IoC实现的一种方式。代码解耦并增强其可测试性和易读性的通用技术</p></li><li><p>字符串比较不能使用==，要使用strSource.equals(strDest)，不区分大小写比较使用strSource.equalsIgnoreCase(strDest)</p></li><li><p>ide 报错：</p><p>objc[823]: Class JavaLaunchHelper is implemented in both<br>解决办法：<br>点击Ide最上面菜单的Help-Edit Custom Properties，没有这个properties文件的话，会提示创建，然后在里面加上<br>idea.no.launcher=true</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作十余载，常憾浅尝辄止于各种技术，亦曾屡试专攻于一技，怎奈现实总不能遂人意，为了生活，只能不断前进再前进….&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;游戏服务器开发掌握的技能： 1）语言：Java(Lua,Python Linux Shell etc.) 教程：&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Server" scheme="http://blog.le-more.com/categories/Server/"/>
    
    
  </entry>
  
</feed>
